//+------------------------------------------------------------------+
//|                                              NewsTrader_Pro.mq5 |
//|                                 Professional News Trading (FF)   |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Professional News Trading EA - ForexFactory Edition"
#property link      "https://www.mql5.com"
#property version   "5.00"
#property strict

// Добавляем свойства для индикатора (исправление ошибки)
#property indicator_chart_window
#property indicator_plots 0

#include <Trade/Trade.mqh>

//--- Trading objects
CTrade trade;

//+------------------------------------------------------------------+
//| Enums for EA configuration
//+------------------------------------------------------------------+
enum ENUM_NEWS_STRATEGY {
    STRATEGY_BREAKOUT,     // Стратегия пробоя
    STRATEGY_STRADDLE,     // Стратегия стрэддла  
    STRATEGY_PULLBACK,     // Стратегия пуллбэка
    STRATEGY_FUNDAMENTAL   // Стратегия по фундаментальным данным
};

enum ENUM_RISK_LEVEL {
    RISK_LOW,              // Низкий риск (0.5%)
    RISK_MEDIUM,           // Средний риск (1.0%)
    RISK_HIGH              // Высокий риск (2.0%)
};

enum ENUM_TRAILING_PAUSE_MODE {
    TRAILING_PAUSE_NONE,        // Не останавливать
    TRAILING_PAUSE_TO_INITIAL,  // До начального SL
    TRAILING_PAUSE_TO_BE        // До безубытка
};

//+------------------------------------------------------------------+
//| Input parameters
//+------------------------------------------------------------------+
input group "=== НАСТРОЙКИ ТОРГОВЛИ ==="
input ENUM_NEWS_STRATEGY TradingStrategy = STRATEGY_STRADDLE;  // Торговая стратегия
input ENUM_RISK_LEVEL RiskLevel = RISK_MEDIUM;                // Уровень риска
input string TradingPairs = "EURUSD,GBPUSD,USDJPY,USDCHF,NZDUSD,AUDUSD,XAUUSD";   // Торговые пары (через запятую)

input group "=== НАСТРОЙКИ НОВОСТЕЙ ==="
input bool UseNewsFilter = true;                             // Использовать фильтр новостей
input int MinNewsImpact = 2;                                // Минимальное воздействие (1-3)
input int NewsMinutesBefore = 15;                           // Минут до новости для подготовки
input int NewsMinutesAfter = 60;                            // Минут после новости для торговли
input string NewsCurrencies = "USD,EUR,GBP,JPY,CHF,CAD,AUD,NZD";           // Валюты для мониторинга
input string NewsFilterKeywords = "NFP,CPI,GDP,Interest Rate,PMI,Retail Sales,Employment,PPI,m/m,y/y,Jackson,FOMC,Gov,BOE,BOJ,q/q,Bus"; // Ключевые слова новостей (через запятую)
input bool TradeAllHighImpact = true;                      // Торговать на всех новостях высокой важности

input group "=== УПРАВЛЕНИЕ РИСКАМИ ==="
input double MaxDailyLoss = 5.0;                           // Максимальная дневная потеря (%)
input double MaxSpreadPoints = 30;                         // Максимальный спред (пункты)
input int ConsecutiveLossLimit = 5;                        // Лимит последовательных убытков
input bool UseATRPositionSizing = true;                    // Использовать ATR для размера позиции

input group "=== ТЕХНИЧЕСКИЕ ПАРАМЕТРЫ ==="
input int ATRPeriod = 14;                                  // Период ATR
input double ATRMultiplier = 2.5;                         // Множитель ATR для расстояния
input int MagicNumber = 777888;                            // Магический номер
input int MaxSlippagePoints = 10;                          // Максимальное проскальзывание

input group "=== НАСТРОЙКИ СТОП-ЛОССА И ТЕЙК-ПРОФИТА ==="
input bool UseTrailingStop = true;                        // Использовать Trailing Stop
input double TrailingStopMultiplier = 1.5;               // Множитель ATR для Trailing Stop
input double StopLossMultiplier = 2.0;                   // Множитель дистанции для Stop Loss
input double TakeProfitMultiplier = 3.0;                 // Множитель дистанции для Take Profit

input group "=== ДИНАМИЧЕСКОЕ ОБНОВЛЕНИЕ SL/TP ==="
input bool UpdateSLByATR = false;                        // Обновлять SL по текущему ATR
input int SLUpdateMinutes = 60;                           // Минут между обновлениями SL
input bool UpdateTPByATR = false;                        // Обновлять TP по текущему ATR
input int TPUpdateMinutes = 60;                           // Минут между обновлениями TP
input bool UpdateTrailingByATR = true;                   // Обновлять Trailing по текущему ATR
input int TrailingUpdateMinutes = 30;                     // Минут между обновлениями Trailing
input ENUM_TRAILING_PAUSE_MODE TrailingPauseMode = TRAILING_PAUSE_TO_BE; // Режим паузы Trailing Stop

input group "=== ОГРАНИЧЕНИЯ ВЫСТАВЛЕНИЯ ОРДЕРОВ ==="
input bool UseOrderDistanceLimit = true;                  // Использовать ограничение по расстоянию
input double MinOrderDistancePoints = 10;                 // Минимальное расстояние между группами ордеров (пункты)
input int MaxOrdersPerPriceLevel = 3;                    // Максимум ордеров на одном ценовом уровне
input bool LimitOrdersPerNews = true;                    // Ограничивать ордера для каждой новости отдельно
input int MaxOrdersPerNews = 6;                          // Максимум ордеров на одну новость

input group "=== УПРАВЛЕНИЕ ОТЛОЖЕННЫМИ ОРДЕРАМИ ==="
input bool UseOrderExpiration = true;                     // Использовать истечение срока ордеров
input int OrderExpirationMinutes = 30;                    // Минут после новости для отмены ордеров
input bool CancelOppositeOrdersOnFill = true;            // Отменять противоположные ордера при срабатывании (только для стрэддл)
input bool UpdateOrdersOnNewNews = true;                 // Обновлять ордера при новых новостях
input int MinMinutesBetweenNewsForUpdate = 30;          // Минимум минут между новостями для обновления

input group "=== НАСТРОЙКИ ВРЕМЕНИ ==="
input int GMTOffset = -5;                                  // GMT смещение ForexFactory (EST = -5)
input bool AutoDetectBrokerGMT = true;                     // Автоопределение GMT брокера
input int ManualBrokerGMT = 3;                             // Ручная установка GMT брокера (если автоопределение отключено)

input group "=== FOREXFACTORY НАСТРОЙКИ ==="
input string ForexFactoryURL = "https://www.forexfactory.com/calendar.php"; // URL ForexFactory
input int WebRequestTimeout = 5000;                        // Таймаут веб-запроса (мс)
input int NewsUpdateMinutes = 30;                          // Обновлять новости каждые X минут
input bool LoadTodayOnly = false;                          // Загружать только сегодняшние новости
input int NewsHistoryHours = 2;                            // Показывать прошедшие новости за X часов

input group "=== НАСТРОЙКИ ФУНДАМЕНТАЛЬНОЙ СТРАТЕГИИ ==="
input double FundamentalDeviationPercent = 20.0;          // Минимальное отклонение от прогноза (%)
input double FundamentalATRMultiplier = 1.0;              // Множитель ATR для фундаментальной стратегии
input bool TradeOnlyMajorSurprises = true;                // Торговать только на больших сюрпризах

input group "=== НАСТРОЙКИ ТЕСТЕРА ==="
input bool TesterMode = false;                             // Режим тестера (автоопределение)
input string NewsDataPath = "NewsData";                    // Папка с файлами новостей
input double ActualVariation = 20.0;                      // Вариация факта от прогноза (%)
input double SurpriseVolatilityMultiplier = 2.0;          // Множитель волатильности для сюрпризов

input group "=== НАСТРОЙКИ ПАНЕЛИ НОВОСТЕЙ ==="
input bool ShowNewsPanel = true;                          // Показывать панель новостей
input int PanelX = 10;                                    // Позиция панели X
input int PanelY = 50;                                    // Позиция панели Y
input int PanelWidth = 500;                               // Ширина панели
input int PanelNewsCount = 5;                             // Количество новостей для отображения
input color PanelBackgroundColor = clrBlack;              // Цвет фона панели
input color PanelTextColor = clrWhite;                    // Цвет текста панели
input int PanelFontSize = 8;                              // Размер шрифта панели
input bool EnableSoundAlert = true;                       // Звуковой сигнал перед новостями
input int SoundAlertMinutes = 5;                          // За сколько минут сигнал

//+------------------------------------------------------------------+
//| Global variables
//+------------------------------------------------------------------+
struct NewsEvent {
    datetime time;
    string currency;
    string title;
    int impact;
    double forecast;
    double actual;
    double previous;
    bool processed;
    bool actualReleased;  // Для тестера
    bool hasForecast;     // Флаг наличия прогноза
    
    // Copy constructor
    NewsEvent(const NewsEvent& other) {
        time = other.time;
        currency = other.currency;
        title = other.title;
        impact = other.impact;
        forecast = other.forecast;
        actual = other.actual;
        previous = other.previous;
        processed = other.processed;
        actualReleased = other.actualReleased;
        hasForecast = other.hasForecast;
    }
    
    // Default constructor
    NewsEvent() {
        time = 0;
        currency = "";
        title = "";
        impact = 0;
        forecast = 0;
        actual = 0;
        previous = 0;
        processed = false;
        actualReleased = false;
        hasForecast = false;
    }
};

// Структура для отслеживания параметров позиций
struct PositionInfo {
    ulong ticket;
    string symbol;
    datetime openTime;
    datetime lastSLUpdate;
    datetime lastTPUpdate;
    datetime lastTrailingUpdate;
    double initialSL;
    double openPrice;
    bool trailingPaused;
    double pausedAtPrice;
    
    // Copy constructor (исправление ошибки компиляции)
    PositionInfo(const PositionInfo& other) {
        ticket = other.ticket;
        symbol = other.symbol;
        openTime = other.openTime;
        lastSLUpdate = other.lastSLUpdate;
        lastTPUpdate = other.lastTPUpdate;
        lastTrailingUpdate = other.lastTrailingUpdate;
        initialSL = other.initialSL;
        openPrice = other.openPrice;
        trailingPaused = other.trailingPaused;
        pausedAtPrice = other.pausedAtPrice;
    }
    
    PositionInfo() {
        ticket = 0;
        symbol = "";
        openTime = 0;
        lastSLUpdate = 0;
        lastTPUpdate = 0;
        lastTrailingUpdate = 0;
        initialSL = 0;
        openPrice = 0;
        trailingPaused = false;
        pausedAtPrice = 0;
    }
};

PositionInfo positionsTracking[];

// Структура для отслеживания парных ордеров стрэддла
struct StraddlePair {
    ulong buyTicket;
    ulong sellTicket;
    string symbol;
    datetime newsTime;
    
    StraddlePair() {
        buyTicket = 0;
        sellTicket = 0;
        symbol = "";
        newsTime = 0;
    }
};

StraddlePair straddlePairs[];

// Структура для отслеживания ценовых уровней
struct PriceLevel {
    double price;
    int orderCount;
    datetime newsTime;
    string newsTitle;
    
    PriceLevel() {
        price = 0;
        orderCount = 0;
        newsTime = 0;
        newsTitle = "";
    }
};

// Структура для отслеживания ордеров по символам
struct SymbolOrderInfo {
    string symbol;
    PriceLevel priceLevels[];
    
    SymbolOrderInfo() {
        symbol = "";
        ArrayResize(priceLevels, 0);
    }
};

// Структура для отслеживания ордеров по новостям
struct NewsOrderTracking {
    datetime newsTime;
    string newsTitle;
    string currency;
    int orderCount;
    ulong orderTickets[];
    
    NewsOrderTracking() {
        newsTime = 0;
        newsTitle = "";
        currency = "";
        orderCount = 0;
        ArrayResize(orderTickets, 0);
    }
};

NewsOrderTracking newsOrderTracking[];
SymbolOrderInfo symbolOrders[];

NewsEvent newsCalendar[];
datetime lastNewsCheck = 0;
double dailyPnL = 0;
int consecutiveLosses = 0;
bool tradingHalted = false;
string validPairs[];
bool isTesting = false;
datetime lastLoadedMonth = 0;
int brokerGMTOffset = 0;

int atrHandle;
double currentATR = 0;

// Forward declarations
class CNewsManager;
CNewsManager *newsManagerPtr = NULL;
class CRiskManager;

// Глобальная функция PlacePendingOrder
ulong PlacePendingOrder(ENUM_ORDER_TYPE orderType, string symbol, double price, 
                     double sl, double tp, double volume, datetime expiration) {
    MqlTradeRequest request = {};
    MqlTradeResult result = {};
    
    ZeroMemory(request);
    ZeroMemory(result);
    
    request.action = TRADE_ACTION_PENDING;
    request.symbol = symbol;
    request.volume = volume;
    request.type = orderType;
    request.price = NormalizeDouble(price, (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS));
    request.sl = NormalizeDouble(sl, (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS));
    request.tp = NormalizeDouble(tp, (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS));
    request.magic = MagicNumber;
    request.deviation = MaxSlippagePoints;
    request.comment = StringFormat("News: %s", EnumToString(TradingStrategy));
    
    int filling = (int)SymbolInfoInteger(symbol, SYMBOL_FILLING_MODE);
    if(filling == SYMBOL_FILLING_FOK) {
        request.type_filling = ORDER_FILLING_FOK;
    } else if(filling == SYMBOL_FILLING_IOC) {
        request.type_filling = ORDER_FILLING_IOC;
    } else {
        request.type_filling = ORDER_FILLING_RETURN;
    }
    
    if(UseOrderExpiration && expiration > 0) {
        request.type_time = ORDER_TIME_SPECIFIED;
        request.expiration = expiration;
    } else {
        request.type_time = ORDER_TIME_GTC;
    }
    
    if(!OrderSend(request, result)) {
        return 0;
    }
    
    if(result.retcode == TRADE_RETCODE_DONE || result.retcode == TRADE_RETCODE_PLACED) {
        return result.order;
    } else {
        return 0;
    }
}

// Функции для работы с позициями
int GetPositionTrackingIndex(ulong ticket) {
    for(int i = 0; i < ArraySize(positionsTracking); i++) {
        if(positionsTracking[i].ticket == ticket) {
            return i;
        }
    }
    return -1;
}

void RegisterPosition(ulong ticket, string symbol, double openPrice, double sl) {
    int size = ArraySize(positionsTracking);
    ArrayResize(positionsTracking, size + 1);
    
    positionsTracking[size].ticket = ticket;
    positionsTracking[size].symbol = symbol;
    positionsTracking[size].openTime = TimeCurrent();
    positionsTracking[size].lastSLUpdate = TimeCurrent();
    positionsTracking[size].lastTPUpdate = TimeCurrent();
    positionsTracking[size].lastTrailingUpdate = TimeCurrent();
    positionsTracking[size].initialSL = sl;
    positionsTracking[size].openPrice = openPrice;
    positionsTracking[size].trailingPaused = false;
    positionsTracking[size].pausedAtPrice = 0;
}

void RemovePositionTracking(ulong ticket) {
    int index = GetPositionTrackingIndex(ticket);
    if(index >= 0) {
        ArrayRemove(positionsTracking, index, 1);
    }
}

// Функция для обновления SL/TP по ATR
void UpdatePositionsByATR() {
    datetime currentTime = TimeCurrent();
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;
        
        int trackIndex = GetPositionTrackingIndex(ticket);
        if(trackIndex == -1) continue;
        
        string symbol = PositionGetString(POSITION_SYMBOL);
        double currentSL = PositionGetDouble(POSITION_SL);
        double currentTP = PositionGetDouble(POSITION_TP);
        double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        
        int atrHandleLocal = iATR(symbol, PERIOD_M15, ATRPeriod);
        double atrBuffer[];
        double localATR = 0;
        
        if(CopyBuffer(atrHandleLocal, 0, 0, 1, atrBuffer) > 0) {
            localATR = atrBuffer[0];
        }
        IndicatorRelease(atrHandleLocal);
        
        if(localATR <= 0) continue;
        
        int digits = (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS);
        double point = SymbolInfoDouble(symbol, SYMBOL_POINT);
        double pipSize = (digits == 5 || digits == 3) ? point * 10 : point;
        
        bool modified = false;
        double newSL = currentSL;
        double newTP = currentTP;
        
        if(UpdateSLByATR && 
           (currentTime - positionsTracking[trackIndex].lastSLUpdate) >= SLUpdateMinutes * 60) {
            
            double slDistance = localATR * StopLossMultiplier;
            
            if(posType == POSITION_TYPE_BUY) {
                newSL = openPrice - slDistance;
            } else {
                newSL = openPrice + slDistance;
            }
            
            newSL = NormalizeDouble(newSL, digits);
            
            if(newSL != currentSL) {
                positionsTracking[trackIndex].lastSLUpdate = currentTime;
                modified = true;
            }
        }
        
        if(UpdateTPByATR && 
           (currentTime - positionsTracking[trackIndex].lastTPUpdate) >= TPUpdateMinutes * 60) {
            
            double tpDistance = localATR * TakeProfitMultiplier;
            
            if(posType == POSITION_TYPE_BUY) {
                newTP = openPrice + tpDistance;
            } else {
                newTP = openPrice - tpDistance;
            }
            
            newTP = NormalizeDouble(newTP, digits);
            
            if(newTP != currentTP) {
                positionsTracking[trackIndex].lastTPUpdate = currentTime;
                modified = true;
            }
        }
        
        if(modified) {
            MqlTradeRequest request = {};
            MqlTradeResult result = {};
            
            request.action = TRADE_ACTION_SLTP;
            request.position = ticket;
            request.symbol = symbol;
            request.sl = newSL;
            request.tp = newTP;
            request.magic = MagicNumber;
            
            if(!OrderSend(request, result)) {
                Print("Ошибка обновления SL/TP: ", GetLastError());
            }
        }
    }
}

// Функция для проверки паузы трейлинга
bool ShouldPauseTrailing(int trackIndex, double currentPrice, double currentSL) {
    if(TrailingPauseMode == TRAILING_PAUSE_NONE) return false;
    
    PositionInfo info = positionsTracking[trackIndex];
    
    if(TrailingPauseMode == TRAILING_PAUSE_TO_INITIAL) {
        double distanceToInitial = MathAbs(currentPrice - info.initialSL);
        double requiredDistance = currentATR * TrailingStopMultiplier;
        
        if(distanceToInitial < requiredDistance) {
            if(!info.trailingPaused) {
                positionsTracking[trackIndex].trailingPaused = true;
                positionsTracking[trackIndex].pausedAtPrice = currentPrice;
            }
            return true;
        } else {
            if(info.trailingPaused) {
                positionsTracking[trackIndex].trailingPaused = false;
            }
        }
    } else if(TrailingPauseMode == TRAILING_PAUSE_TO_BE) {
        bool inProfit = false;
        
        if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY) {
            inProfit = currentPrice > info.openPrice;
        } else {
            inProfit = currentPrice < info.openPrice;
        }
        
        if(!inProfit) {
            if(!info.trailingPaused) {
                positionsTracking[trackIndex].trailingPaused = true;
                positionsTracking[trackIndex].pausedAtPrice = currentPrice;
            }
            return true;
        } else {
            double distanceFromBE = MathAbs(currentPrice - info.openPrice);
            double requiredDistance = currentATR * TrailingStopMultiplier;
            
            if(distanceFromBE < requiredDistance) {
                if(!info.trailingPaused) {
                    positionsTracking[trackIndex].trailingPaused = true;
                    positionsTracking[trackIndex].pausedAtPrice = currentPrice;
                }
                return true;
            } else {
                if(info.trailingPaused) {
                    positionsTracking[trackIndex].trailingPaused = false;
                }
            }
        }
    }
    
    return false;
}

// Обновленная функция трейлинг стопа
void UpdateTrailingStop() {
    if(!UseTrailingStop) return;
    
    datetime currentTime = TimeCurrent();
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;
        
        int trackIndex = GetPositionTrackingIndex(ticket);
        if(trackIndex == -1) {
            RegisterPosition(ticket, 
                           PositionGetString(POSITION_SYMBOL),
                           PositionGetDouble(POSITION_PRICE_OPEN),
                           PositionGetDouble(POSITION_SL));
            trackIndex = GetPositionTrackingIndex(ticket);
        }
        
        string symbol = PositionGetString(POSITION_SYMBOL);
        double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        double currentSL = PositionGetDouble(POSITION_SL);
        double currentTP = PositionGetDouble(POSITION_TP);
        ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        
        double point = SymbolInfoDouble(symbol, SYMBOL_POINT);
        
        double trailDistance = currentATR * TrailingStopMultiplier;
        
        if(UpdateTrailingByATR && 
           (currentTime - positionsTracking[trackIndex].lastTrailingUpdate) >= TrailingUpdateMinutes * 60) {
            int atrHandleLocal = iATR(symbol, PERIOD_M15, ATRPeriod);
            double atrBuffer[];
            
            if(CopyBuffer(atrHandleLocal, 0, 0, 1, atrBuffer) > 0) {
                trailDistance = atrBuffer[0] * TrailingStopMultiplier;
                positionsTracking[trackIndex].lastTrailingUpdate = currentTime;
            }
            IndicatorRelease(atrHandleLocal);
        }
        
        double newSL = 0;
        bool shouldModify = false;
        
        if(posType == POSITION_TYPE_BUY) {
            double bid = SymbolInfoDouble(symbol, SYMBOL_BID);
            
            if(ShouldPauseTrailing(trackIndex, bid, currentSL)) {
                continue;
            }
            
            if(bid - openPrice > trailDistance) {
                newSL = bid - trailDistance;
                if(newSL > currentSL) {
                    shouldModify = true;
                }
            }
        } else {
            double ask = SymbolInfoDouble(symbol, SYMBOL_ASK);
            
            if(ShouldPauseTrailing(trackIndex, ask, currentSL)) {
                continue;
            }
            
            if(openPrice - ask > trailDistance) {
                newSL = ask + trailDistance;
                if(newSL < currentSL || currentSL == 0) {
                    shouldModify = true;
                }
            }
        }
        
        if(shouldModify && newSL > 0) {
            trade.PositionModify(ticket, newSL, currentTP);
        }
    }
}

// Функция для отслеживания ордеров по новостям
int GetNewsOrderIndex(datetime newsTime, string newsTitle) {
    for(int i = 0; i < ArraySize(newsOrderTracking); i++) {
        if(newsOrderTracking[i].newsTime == newsTime && 
           newsOrderTracking[i].newsTitle == newsTitle) {
            return i;
        }
    }
    return -1;
}

void RegisterOrderForNews(ulong ticket, datetime newsTime, string newsTitle, string currency) {
    int index = GetNewsOrderIndex(newsTime, newsTitle);
    
    if(index == -1) {
        int size = ArraySize(newsOrderTracking);
        ArrayResize(newsOrderTracking, size + 1);
        newsOrderTracking[size].newsTime = newsTime;
        newsOrderTracking[size].newsTitle = newsTitle;
        newsOrderTracking[size].currency = currency;
        newsOrderTracking[size].orderCount = 0;
        ArrayResize(newsOrderTracking[size].orderTickets, 0);
        index = size;
    }
    
    int ticketCount = ArraySize(newsOrderTracking[index].orderTickets);
    ArrayResize(newsOrderTracking[index].orderTickets, ticketCount + 1);
    newsOrderTracking[index].orderTickets[ticketCount] = ticket;
    newsOrderTracking[index].orderCount++;
}

bool CanPlaceOrderForNews(datetime newsTime, string newsTitle) {
    if(!LimitOrdersPerNews) return true;
    
    int index = GetNewsOrderIndex(newsTime, newsTitle);
    if(index == -1) return true;
    
    return newsOrderTracking[index].orderCount < MaxOrdersPerNews;
}

// Функция для обновления существующих ордеров
void UpdateExistingOrders(string symbol, NewsEvent& news) {
    if(!UpdateOrdersOnNewNews) return;
    
    datetime currentTime = TimeCurrent();
    bool foundRecentNews = false;
    
    for(int i = 0; i < ArraySize(newsOrderTracking); i++) {
        if(newsOrderTracking[i].currency == news.currency) {
            int timeDiff = (int)((news.time - newsOrderTracking[i].newsTime) / 60);
            if(MathAbs(timeDiff) < MinMinutesBetweenNewsForUpdate) {
                foundRecentNews = true;
                break;
            }
        }
    }
    
    if(!foundRecentNews) return;
    
    double currentPrice = SymbolInfoDouble(symbol, SYMBOL_ASK);
    double distance = currentATR * ATRMultiplier;
    
    if(!news.hasForecast) {
        distance *= 1.5;
    }
    
    int digits = (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS);
    double point = SymbolInfoDouble(symbol, SYMBOL_POINT);
    double pipSize = (digits == 5 || digits == 3) ? point * 10 : point;
    
    double distanceInPips = distance / pipSize;

    for(int i = OrdersTotal() - 1; i >= 0; i--) {
        ulong ticket = OrderGetTicket(i);
        if(!OrderSelect(ticket)) continue;
        if(OrderGetInteger(ORDER_MAGIC) != MagicNumber) continue;
        if(OrderGetString(ORDER_SYMBOL) != symbol) continue;
        
        ENUM_ORDER_TYPE orderType = (ENUM_ORDER_TYPE)OrderGetInteger(ORDER_TYPE);
        
        if(orderType == ORDER_TYPE_BUY_STOP || orderType == ORDER_TYPE_SELL_STOP) {
            double newPrice = 0;
            double newSL = 0;
            double newTP = 0;
            
            if(orderType == ORDER_TYPE_BUY_STOP) {
                newPrice = currentPrice + distance;
                newSL = newPrice - (distanceInPips * StopLossMultiplier * pipSize);
                newTP = newPrice + (distanceInPips * TakeProfitMultiplier * pipSize);
            } else {
                newPrice = currentPrice - distance;
                newSL = newPrice + (distanceInPips * StopLossMultiplier * pipSize);
                newTP = newPrice - (distanceInPips * TakeProfitMultiplier * pipSize);
            }
            
            MqlTradeRequest request = {};
            MqlTradeResult result = {};
            
            request.action = TRADE_ACTION_MODIFY;
            request.order = ticket;
            request.price = NormalizeDouble(newPrice, digits);
            request.sl = NormalizeDouble(newSL, digits);
            request.tp = NormalizeDouble(newTP, digits);
            
            if(!OrderSend(request, result)) {
                Print("Ошибка модификации ордера: ", GetLastError());
            }
        }
    }
}

// Функция для регистрации стрэддл пары
void RegisterStraddlePair(ulong buyTicket, ulong sellTicket, string symbol, datetime newsTime) {
    int size = ArraySize(straddlePairs);
    ArrayResize(straddlePairs, size + 1);
    straddlePairs[size].buyTicket = buyTicket;
    straddlePairs[size].sellTicket = sellTicket;
    straddlePairs[size].symbol = symbol;
    straddlePairs[size].newsTime = newsTime;
}

// Функция для отмены противоположного ордера при срабатывании одного из пары
void CheckAndCancelOppositeOrders() {
    if(!CancelOppositeOrdersOnFill || TradingStrategy != STRATEGY_STRADDLE) return;
    
    for(int i = ArraySize(straddlePairs) - 1; i >= 0; i--) {
        bool buyExists = false;
        bool sellExists = false;
        bool buyFilled = false;
        bool sellFilled = false;
        
        // Проверяем статус buy ордера
        if(straddlePairs[i].buyTicket > 0) {
            if(OrderSelect(straddlePairs[i].buyTicket)) {
                buyExists = true;
            } else {
                // Проверяем в позициях
                for(int j = PositionsTotal() - 1; j >= 0; j--) {
                    if(PositionSelectByTicket(PositionGetTicket(j))) {
                        if(PositionGetInteger(POSITION_IDENTIFIER) == straddlePairs[i].buyTicket ||
                           PositionGetString(POSITION_COMMENT) == "Buy from " + IntegerToString(straddlePairs[i].buyTicket)) {
                            buyFilled = true;
                            break;
                        }
                    }
                }
            }
        }
        
        // Проверяем статус sell ордера
        if(straddlePairs[i].sellTicket > 0) {
            if(OrderSelect(straddlePairs[i].sellTicket)) {
                sellExists = true;
            } else {
                // Проверяем в позициях
                for(int j = PositionsTotal() - 1; j >= 0; j--) {
                    if(PositionSelectByTicket(PositionGetTicket(j))) {
                        if(PositionGetInteger(POSITION_IDENTIFIER) == straddlePairs[i].sellTicket ||
                           PositionGetString(POSITION_COMMENT) == "Sell from " + IntegerToString(straddlePairs[i].sellTicket)) {
                            sellFilled = true;
                            break;
                        }
                    }
                }
            }
        }
        
        // Если один ордер сработал, отменяем противоположный
        if(buyFilled && sellExists) {
            trade.OrderDelete(straddlePairs[i].sellTicket);
        } else if(sellFilled && buyExists) {
            trade.OrderDelete(straddlePairs[i].buyTicket);
        }
        
        // Удаляем пару из списка, если оба ордера обработаны
        if((!buyExists && !sellExists) || (buyFilled || sellFilled)) {
            ArrayRemove(straddlePairs, i, 1);
        }
    }
}

// Функция для проверки истечения срока ордеров
void CheckOrderExpiration() {
    if(!UseOrderExpiration) return;
    
    datetime currentTime = TimeCurrent();
    
    for(int i = OrdersTotal() - 1; i >= 0; i--) {
        ulong ticket = OrderGetTicket(i);
        if(OrderSelect(ticket) && OrderGetInteger(ORDER_MAGIC) == MagicNumber) {
            datetime orderTime = (datetime)OrderGetInteger(ORDER_TIME_SETUP);
            
            // Проверяем время жизни ордера
            if(currentTime - orderTime > OrderExpirationMinutes * 60) {
                trade.OrderDelete(ticket);
            }
        }
    }
}

// Функция для проверки ценового уровня
int GetPriceLevelIndex(SymbolOrderInfo &symbolInfo, double price) {
    double point = SymbolInfoDouble(symbolInfo.symbol, SYMBOL_POINT);
    double tolerance = MinOrderDistancePoints * point;
    
    for(int i = 0; i < ArraySize(symbolInfo.priceLevels); i++) {
        if(MathAbs(symbolInfo.priceLevels[i].price - price) < tolerance) {
            return i;
        }
    }
    
    return -1;
}

// Функция для управления ордерами по символам
bool CanPlaceOrder(string symbol, double price, datetime newsTime = 0, string newsTitle = "") {
    if(!UseOrderDistanceLimit) return true;
    
    // Проверяем лимит для конкретной новости
    if(LimitOrdersPerNews && newsTime > 0 && newsTitle != "") {
        if(!CanPlaceOrderForNews(newsTime, newsTitle)) {
            return false;
        }
    }
    
    // Находим или создаем информацию о символе
    int symbolIndex = -1;
    for(int i = 0; i < ArraySize(symbolOrders); i++) {
        if(symbolOrders[i].symbol == symbol) {
            symbolIndex = i;
            break;
        }
    }
    
    if(symbolIndex == -1) {
        // Создаем новую запись для символа
        int size = ArraySize(symbolOrders);
        ArrayResize(symbolOrders, size + 1);
        symbolOrders[size].symbol = symbol;
        ArrayResize(symbolOrders[size].priceLevels, 0);
        symbolIndex = size;
    }
    
    // Проверяем ценовой уровень
    int levelIndex = GetPriceLevelIndex(symbolOrders[symbolIndex], price);
    
    if(levelIndex >= 0) {
        // Если ограничение по новостям, проверяем только ордера той же новости
        if(LimitOrdersPerNews && newsTime > 0) {
            int sameNewsOrderCount = 0;
            for(int i = 0; i < ArraySize(symbolOrders[symbolIndex].priceLevels); i++) {
                if(MathAbs(symbolOrders[symbolIndex].priceLevels[i].price - price) < MinOrderDistancePoints * SymbolInfoDouble(symbol, SYMBOL_POINT) &&
                   symbolOrders[symbolIndex].priceLevels[i].newsTime == newsTime) {
                    sameNewsOrderCount += symbolOrders[symbolIndex].priceLevels[i].orderCount;
                }
            }
            
            if(sameNewsOrderCount >= MaxOrdersPerPriceLevel) {
                return false;
            }
        } else {
            // Обычная проверка без учета новостей
            if(symbolOrders[symbolIndex].priceLevels[levelIndex].orderCount >= MaxOrdersPerPriceLevel) {
                return false;
            }
        }
    }
    
    return true;
}

void RegisterOrderPlaced(string symbol, double price, datetime newsTime = 0, string newsTitle = "") {
    // Находим символ
    int symbolIndex = -1;
    for(int i = 0; i < ArraySize(symbolOrders); i++) {
        if(symbolOrders[i].symbol == symbol) {
            symbolIndex = i;
            break;
        }
    }
    
    if(symbolIndex == -1) {
        // Создаем новую запись
        int size = ArraySize(symbolOrders);
        ArrayResize(symbolOrders, size + 1);
        symbolOrders[size].symbol = symbol;
        ArrayResize(symbolOrders[size].priceLevels, 0);
        symbolIndex = size;
    }
    
    // Находим или создаем ценовой уровень
    int levelIndex = GetPriceLevelIndex(symbolOrders[symbolIndex], price);
    
    if(levelIndex == -1) {
        // Создаем новый уровень
        int levelCount = ArraySize(symbolOrders[symbolIndex].priceLevels);
        ArrayResize(symbolOrders[symbolIndex].priceLevels, levelCount + 1);
        symbolOrders[symbolIndex].priceLevels[levelCount].price = price;
        symbolOrders[symbolIndex].priceLevels[levelCount].orderCount = 1;
        symbolOrders[symbolIndex].priceLevels[levelCount].newsTime = newsTime;
        symbolOrders[symbolIndex].priceLevels[levelCount].newsTitle = newsTitle;
    } else {
        // Увеличиваем счетчик на существующем уровне
        symbolOrders[symbolIndex].priceLevels[levelIndex].orderCount++;
        if(newsTime > 0) {
            symbolOrders[symbolIndex].priceLevels[levelIndex].newsTime = newsTime;
            symbolOrders[symbolIndex].priceLevels[levelIndex].newsTitle = newsTitle;
        }
    }
}

void CleanupSymbolOrders() {
    // Очистка информации об ордерах для символов без активных ордеров
    for(int i = 0; i < ArraySize(symbolOrders); i++) {
        // Сначала очищаем все уровни
        for(int j = 0; j < ArraySize(symbolOrders[i].priceLevels); j++) {
            symbolOrders[i].priceLevels[j].orderCount = 0;
        }
        
        // Теперь пересчитываем активные ордера
        for(int j = OrdersTotal() - 1; j >= 0; j--) {
            ulong ticket = OrderGetTicket(j);
            if(OrderSelect(ticket) && OrderGetString(ORDER_SYMBOL) == symbolOrders[i].symbol &&
               OrderGetInteger(ORDER_MAGIC) == MagicNumber) {
                double orderPrice = OrderGetDouble(ORDER_PRICE_OPEN);
                int levelIndex = GetPriceLevelIndex(symbolOrders[i], orderPrice);
                if(levelIndex >= 0) {
                    symbolOrders[i].priceLevels[levelIndex].orderCount++;
                } else {
                    // Создаем новый уровень
                    int levelCount = ArraySize(symbolOrders[i].priceLevels);
                    ArrayResize(symbolOrders[i].priceLevels, levelCount + 1);
                    symbolOrders[i].priceLevels[levelCount].price = orderPrice;
                    symbolOrders[i].priceLevels[levelCount].orderCount = 1;
                }
            }
        }
        
        // Удаляем пустые уровни
        PriceLevel tempLevels[];
        int tempCount = 0;
        for(int j = 0; j < ArraySize(symbolOrders[i].priceLevels); j++) {
            if(symbolOrders[i].priceLevels[j].orderCount > 0) {
                ArrayResize(tempLevels, tempCount + 1);
                tempLevels[tempCount] = symbolOrders[i].priceLevels[j];
                tempCount++;
            }
        }
        ArrayResize(symbolOrders[i].priceLevels, tempCount);
        for(int j = 0; j < tempCount; j++) {
            symbolOrders[i].priceLevels[j] = tempLevels[j];
        }
    }
}

