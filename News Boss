//+------------------------------------------------------------------+
//|                                              NewsTrader_Pro.mq5 |
//|                                 Professional News Trading (FF)   |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Professional News Trading EA - ForexFactory Edition"
#property link      "https://www.mql5.com"
#property version   "5.00"
#property strict

// Добавляем свойства для индикатора (исправление ошибки)
#property indicator_chart_window
#property indicator_plots 0

#include <Trade/Trade.mqh>

//--- Trading objects
CTrade trade;

//+------------------------------------------------------------------+
//| Enums for EA configuration
//+------------------------------------------------------------------+
enum ENUM_NEWS_STRATEGY {
    STRATEGY_BREAKOUT,     // Стратегия пробоя
    STRATEGY_STRADDLE,     // Стратегия стрэддла  
    STRATEGY_PULLBACK,     // Стратегия пуллбэка
    STRATEGY_FUNDAMENTAL   // Стратегия по фундаментальным данным
};

enum ENUM_RISK_LEVEL {
    RISK_LOW,              // Низкий риск (0.5%)
    RISK_MEDIUM,           // Средний риск (1.0%)
    RISK_HIGH              // Высокий риск (2.0%)
};

enum ENUM_TRAILING_PAUSE_MODE {
    TRAILING_PAUSE_NONE,        // Не останавливать
    TRAILING_PAUSE_TO_INITIAL,  // До начального SL
    TRAILING_PAUSE_TO_BE        // До безубытка
};

//+------------------------------------------------------------------+
//| Input parameters
//+------------------------------------------------------------------+
input group "=== НАСТРОЙКИ ТОРГОВЛИ ==="
input ENUM_NEWS_STRATEGY TradingStrategy = STRATEGY_STRADDLE;  // Торговая стратегия
input ENUM_RISK_LEVEL RiskLevel = RISK_MEDIUM;                // Уровень риска
input string TradingPairs = "EURUSD,GBPUSD,USDJPY,USDCHF,NZDUSD,AUDUSD,XAUUSD";   // Торговые пары (через запятую)

input group "=== НАСТРОЙКИ НОВОСТЕЙ ==="
input bool UseNewsFilter = true;                             // Использовать фильтр новостей
input int MinNewsImpact = 2;                                // Минимальное воздействие (1-3)
input int NewsMinutesBefore = 15;                           // Минут до новости для подготовки
input int NewsMinutesAfter = 60;                            // Минут после новости для торговли
input string NewsCurrencies = "USD,EUR,GBP,JPY,CHF,CAD,AUD,NZD";           // Валюты для мониторинга
input string NewsFilterKeywords = "NFP,CPI,GDP,Interest Rate,PMI,Retail Sales,Employment,PPI,m/m,y/y,Jackson,FOMC,Gov,BOE,BOJ,q/q,Bus"; // Ключевые слова новостей (через запятую)
input bool TradeAllHighImpact = true;                      // Торговать на всех новостях высокой важности

input group "=== УПРАВЛЕНИЕ РИСКАМИ ==="
input double MaxDailyLoss = 5.0;                           // Максимальная дневная потеря (%)
input double MaxSpreadPoints = 30;                         // Максимальный спред (пункты)
input int ConsecutiveLossLimit = 5;                        // Лимит последовательных убытков
input bool UseATRPositionSizing = true;                    // Использовать ATR для размера позиции

input group "=== ТЕХНИЧЕСКИЕ ПАРАМЕТРЫ ==="
input int ATRPeriod = 14;                                  // Период ATR
input double ATRMultiplier = 2.5;                         // Множитель ATR для расстояния
input int MagicNumber = 777888;                            // Магический номер
input int MaxSlippagePoints = 10;                          // Максимальное проскальзывание

input group "=== НАСТРОЙКИ СТОП-ЛОССА И ТЕЙК-ПРОФИТА ==="
input bool UseTrailingStop = true;                        // Использовать Trailing Stop
input double TrailingStopMultiplier = 1.5;               // Множитель ATR для Trailing Stop
input double StopLossMultiplier = 2.0;                   // Множитель дистанции для Stop Loss
input double TakeProfitMultiplier = 3.0;                 // Множитель дистанции для Take Profit

input group "=== ДИНАМИЧЕСКОЕ ОБНОВЛЕНИЕ SL/TP ==="
input bool UpdateSLByATR = false;                        // Обновлять SL по текущему ATR
input int SLUpdateMinutes = 60;                           // Минут между обновлениями SL
input bool UpdateTPByATR = false;                        // Обновлять TP по текущему ATR
input int TPUpdateMinutes = 60;                           // Минут между обновлениями TP
input bool UpdateTrailingByATR = true;                   // Обновлять Trailing по текущему ATR
input int TrailingUpdateMinutes = 30;                     // Минут между обновлениями Trailing
input ENUM_TRAILING_PAUSE_MODE TrailingPauseMode = TRAILING_PAUSE_TO_BE; // Режим паузы Trailing Stop

input group "=== ОГРАНИЧЕНИЯ ВЫСТАВЛЕНИЯ ОРДЕРОВ ==="
input bool UseOrderDistanceLimit = true;                  // Использовать ограничение по расстоянию
input double MinOrderDistancePoints = 10;                 // Минимальное расстояние между группами ордеров (пункты)
input int MaxOrdersPerPriceLevel = 3;                    // Максимум ордеров на одном ценовом уровне
input bool LimitOrdersPerNews = true;                    // Ограничивать ордера для каждой новости отдельно
input int MaxOrdersPerNews = 6;                          // Максимум ордеров на одну новость

input group "=== УПРАВЛЕНИЕ ОТЛОЖЕННЫМИ ОРДЕРАМИ ==="
input bool UseOrderExpiration = true;                     // Использовать истечение срока ордеров
input int OrderExpirationMinutes = 30;                    // Минут после новости для отмены ордеров
input bool CancelOppositeOrdersOnFill = true;            // Отменять противоположные ордера при срабатывании (только для стрэддл)
input bool UpdateOrdersOnNewNews = true;                 // Обновлять ордера при новых новостях
input int MinMinutesBetweenNewsForUpdate = 30;          // Минимум минут между новостями для обновления

input group "=== НАСТРОЙКИ ВРЕМЕНИ ==="
input int GMTOffset = -5;                                  // GMT смещение ForexFactory (EST = -5)
input bool AutoDetectBrokerGMT = true;                     // Автоопределение GMT брокера
input int ManualBrokerGMT = 3;                             // Ручная установка GMT брокера (если автоопределение отключено)

input group "=== FOREXFACTORY НАСТРОЙКИ ==="
input string ForexFactoryURL = "https://www.forexfactory.com/calendar.php"; // URL ForexFactory
input int WebRequestTimeout = 5000;                        // Таймаут веб-запроса (мс)
input int NewsUpdateMinutes = 30;                          // Обновлять новости каждые X минут
input bool LoadTodayOnly = false;                          // Загружать только сегодняшние новости
input int NewsHistoryHours = 2;                            // Показывать прошедшие новости за X часов

input group "=== НАСТРОЙКИ ФУНДАМЕНТАЛЬНОЙ СТРАТЕГИИ ==="
input double FundamentalDeviationPercent = 20.0;          // Минимальное отклонение от прогноза (%)
input double FundamentalATRMultiplier = 1.0;              // Множитель ATR для фундаментальной стратегии
input bool TradeOnlyMajorSurprises = true;                // Торговать только на больших сюрпризах

input group "=== НАСТРОЙКИ ТЕСТЕРА ==="
input bool TesterMode = false;                             // Режим тестера (автоопределение)
input string NewsDataPath = "NewsData";                    // Папка с файлами новостей
input double ActualVariation = 20.0;                      // Вариация факта от прогноза (%)
input double SurpriseVolatilityMultiplier = 2.0;          // Множитель волатильности для сюрпризов

input group "=== НАСТРОЙКИ ПАНЕЛИ НОВОСТЕЙ ==="
input bool ShowNewsPanel = true;                          // Показывать панель новостей
input int PanelX = 10;                                    // Позиция панели X
input int PanelY = 50;                                    // Позиция панели Y
input int PanelWidth = 500;                               // Ширина панели
input int PanelNewsCount = 5;                             // Количество новостей для отображения
input color PanelBackgroundColor = clrBlack;              // Цвет фона панели
input color PanelTextColor = clrWhite;                    // Цвет текста панели
input int PanelFontSize = 8;                              // Размер шрифта панели
input bool EnableSoundAlert = true;                       // Звуковой сигнал перед новостями
input int SoundAlertMinutes = 5;                          // За сколько минут сигнал

//+------------------------------------------------------------------+
//| Global variables
//+------------------------------------------------------------------+
struct NewsEvent {
    datetime time;
    string currency;
    string title;
    int impact;
    double forecast;
    double actual;
    double previous;
    bool processed;
    bool actualReleased;  // Для тестера
    bool hasForecast;     // Флаг наличия прогноза
    
    // Copy constructor
    NewsEvent(const NewsEvent& other) {
        time = other.time;
        currency = other.currency;
        title = other.title;
        impact = other.impact;
        forecast = other.forecast;
        actual = other.actual;
        previous = other.previous;
        processed = other.processed;
        actualReleased = other.actualReleased;
        hasForecast = other.hasForecast;
    }
    
    // Default constructor
    NewsEvent() {
        time = 0;
        currency = "";
        title = "";
        impact = 0;
        forecast = 0;
        actual = 0;
        previous = 0;
        processed = false;
        actualReleased = false;
        hasForecast = false;
    }
};

// Структура для отслеживания параметров позиций
struct PositionInfo {
    ulong ticket;
    string symbol;
    datetime openTime;
    datetime lastSLUpdate;
    datetime lastTPUpdate;
    datetime lastTrailingUpdate;
    double initialSL;
    double openPrice;
    bool trailingPaused;
    double pausedAtPrice;
    
    // Copy constructor (исправление ошибки компиляции)
    PositionInfo(const PositionInfo& other) {
        ticket = other.ticket;
        symbol = other.symbol;
        openTime = other.openTime;
        lastSLUpdate = other.lastSLUpdate;
        lastTPUpdate = other.lastTPUpdate;
        lastTrailingUpdate = other.lastTrailingUpdate;
        initialSL = other.initialSL;
        openPrice = other.openPrice;
        trailingPaused = other.trailingPaused;
        pausedAtPrice = other.pausedAtPrice;
    }
    
    PositionInfo() {
        ticket = 0;
        symbol = "";
        openTime = 0;
        lastSLUpdate = 0;
        lastTPUpdate = 0;
        lastTrailingUpdate = 0;
        initialSL = 0;
        openPrice = 0;
        trailingPaused = false;
        pausedAtPrice = 0;
    }
};

PositionInfo positionsTracking[];

// Структура для отслеживания парных ордеров стрэддла
struct StraddlePair {
    ulong buyTicket;
    ulong sellTicket;
    string symbol;
    datetime newsTime;
    
    StraddlePair() {
        buyTicket = 0;
        sellTicket = 0;
        symbol = "";
        newsTime = 0;
    }
};

StraddlePair straddlePairs[];

// Структура для отслеживания ценовых уровней
struct PriceLevel {
    double price;
    int orderCount;
    datetime newsTime;
    string newsTitle;
    
    PriceLevel() {
        price = 0;
        orderCount = 0;
        newsTime = 0;
        newsTitle = "";
    }
};

// Структура для отслеживания ордеров по символам
struct SymbolOrderInfo {
    string symbol;
    PriceLevel priceLevels[];
    
    SymbolOrderInfo() {
        symbol = "";
        ArrayResize(priceLevels, 0);
    }
};

// Структура для отслеживания ордеров по новостям
struct NewsOrderTracking {
    datetime newsTime;
    string newsTitle;
    string currency;
    int orderCount;
    ulong orderTickets[];
    
    NewsOrderTracking() {
        newsTime = 0;
        newsTitle = "";
        currency = "";
        orderCount = 0;
        ArrayResize(orderTickets, 0);
    }
};

NewsOrderTracking newsOrderTracking[];
SymbolOrderInfo symbolOrders[];

NewsEvent newsCalendar[];
datetime lastNewsCheck = 0;
double dailyPnL = 0;
int consecutiveLosses = 0;
bool tradingHalted = false;
string validPairs[];
bool isTesting = false;
datetime lastLoadedMonth = 0;
int brokerGMTOffset = 0;

int atrHandle;
double currentATR = 0;

// Forward declarations
class CNewsManager;
CNewsManager *newsManagerPtr = NULL;
class CRiskManager;

// Глобальная функция PlacePendingOrder
ulong PlacePendingOrder(ENUM_ORDER_TYPE orderType, string symbol, double price, 
                     double sl, double tp, double volume, datetime expiration) {
    MqlTradeRequest request = {};
    MqlTradeResult result = {};
    
    ZeroMemory(request);
    ZeroMemory(result);
    
    request.action = TRADE_ACTION_PENDING;
    request.symbol = symbol;
    request.volume = volume;
    request.type = orderType;
    request.price = NormalizeDouble(price, (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS));
    request.sl = NormalizeDouble(sl, (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS));
    request.tp = NormalizeDouble(tp, (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS));
    request.magic = MagicNumber;
    request.deviation = MaxSlippagePoints;
    request.comment = StringFormat("News: %s", EnumToString(TradingStrategy));
    
    int filling = (int)SymbolInfoInteger(symbol, SYMBOL_FILLING_MODE);
    if(filling == SYMBOL_FILLING_FOK) {
        request.type_filling = ORDER_FILLING_FOK;
    } else if(filling == SYMBOL_FILLING_IOC) {
        request.type_filling = ORDER_FILLING_IOC;
    } else {
        request.type_filling = ORDER_FILLING_RETURN;
    }
    
    if(UseOrderExpiration && expiration > 0) {
        request.type_time = ORDER_TIME_SPECIFIED;
        request.expiration = expiration;
    } else {
        request.type_time = ORDER_TIME_GTC;
    }
    
    if(!OrderSend(request, result)) {
        return 0;
    }
    
    if(result.retcode == TRADE_RETCODE_DONE || result.retcode == TRADE_RETCODE_PLACED) {
        return result.order;
    } else {
        return 0;
    }
}

// Функции для работы с позициями
int GetPositionTrackingIndex(ulong ticket) {
    for(int i = 0; i < ArraySize(positionsTracking); i++) {
        if(positionsTracking[i].ticket == ticket) {
            return i;
        }
    }
    return -1;
}

void RegisterPosition(ulong ticket, string symbol, double openPrice, double sl) {
    int size = ArraySize(positionsTracking);
    ArrayResize(positionsTracking, size + 1);
    
    positionsTracking[size].ticket = ticket;
    positionsTracking[size].symbol = symbol;
    positionsTracking[size].openTime = TimeCurrent();
    positionsTracking[size].lastSLUpdate = TimeCurrent();
    positionsTracking[size].lastTPUpdate = TimeCurrent();
    positionsTracking[size].lastTrailingUpdate = TimeCurrent();
    positionsTracking[size].initialSL = sl;
    positionsTracking[size].openPrice = openPrice;
    positionsTracking[size].trailingPaused = false;
    positionsTracking[size].pausedAtPrice = 0;
}

void RemovePositionTracking(ulong ticket) {
    int index = GetPositionTrackingIndex(ticket);
    if(index >= 0) {
        ArrayRemove(positionsTracking, index, 1);
    }
}

// Функция для обновления SL/TP по ATR
void UpdatePositionsByATR() {
    datetime currentTime = TimeCurrent();
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;
        
        int trackIndex = GetPositionTrackingIndex(ticket);
        if(trackIndex == -1) continue;
        
        string symbol = PositionGetString(POSITION_SYMBOL);
        double currentSL = PositionGetDouble(POSITION_SL);
        double currentTP = PositionGetDouble(POSITION_TP);
        double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        
        int atrHandleLocal = iATR(symbol, PERIOD_M15, ATRPeriod);
        double atrBuffer[];
        double localATR = 0;
        
        if(CopyBuffer(atrHandleLocal, 0, 0, 1, atrBuffer) > 0) {
            localATR = atrBuffer[0];
        }
        IndicatorRelease(atrHandleLocal);
        
        if(localATR <= 0) continue;
        
        int digits = (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS);
        double point = SymbolInfoDouble(symbol, SYMBOL_POINT);
        double pipSize = (digits == 5 || digits == 3) ? point * 10 : point;
        
        bool modified = false;
        double newSL = currentSL;
        double newTP = currentTP;
        
        if(UpdateSLByATR && 
           (currentTime - positionsTracking[trackIndex].lastSLUpdate) >= SLUpdateMinutes * 60) {
            
            double slDistance = localATR * StopLossMultiplier;
            
            if(posType == POSITION_TYPE_BUY) {
                newSL = openPrice - slDistance;
            } else {
                newSL = openPrice + slDistance;
            }
            
            newSL = NormalizeDouble(newSL, digits);
            
            if(newSL != currentSL) {
                positionsTracking[trackIndex].lastSLUpdate = currentTime;
                modified = true;
            }
        }
        
        if(UpdateTPByATR && 
           (currentTime - positionsTracking[trackIndex].lastTPUpdate) >= TPUpdateMinutes * 60) {
            
            double tpDistance = localATR * TakeProfitMultiplier;
            
            if(posType == POSITION_TYPE_BUY) {
                newTP = openPrice + tpDistance;
            } else {
                newTP = openPrice - tpDistance;
            }
            
            newTP = NormalizeDouble(newTP, digits);
            
            if(newTP != currentTP) {
                positionsTracking[trackIndex].lastTPUpdate = currentTime;
                modified = true;
            }
        }
        
        if(modified) {
            MqlTradeRequest request = {};
            MqlTradeResult result = {};
            
            request.action = TRADE_ACTION_SLTP;
            request.position = ticket;
            request.symbol = symbol;
            request.sl = newSL;
            request.tp = newTP;
            request.magic = MagicNumber;
            
            if(!OrderSend(request, result)) {
                Print("Ошибка обновления SL/TP: ", GetLastError());
            }
        }
    }
}

// Функция для проверки паузы трейлинга
bool ShouldPauseTrailing(int trackIndex, double currentPrice, double currentSL) {
    if(TrailingPauseMode == TRAILING_PAUSE_NONE) return false;
    
    PositionInfo info = positionsTracking[trackIndex];
    
    if(TrailingPauseMode == TRAILING_PAUSE_TO_INITIAL) {
        double distanceToInitial = MathAbs(currentPrice - info.initialSL);
        double requiredDistance = currentATR * TrailingStopMultiplier;
        
        if(distanceToInitial < requiredDistance) {
            if(!info.trailingPaused) {
                positionsTracking[trackIndex].trailingPaused = true;
                positionsTracking[trackIndex].pausedAtPrice = currentPrice;
            }
            return true;
        } else {
            if(info.trailingPaused) {
                positionsTracking[trackIndex].trailingPaused = false;
            }
        }
    } else if(TrailingPauseMode == TRAILING_PAUSE_TO_BE) {
        bool inProfit = false;
        
        if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY) {
            inProfit = currentPrice > info.openPrice;
        } else {
            inProfit = currentPrice < info.openPrice;
        }
        
        if(!inProfit) {
            if(!info.trailingPaused) {
                positionsTracking[trackIndex].trailingPaused = true;
                positionsTracking[trackIndex].pausedAtPrice = currentPrice;
            }
            return true;
        } else {
            double distanceFromBE = MathAbs(currentPrice - info.openPrice);
            double requiredDistance = currentATR * TrailingStopMultiplier;
            
            if(distanceFromBE < requiredDistance) {
                if(!info.trailingPaused) {
                    positionsTracking[trackIndex].trailingPaused = true;
                    positionsTracking[trackIndex].pausedAtPrice = currentPrice;
                }
                return true;
            } else {
                if(info.trailingPaused) {
                    positionsTracking[trackIndex].trailingPaused = false;
                }
            }
        }
    }
    
    return false;
}

// Обновленная функция трейлинг стопа
void UpdateTrailingStop() {
    if(!UseTrailingStop) return;
    
    datetime currentTime = TimeCurrent();
    
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;
        
        int trackIndex = GetPositionTrackingIndex(ticket);
        if(trackIndex == -1) {
            RegisterPosition(ticket, 
                           PositionGetString(POSITION_SYMBOL),
                           PositionGetDouble(POSITION_PRICE_OPEN),
                           PositionGetDouble(POSITION_SL));
            trackIndex = GetPositionTrackingIndex(ticket);
        }
        
        string symbol = PositionGetString(POSITION_SYMBOL);
        double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        double currentSL = PositionGetDouble(POSITION_SL);
        double currentTP = PositionGetDouble(POSITION_TP);
        ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        
        double point = SymbolInfoDouble(symbol, SYMBOL_POINT);
        
        double trailDistance = currentATR * TrailingStopMultiplier;
        
        if(UpdateTrailingByATR && 
           (currentTime - positionsTracking[trackIndex].lastTrailingUpdate) >= TrailingUpdateMinutes * 60) {
            int atrHandleLocal = iATR(symbol, PERIOD_M15, ATRPeriod);
            double atrBuffer[];
            
            if(CopyBuffer(atrHandleLocal, 0, 0, 1, atrBuffer) > 0) {
                trailDistance = atrBuffer[0] * TrailingStopMultiplier;
                positionsTracking[trackIndex].lastTrailingUpdate = currentTime;
            }
            IndicatorRelease(atrHandleLocal);
        }
        
        double newSL = 0;
        bool shouldModify = false;
        
        if(posType == POSITION_TYPE_BUY) {
            double bid = SymbolInfoDouble(symbol, SYMBOL_BID);
            
            if(ShouldPauseTrailing(trackIndex, bid, currentSL)) {
                continue;
            }
            
            if(bid - openPrice > trailDistance) {
                newSL = bid - trailDistance;
                if(newSL > currentSL) {
                    shouldModify = true;
                }
            }
        } else {
            double ask = SymbolInfoDouble(symbol, SYMBOL_ASK);
            
            if(ShouldPauseTrailing(trackIndex, ask, currentSL)) {
                continue;
            }
            
            if(openPrice - ask > trailDistance) {
                newSL = ask + trailDistance;
                if(newSL < currentSL || currentSL == 0) {
                    shouldModify = true;
                }
            }
        }
        
        if(shouldModify && newSL > 0) {
            trade.PositionModify(ticket, newSL, currentTP);
        }
    }
}

// Функция для отслеживания ордеров по новостям
int GetNewsOrderIndex(datetime newsTime, string newsTitle) {
    for(int i = 0; i < ArraySize(newsOrderTracking); i++) {
        if(newsOrderTracking[i].newsTime == newsTime && 
           newsOrderTracking[i].newsTitle == newsTitle) {
            return i;
        }
    }
    return -1;
}

void RegisterOrderForNews(ulong ticket, datetime newsTime, string newsTitle, string currency) {
    int index = GetNewsOrderIndex(newsTime, newsTitle);
    
    if(index == -1) {
        int size = ArraySize(newsOrderTracking);
        ArrayResize(newsOrderTracking, size + 1);
        newsOrderTracking[size].newsTime = newsTime;
        newsOrderTracking[size].newsTitle = newsTitle;
        newsOrderTracking[size].currency = currency;
        newsOrderTracking[size].orderCount = 0;
        ArrayResize(newsOrderTracking[size].orderTickets, 0);
        index = size;
    }
    
    int ticketCount = ArraySize(newsOrderTracking[index].orderTickets);
    ArrayResize(newsOrderTracking[index].orderTickets, ticketCount + 1);
    newsOrderTracking[index].orderTickets[ticketCount] = ticket;
    newsOrderTracking[index].orderCount++;
}

bool CanPlaceOrderForNews(datetime newsTime, string newsTitle) {
    if(!LimitOrdersPerNews) return true;
    
    int index = GetNewsOrderIndex(newsTime, newsTitle);
    if(index == -1) return true;
    
    return newsOrderTracking[index].orderCount < MaxOrdersPerNews;
}

// Функция для обновления существующих ордеров
void UpdateExistingOrders(string symbol, NewsEvent& news) {
    if(!UpdateOrdersOnNewNews) return;
    
    datetime currentTime = TimeCurrent();
    bool foundRecentNews = false;
    
    for(int i = 0; i < ArraySize(newsOrderTracking); i++) {
        if(newsOrderTracking[i].currency == news.currency) {
            int timeDiff = (int)((news.time - newsOrderTracking[i].newsTime) / 60);
            if(MathAbs(timeDiff) < MinMinutesBetweenNewsForUpdate) {
                foundRecentNews = true;
                break;
            }
        }
    }
    
    if(!foundRecentNews) return;
    
    double currentPrice = SymbolInfoDouble(symbol, SYMBOL_ASK);
    double distance = currentATR * ATRMultiplier;
    
    if(!news.hasForecast) {
        distance *= 1.5;
    }
    
    int digits = (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS);
    double point = SymbolInfoDouble(symbol, SYMBOL_POINT);
    double pipSize = (digits == 5 || digits == 3) ? point * 10 : point;
    
    double distanceInPips = distance / pipSize;

    for(int i = OrdersTotal() - 1; i >= 0; i--) {
        ulong ticket = OrderGetTicket(i);
        if(!OrderSelect(ticket)) continue;
        if(OrderGetInteger(ORDER_MAGIC) != MagicNumber) continue;
        if(OrderGetString(ORDER_SYMBOL) != symbol) continue;
        
        ENUM_ORDER_TYPE orderType = (ENUM_ORDER_TYPE)OrderGetInteger(ORDER_TYPE);
        
        if(orderType == ORDER_TYPE_BUY_STOP || orderType == ORDER_TYPE_SELL_STOP) {
            double newPrice = 0;
            double newSL = 0;
            double newTP = 0;
            
            if(orderType == ORDER_TYPE_BUY_STOP) {
                newPrice = currentPrice + distance;
                newSL = newPrice - (distanceInPips * StopLossMultiplier * pipSize);
                newTP = newPrice + (distanceInPips * TakeProfitMultiplier * pipSize);
            } else {
                newPrice = currentPrice - distance;
                newSL = newPrice + (distanceInPips * StopLossMultiplier * pipSize);
                newTP = newPrice - (distanceInPips * TakeProfitMultiplier * pipSize);
            }
            
            MqlTradeRequest request = {};
            MqlTradeResult result = {};
            
            request.action = TRADE_ACTION_MODIFY;
            request.order = ticket;
            request.price = NormalizeDouble(newPrice, digits);
            request.sl = NormalizeDouble(newSL, digits);
            request.tp = NormalizeDouble(newTP, digits);
            
            if(!OrderSend(request, result)) {
                Print("Ошибка модификации ордера: ", GetLastError());
            }
        }
    }
}

// Функция для регистрации стрэддл пары
void RegisterStraddlePair(ulong buyTicket, ulong sellTicket, string symbol, datetime newsTime) {
    int size = ArraySize(straddlePairs);
    ArrayResize(straddlePairs, size + 1);
    straddlePairs[size].buyTicket = buyTicket;
    straddlePairs[size].sellTicket = sellTicket;
    straddlePairs[size].symbol = symbol;
    straddlePairs[size].newsTime = newsTime;
}

// Функция для отмены противоположного ордера при срабатывании одного из пары
void CheckAndCancelOppositeOrders() {
    if(!CancelOppositeOrdersOnFill || TradingStrategy != STRATEGY_STRADDLE) return;
    
    for(int i = ArraySize(straddlePairs) - 1; i >= 0; i--) {
        bool buyExists = false;
        bool sellExists = false;
        bool buyFilled = false;
        bool sellFilled = false;
        
        // Проверяем статус buy ордера
        if(straddlePairs[i].buyTicket > 0) {
            if(OrderSelect(straddlePairs[i].buyTicket)) {
                buyExists = true;
            } else {
                // Проверяем в позициях
                for(int j = PositionsTotal() - 1; j >= 0; j--) {
                    if(PositionSelectByTicket(PositionGetTicket(j))) {
                        if(PositionGetInteger(POSITION_IDENTIFIER) == straddlePairs[i].buyTicket ||
                           PositionGetString(POSITION_COMMENT) == "Buy from " + IntegerToString(straddlePairs[i].buyTicket)) {
                            buyFilled = true;
                            break;
                        }
                    }
                }
            }
        }
        
        // Проверяем статус sell ордера
        if(straddlePairs[i].sellTicket > 0) {
            if(OrderSelect(straddlePairs[i].sellTicket)) {
                sellExists = true;
            } else {
                // Проверяем в позициях
                for(int j = PositionsTotal() - 1; j >= 0; j--) {
                    if(PositionSelectByTicket(PositionGetTicket(j))) {
                        if(PositionGetInteger(POSITION_IDENTIFIER) == straddlePairs[i].sellTicket ||
                           PositionGetString(POSITION_COMMENT) == "Sell from " + IntegerToString(straddlePairs[i].sellTicket)) {
                            sellFilled = true;
                            break;
                        }
                    }
                }
            }
        }
        
        // Если один ордер сработал, отменяем противоположный
        if(buyFilled && sellExists) {
            trade.OrderDelete(straddlePairs[i].sellTicket);
        } else if(sellFilled && buyExists) {
            trade.OrderDelete(straddlePairs[i].buyTicket);
        }
        
        // Удаляем пару из списка, если оба ордера обработаны
        if((!buyExists && !sellExists) || (buyFilled || sellFilled)) {
            ArrayRemove(straddlePairs, i, 1);
        }
    }
}

// Функция для проверки истечения срока ордеров
void CheckOrderExpiration() {
    if(!UseOrderExpiration) return;
    
    datetime currentTime = TimeCurrent();
    
    for(int i = OrdersTotal() - 1; i >= 0; i--) {
        ulong ticket = OrderGetTicket(i);
        if(OrderSelect(ticket) && OrderGetInteger(ORDER_MAGIC) == MagicNumber) {
            datetime orderTime = (datetime)OrderGetInteger(ORDER_TIME_SETUP);
            
            // Проверяем время жизни ордера
            if(currentTime - orderTime > OrderExpirationMinutes * 60) {
                trade.OrderDelete(ticket);
            }
        }
    }
}

// Функция для проверки ценового уровня
int GetPriceLevelIndex(SymbolOrderInfo &symbolInfo, double price) {
    double point = SymbolInfoDouble(symbolInfo.symbol, SYMBOL_POINT);
    double tolerance = MinOrderDistancePoints * point;
    
    for(int i = 0; i < ArraySize(symbolInfo.priceLevels); i++) {
        if(MathAbs(symbolInfo.priceLevels[i].price - price) < tolerance) {
            return i;
        }
    }
    
    return -1;
}

// Функция для управления ордерами по символам
bool CanPlaceOrder(string symbol, double price, datetime newsTime = 0, string newsTitle = "") {
    if(!UseOrderDistanceLimit) return true;
    
    // Проверяем лимит для конкретной новости
    if(LimitOrdersPerNews && newsTime > 0 && newsTitle != "") {
        if(!CanPlaceOrderForNews(newsTime, newsTitle)) {
            return false;
        }
    }
    
    // Находим или создаем информацию о символе
    int symbolIndex = -1;
    for(int i = 0; i < ArraySize(symbolOrders); i++) {
        if(symbolOrders[i].symbol == symbol) {
            symbolIndex = i;
            break;
        }
    }
    
    if(symbolIndex == -1) {
        // Создаем новую запись для символа
        int size = ArraySize(symbolOrders);
        ArrayResize(symbolOrders, size + 1);
        symbolOrders[size].symbol = symbol;
        ArrayResize(symbolOrders[size].priceLevels, 0);
        symbolIndex = size;
    }
    
    // Проверяем ценовой уровень
    int levelIndex = GetPriceLevelIndex(symbolOrders[symbolIndex], price);
    
    if(levelIndex >= 0) {
        // Если ограничение по новостям, проверяем только ордера той же новости
        if(LimitOrdersPerNews && newsTime > 0) {
            int sameNewsOrderCount = 0;
            for(int i = 0; i < ArraySize(symbolOrders[symbolIndex].priceLevels); i++) {
                if(MathAbs(symbolOrders[symbolIndex].priceLevels[i].price - price) < MinOrderDistancePoints * SymbolInfoDouble(symbol, SYMBOL_POINT) &&
                   symbolOrders[symbolIndex].priceLevels[i].newsTime == newsTime) {
                    sameNewsOrderCount += symbolOrders[symbolIndex].priceLevels[i].orderCount;
                }
            }
            
            if(sameNewsOrderCount >= MaxOrdersPerPriceLevel) {
                return false;
            }
        } else {
            // Обычная проверка без учета новостей
            if(symbolOrders[symbolIndex].priceLevels[levelIndex].orderCount >= MaxOrdersPerPriceLevel) {
                return false;
            }
        }
    }
    
    return true;
}

void RegisterOrderPlaced(string symbol, double price, datetime newsTime = 0, string newsTitle = "") {
    // Находим символ
    int symbolIndex = -1;
    for(int i = 0; i < ArraySize(symbolOrders); i++) {
        if(symbolOrders[i].symbol == symbol) {
            symbolIndex = i;
            break;
        }
    }
    
    if(symbolIndex == -1) {
        // Создаем новую запись
        int size = ArraySize(symbolOrders);
        ArrayResize(symbolOrders, size + 1);
        symbolOrders[size].symbol = symbol;
        ArrayResize(symbolOrders[size].priceLevels, 0);
        symbolIndex = size;
    }
    
    // Находим или создаем ценовой уровень
    int levelIndex = GetPriceLevelIndex(symbolOrders[symbolIndex], price);
    
    if(levelIndex == -1) {
        // Создаем новый уровень
        int levelCount = ArraySize(symbolOrders[symbolIndex].priceLevels);
        ArrayResize(symbolOrders[symbolIndex].priceLevels, levelCount + 1);
        symbolOrders[symbolIndex].priceLevels[levelCount].price = price;
        symbolOrders[symbolIndex].priceLevels[levelCount].orderCount = 1;
        symbolOrders[symbolIndex].priceLevels[levelCount].newsTime = newsTime;
        symbolOrders[symbolIndex].priceLevels[levelCount].newsTitle = newsTitle;
    } else {
        // Увеличиваем счетчик на существующем уровне
        symbolOrders[symbolIndex].priceLevels[levelIndex].orderCount++;
        if(newsTime > 0) {
            symbolOrders[symbolIndex].priceLevels[levelIndex].newsTime = newsTime;
            symbolOrders[symbolIndex].priceLevels[levelIndex].newsTitle = newsTitle;
        }
    }
}

void CleanupSymbolOrders() {
    // Очистка информации об ордерах для символов без активных ордеров
    for(int i = 0; i < ArraySize(symbolOrders); i++) {
        // Сначала очищаем все уровни
        for(int j = 0; j < ArraySize(symbolOrders[i].priceLevels); j++) {
            symbolOrders[i].priceLevels[j].orderCount = 0;
        }
        
        // Теперь пересчитываем активные ордера
        for(int j = OrdersTotal() - 1; j >= 0; j--) {
            ulong ticket = OrderGetTicket(j);
            if(OrderSelect(ticket) && OrderGetString(ORDER_SYMBOL) == symbolOrders[i].symbol &&
               OrderGetInteger(ORDER_MAGIC) == MagicNumber) {
                double orderPrice = OrderGetDouble(ORDER_PRICE_OPEN);
                int levelIndex = GetPriceLevelIndex(symbolOrders[i], orderPrice);
                if(levelIndex >= 0) {
                    symbolOrders[i].priceLevels[levelIndex].orderCount++;
                } else {
                    // Создаем новый уровень
                    int levelCount = ArraySize(symbolOrders[i].priceLevels);
                    ArrayResize(symbolOrders[i].priceLevels, levelCount + 1);
                    symbolOrders[i].priceLevels[levelCount].price = orderPrice;
                    symbolOrders[i].priceLevels[levelCount].orderCount = 1;
                }
            }
        }
        
        // Удаляем пустые уровни
        PriceLevel tempLevels[];
        int tempCount = 0;
        for(int j = 0; j < ArraySize(symbolOrders[i].priceLevels); j++) {
            if(symbolOrders[i].priceLevels[j].orderCount > 0) {
                ArrayResize(tempLevels, tempCount + 1);
                tempLevels[tempCount] = symbolOrders[i].priceLevels[j];
                tempCount++;
            }
        }
        ArrayResize(symbolOrders[i].priceLevels, tempCount);
        for(int j = 0; j < tempCount; j++) {
            symbolOrders[i].priceLevels[j] = tempLevels[j];
        }
    }
}

// Функция определения GMT смещения брокера
int GetBrokerGMTOffset() {
    // Метод 1: По последней свече
    datetime brokerTime = TimeCurrent();
    datetime barTime = iTime(_Symbol, PERIOD_H1, 0);
    
    // Получаем время открытия текущего бара в GMT
    MqlDateTime brokerDt;
    TimeToStruct(barTime, brokerDt);
    
    // Метод 2: Сравнение с известным временем рынка
    // Форекс рынок открывается в воскресенье 22:00 GMT
    // Найдем последнее воскресенье
    datetime currentTime = TimeCurrent();
    MqlDateTime dt;
    TimeToStruct(currentTime, dt);
    
    // Идем назад до воскресенья
    int daysBack = 0;
    while(dt.day_of_week != 0) { // 0 = воскресенье
        currentTime -= 86400; // Вычитаем день
        TimeToStruct(currentTime, dt);
        daysBack++;
        if(daysBack > 7) break; // Защита от бесконечного цикла
    }
    
    // Теперь найдем первый бар после открытия рынка в это воскресенье
    datetime sundayOpen = StringToTime(TimeToString(currentTime, TIME_DATE) + " 00:00");
    int shift = iBarShift(_Symbol, PERIOD_H1, sundayOpen);
    
    // Ищем первый бар после открытия
    for(int i = shift; i >= 0; i--) {
        datetime ibarTime = iTime(_Symbol, PERIOD_H1, i);
        if(ibarTime >= sundayOpen) {
            MqlDateTime barDt;
            TimeToStruct(ibarTime, barDt);
            
            // Если первый бар воскресенья открылся в 22:00 или позже
            if(barDt.day_of_week == 0 && barDt.hour >= 22) {
                // Рынок открывается в 22:00 GMT в воскресенье
                // Смещение = час открытия - 22
                int offset = barDt.hour - 22;
                if(offset < 0) offset += 24;
                
                Print("Первый бар воскресенья: " + TimeToString(ibarTime));
                Print("Час открытия: " + IntegerToString(barDt.hour));
                Print("Вычисленное GMT смещение: " + IntegerToString(offset));
                
                return offset;
            }
        }
    }
    
    // Метод 3: Если не удалось определить автоматически,
    // используем значение по умолчанию для популярных брокеров
    Print("Не удалось автоматически определить GMT смещение");
    Print("Используется значение по умолчанию: GMT+3");
    
    return 3; // Большинство брокеров используют GMT+2 или GMT+3
}

//+------------------------------------------------------------------+
//| Risk Manager Class
//+------------------------------------------------------------------+
class CRiskManager {
private:
    double maxRiskPercent;
    double accountBalance;
    double currentDrawdown;
    
public:
    void SetRiskLevel(ENUM_RISK_LEVEL level) {
        switch(level) {
            case RISK_LOW: maxRiskPercent = 0.5; break;
            case RISK_MEDIUM: maxRiskPercent = 1.0; break;
            case RISK_HIGH: maxRiskPercent = 2.0; break;
        }
    }
    
    double CalculatePositionSize(string symbol, double stopLossPips) {
        accountBalance = AccountInfoDouble(ACCOUNT_BALANCE);
        double riskAmount = accountBalance * (maxRiskPercent / 100.0);
        
        // Получаем все необходимые параметры символа
        double point = SymbolInfoDouble(symbol, SYMBOL_POINT);
        double tickValue = SymbolInfoDouble(symbol, SYMBOL_TRADE_TICK_VALUE);
        double tickSize = SymbolInfoDouble(symbol, SYMBOL_TRADE_TICK_SIZE);
        double contractSize = SymbolInfoDouble(symbol, SYMBOL_TRADE_CONTRACT_SIZE);
        int digits = (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS);
        
        // ВАЖНО: Корректируем понимание "пипсов" для разных инструментов
        double pipValue;
        
        // Определяем размер пипса в зависимости от типа инструмента
        if(digits == 5 || digits == 3) {
            // Форекс с 5 или 3 знаками - пипс = 10 * point
            pipValue = point * 10;
        } else if(digits == 2 || digits == 4) {
            // Форекс с 2 или 4 знаками, CFD - пипс = point
            pipValue = point;
        } else {
            // Остальные инструменты - пипс = point
            pipValue = point;
        }
        
        // Правильный расчет размера позиции
        double lots = 0;
        
        if(tickValue > 0 && tickSize > 0) {
            // Конвертируем стоп-лосс из пипсов в изменение цены
            double priceChange = stopLossPips * pipValue;
            
            // Конвертируем изменение цены в количество тиков
            double ticksCount = priceChange / tickSize;
            
            // Рассчитываем убыток на 1 лот
            double lossPerLot = ticksCount * tickValue;
            
            // Рассчитываем размер позиции
            if(lossPerLot > 0) {
                lots = riskAmount / lossPerLot;
            }
        }
        
        if(lots <= 0) {
            return SymbolInfoDouble(symbol, SYMBOL_VOLUME_MIN);
        }
        
        // Получаем ограничения по лоту
        double maxLot = SymbolInfoDouble(symbol, SYMBOL_VOLUME_MAX);
        double minLot = SymbolInfoDouble(symbol, SYMBOL_VOLUME_MIN);
        double lotStep = SymbolInfoDouble(symbol, SYMBOL_VOLUME_STEP);
        
        // Нормализация по шагу лота
        lots = MathFloor(lots / lotStep) * lotStep;
        
        // Применяем ограничения
        lots = MathMax(minLot, MathMin(maxLot, lots));
        
        // Проверка маржи
        double margin = 0;
        if(OrderCalcMargin(ORDER_TYPE_BUY, symbol, lots, SymbolInfoDouble(symbol, SYMBOL_ASK), margin)) {
            double freeMargin = AccountInfoDouble(ACCOUNT_MARGIN_FREE);
            if(margin > freeMargin * 0.95) {
                double newLots = freeMargin * 0.95 / margin * lots;
                newLots = MathFloor(newLots / lotStep) * lotStep;
                newLots = MathMax(minLot, newLots);
                
                lots = newLots;
            }
        }
        
        // Финальная проверка
        if(lots < minLot) lots = minLot;
        if(lots > maxLot) lots = maxLot;
        
        return lots;
    }
    
    bool CheckDailyLoss() {
        double accountEquity = AccountInfoDouble(ACCOUNT_EQUITY);
        double dailyStart = AccountInfoDouble(ACCOUNT_BALANCE);
        dailyPnL = accountEquity - dailyStart;
        
        if(MathAbs(dailyPnL / dailyStart * 100) >= MaxDailyLoss) {
            tradingHalted = true;
            Comment("Торговля остановлена: достигнут дневной лимит потерь");
            return false;
        }
        return true;
    }
    
    bool CheckConsecutiveLosses() {
        if(consecutiveLosses >= ConsecutiveLossLimit) {
            tradingHalted = true;
            Comment("Торговля остановлена: превышен лимит последовательных убытков");
            return false;
        }
        return true;
    }
};

CRiskManager riskManager;

//+------------------------------------------------------------------+
//| Trading Strategy Class
//+------------------------------------------------------------------+
class CTradingStrategy {
private:
    int pendingBuyTicket;
    int pendingSellTicket;
    
    // Структура для пуллбэк сетапов
    struct PullbackSetup {
        datetime setupTime;
        string symbol;
        double breakoutLevel;
        double entryZoneHigh;
        double entryZoneLow;
        bool isLongSetup;
        datetime expiryTime;
        bool isActive;
        
        PullbackSetup(const PullbackSetup& other) {
            setupTime = other.setupTime;
            symbol = other.symbol;
            breakoutLevel = other.breakoutLevel;
            entryZoneHigh = other.entryZoneHigh;
            entryZoneLow = other.entryZoneLow;
            isLongSetup = other.isLongSetup;
            expiryTime = other.expiryTime;
            isActive = other.isActive;
        }
        
        PullbackSetup() {
            setupTime = 0;
            symbol = "";
            breakoutLevel = 0;
            entryZoneHigh = 0;
            entryZoneLow = 0;
            isLongSetup = false;
            expiryTime = 0;
            isActive = false;
        }
    };
    
    PullbackSetup pullbackSetups[];
    
public:
    CTradingStrategy() {
        pendingBuyTicket = 0;
        pendingSellTicket = 0;
    }
    
    void ExecuteStraddleStrategy(string symbol, NewsEvent& news) {
        // Обновляем существующие ордера если нужно
        UpdateExistingOrders(symbol, news);
        
        // ИСПРАВЛЕНИЕ: Получаем актуальные цены
        MqlTick tick;
        if(!SymbolInfoTick(symbol, tick)) {
            return;
        }
        
        double currentPrice = tick.ask;
        double bid = tick.bid;
        
        // Получаем локальный ATR для символа
        int localATRHandle = iATR(symbol, PERIOD_M15, ATRPeriod);
        double localATRBuffer[];
        double localATR = currentATR;
        
        if(CopyBuffer(localATRHandle, 0, 0, 1, localATRBuffer) > 0) {
            localATR = localATRBuffer[0];
        }
        IndicatorRelease(localATRHandle);
        
        double distance = localATR * ATRMultiplier;
        
        // Для новостей без прогноза увеличиваем расстояние
        if(!news.hasForecast) {
            distance *= 1.5;
        }
        
        double spread = (currentPrice - bid);
        double maxSpread = MaxSpreadPoints * SymbolInfoDouble(symbol, SYMBOL_POINT);
        
        if(spread > maxSpread) {
            return;
        }
        
        // Определяем размер пипса для корректного расчета
        int digits = (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS);
        double point = SymbolInfoDouble(symbol, SYMBOL_POINT);
        double pipSize = (digits == 5 || digits == 3) ? point * 10 : point;
        
        // Конвертируем дистанцию в пипсы для расчета позиции
        double distanceInPips = distance / pipSize;
        
        // ИСПРАВЛЕНИЕ: Правильный расчет SL и TP
        double slDistanceInPips = distanceInPips * StopLossMultiplier;
        double tpDistanceInPips = distanceInPips * TakeProfitMultiplier;
        
        double lotSize = riskManager.CalculatePositionSize(symbol, slDistanceInPips);
        
        // Для Buy Stop используем Ask, для Sell Stop - Bid
        double buyPrice = currentPrice + distance;
        double buySL = buyPrice - (slDistanceInPips * pipSize);
        double buyTP = buyPrice + (tpDistanceInPips * pipSize);
        
        double sellPrice = bid - distance;
        double sellSL = sellPrice + (slDistanceInPips * pipSize);
        double sellTP = sellPrice - (tpDistanceInPips * pipSize);
        
        // Нормализуем цены
        buyPrice = NormalizeDouble(buyPrice, digits);
        buySL = NormalizeDouble(buySL, digits);
        buyTP = NormalizeDouble(buyTP, digits);
        sellPrice = NormalizeDouble(sellPrice, digits);
        sellSL = NormalizeDouble(sellSL, digits);
        sellTP = NormalizeDouble(sellTP, digits);
        
        // Проверяем возможность выставления ордеров
        bool canPlaceBuy = CanPlaceOrder(symbol, buyPrice, news.time, news.title);
        bool canPlaceSell = CanPlaceOrder(symbol, sellPrice, news.time, news.title);
        
        if(!canPlaceBuy && !canPlaceSell) {
            return;
        }
        
        // Рассчитываем время истечения ордера
        datetime expiration = 0;
        if(UseOrderExpiration) {
            expiration = news.time + NewsMinutesAfter * 60;
        }
        
        ulong buyTicket = 0;
        ulong sellTicket = 0;
        
        // ИСПРАВЛЕНИЕ: Размещаем ордера с дополнительными проверками
        if(canPlaceBuy) {
            // Проверяем минимальное расстояние от текущей цены
            if(buyPrice - currentPrice < SymbolInfoInteger(symbol, SYMBOL_TRADE_STOPS_LEVEL) * point) {
                // Корректируем цену
                buyPrice = currentPrice + SymbolInfoInteger(symbol, SYMBOL_TRADE_STOPS_LEVEL) * point;
                buySL = buyPrice - (slDistanceInPips * pipSize);
                buyTP = buyPrice + (tpDistanceInPips * pipSize);
            }
            
            buyTicket = PlacePendingOrder(ORDER_TYPE_BUY_STOP, symbol, buyPrice, buySL, buyTP, lotSize, expiration);
            
            if(buyTicket > 0) {
                RegisterOrderPlaced(symbol, buyPrice, news.time, news.title);
                RegisterOrderForNews(buyTicket, news.time, news.title, news.currency);
            }
        }
        
        if(canPlaceSell) {
            // Проверяем минимальное расстояние от текущей цены  
            if(bid - sellPrice < SymbolInfoInteger(symbol, SYMBOL_TRADE_STOPS_LEVEL) * point) {
                sellPrice = bid - SymbolInfoInteger(symbol, SYMBOL_TRADE_STOPS_LEVEL) * point;
                sellSL = sellPrice + (slDistanceInPips * pipSize);
                sellTP = sellPrice - (tpDistanceInPips * pipSize);
            }
            
            sellTicket = PlacePendingOrder(ORDER_TYPE_SELL_STOP, symbol, sellPrice, sellSL, sellTP, lotSize, expiration);
            
            if(sellTicket > 0) {
                RegisterOrderPlaced(symbol, sellPrice, news.time, news.title);
                RegisterOrderForNews(sellTicket, news.time, news.title, news.currency);
            }
        }
        
        // Регистрируем пару стрэддл ордеров
        if(buyTicket > 0 && sellTicket > 0 && CancelOppositeOrdersOnFill) {
            RegisterStraddlePair(buyTicket, sellTicket, symbol, news.time);
        }
    }
    
    void ExecuteBreakoutStrategy(string symbol, NewsEvent& news) {
        // Обновляем существующие ордера если нужно
        UpdateExistingOrders(symbol, news);
        
        // ИСПРАВЛЕНИЕ: Проверяем волатильность на нескольких таймфреймах
        double highM5 = iHigh(symbol, PERIOD_M5, 1);
        double lowM5 = iLow(symbol, PERIOD_M5, 1);
        double highM1 = iHigh(symbol, PERIOD_M1, 0);
        double lowM1 = iLow(symbol, PERIOD_M1, 0);
        
        double currentPrice = SymbolInfoDouble(symbol, SYMBOL_ASK);
        double bid = SymbolInfoDouble(symbol, SYMBOL_BID);
        
        // Анализ объема
        long currentVolume = iVolume(symbol, PERIOD_M1, 0);
        long avgVolume = 0;
        for(int i = 1; i <= 10; i++) {
            avgVolume += iVolume(symbol, PERIOD_M1, i);
        }
        avgVolume /= 10;
        
        // Условия пробоя
        bool volumeConfirmed = currentVolume > avgVolume * 1.5;
        double breakoutThreshold = currentATR * 0.3; // Снижен порог для большей чувствительности
        
        bool bullishBreakout = (currentPrice > highM5 + breakoutThreshold) || 
                               (currentPrice > highM1 + breakoutThreshold && volumeConfirmed);
        bool bearishBreakout = (bid < lowM5 - breakoutThreshold) || 
                               (bid < lowM1 - breakoutThreshold && volumeConfirmed);
        
        if((bullishBreakout || bearishBreakout) && volumeConfirmed) {
            // Корректный расчет размера позиции
            int digits = (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS);
            double point = SymbolInfoDouble(symbol, SYMBOL_POINT);
            double pipSize = (digits == 5 || digits == 3) ? point * 10 : point;
            
            double distanceInPips = currentATR * 0.75 / pipSize;
            double slDistanceInPips = distanceInPips * StopLossMultiplier;
            double tpDistanceInPips = distanceInPips * TakeProfitMultiplier;
            
            double lotSize = riskManager.CalculatePositionSize(symbol, slDistanceInPips);
            
            if(bullishBreakout) {
                if(CanPlaceOrder(symbol, currentPrice, news.time, news.title)) {
                    double sl = currentPrice - (slDistanceInPips * pipSize);
                    double tp = currentPrice + (tpDistanceInPips * pipSize);
                    
                    // Используем рыночный ордер для немедленного входа
                    if(trade.Buy(lotSize, symbol, 0, sl, tp, "Breakout Buy")) {
                        RegisterOrderPlaced(symbol, currentPrice, news.time, news.title);
                        
                        // Получаем ticket последней позиции
                        ulong ticket = 0;
                        for(int i = PositionsTotal() - 1; i >= 0; i--) {
                            if(PositionSelectByTicket(PositionGetTicket(i))) {
                                if(PositionGetString(POSITION_SYMBOL) == symbol &&
                                   PositionGetInteger(POSITION_MAGIC) == MagicNumber) {
                                    ticket = PositionGetTicket(i);
                                    RegisterPosition(ticket, symbol, currentPrice, sl);
                                    break;
                                }
                            }
                        }
                        if(ticket > 0) {
                            RegisterOrderForNews(ticket, news.time, news.title, news.currency);
                        }
                    }
                }
            } else if(bearishBreakout) {
                if(CanPlaceOrder(symbol, bid, news.time, news.title)) {
                    double sl = bid + (slDistanceInPips * pipSize);
                    double tp = bid - (tpDistanceInPips * pipSize);
                    
                    if(trade.Sell(lotSize, symbol, 0, sl, tp, "Breakout Sell")) {
                        RegisterOrderPlaced(symbol, bid, news.time, news.title);
                        
                        // Получаем ticket последней позиции
                        ulong ticket = 0;
                        for(int i = PositionsTotal() - 1; i >= 0; i--) {
                            if(PositionSelectByTicket(PositionGetTicket(i))) {
                                if(PositionGetString(POSITION_SYMBOL) == symbol &&
                                   PositionGetInteger(POSITION_MAGIC) == MagicNumber) {
                                    ticket = PositionGetTicket(i);
                                    RegisterPosition(ticket, symbol, bid, sl);
                                    break;
                                }
                            }
                        }
                        if(ticket > 0) {
                            RegisterOrderForNews(ticket, news.time, news.title, news.currency);
                        }
                    }
                }
            }
        } else {
            // Если пробоя нет, размещаем отложенные ордера
            double distance = currentATR * 0.5; // Меньшее расстояние для отложенных ордеров
            
            // Корректный расчет размера позиции
            int digits = (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS);
            double point = SymbolInfoDouble(symbol, SYMBOL_POINT);
            double pipSize = (digits == 5 || digits == 3) ? point * 10 : point;
            
            double distanceInPips = distance / pipSize;
            double slDistanceInPips = distanceInPips * StopLossMultiplier;
            double tpDistanceInPips = distanceInPips * TakeProfitMultiplier;
            
            double lotSize = riskManager.CalculatePositionSize(symbol, slDistanceInPips);
            
            // Buy Stop выше текущего максимума
            double buyPrice = highM5 + distance;
            double buySL = buyPrice - (slDistanceInPips * pipSize);
            double buyTP = buyPrice + (tpDistanceInPips * pipSize);
            
            // Sell Stop ниже текущего минимума  
            double sellPrice = lowM5 - distance;
            double sellSL = sellPrice + (slDistanceInPips * pipSize);
            double sellTP = sellPrice - (tpDistanceInPips * pipSize);
            
            datetime expiration = UseOrderExpiration ? news.time + NewsMinutesAfter * 60 : 0;
            
            if(CanPlaceOrder(symbol, buyPrice, news.time, news.title)) {
                ulong buyTicket = PlacePendingOrder(ORDER_TYPE_BUY_STOP, symbol, buyPrice, buySL, buyTP, lotSize, expiration);
                if(buyTicket > 0) {
                    RegisterOrderPlaced(symbol, buyPrice, news.time, news.title);
                    RegisterOrderForNews(buyTicket, news.time, news.title, news.currency);
                }
            }
            
            if(CanPlaceOrder(symbol, sellPrice, news.time, news.title)) {
                ulong sellTicket = PlacePendingOrder(ORDER_TYPE_SELL_STOP, symbol, sellPrice, sellSL, sellTP, lotSize, expiration);
                if(sellTicket > 0) {
                    RegisterOrderPlaced(symbol, sellPrice, news.time, news.title);
                    RegisterOrderForNews(sellTicket, news.time, news.title, news.currency);
                }
            }
        }
    }
    
    void ExecutePullbackStrategy(string symbol, NewsEvent& news) {
        // Обновляем существующие ордера если нужно
        UpdateExistingOrders(symbol, news);
        
        // Получаем уровни поддержки/сопротивления
        double highM15 = iHigh(symbol, PERIOD_M15, iHighest(symbol, PERIOD_M15, MODE_HIGH, 20, 1));
        double lowM15 = iLow(symbol, PERIOD_M15, iLowest(symbol, PERIOD_M15, MODE_LOW, 20, 1));
        
        double currentPrice = SymbolInfoDouble(symbol, SYMBOL_ASK);
        double bid = SymbolInfoDouble(symbol, SYMBOL_BID);
        
        // Проверяем, есть ли уже активный сетап для этого символа
        int setupIndex = FindActiveSetup(symbol);
        
        if(setupIndex >= 0) {
            // Проверяем условия для входа
            if(CheckPullbackEntry(setupIndex)) {
                EnterPullbackTrade(setupIndex, news);
            } else if(ShouldCancelPullbackSetup(setupIndex)) {
                CancelPullbackSetup(setupIndex);
            }
        } else {
            // Определяем ключевой уровень
            double keyLevel = (MathAbs(currentPrice - highM15) < MathAbs(currentPrice - lowM15)) ? highM15 : lowM15;
            
            // ИСПРАВЛЕНИЕ: Упрощенная логика определения пробоя
            double breakoutDistance = currentATR * 0.5;
            bool breakoutDetected = false;
            bool isBullish = false;
            
            if(currentPrice > highM15 + breakoutDistance) {
                breakoutDetected = true;
                isBullish = true;
                keyLevel = highM15;
            } else if(bid < lowM15 - breakoutDistance) {
                breakoutDetected = true;
                isBullish = false;
                keyLevel = lowM15;
            }
            
            // Если пробой обнаружен, создаем сетап для пуллбэка
            if(breakoutDetected) {
                CreatePullbackSetup(symbol, keyLevel, news);
            } else {
                // Если пробоя нет, размещаем отложенные ордера на уровнях
                int digits = (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS);
                double point = SymbolInfoDouble(symbol, SYMBOL_POINT);
                double pipSize = (digits == 5 || digits == 3) ? point * 10 : point;
                
                double distance = currentATR * 0.3;
                double distanceInPips = distance / pipSize;
                double slDistanceInPips = distanceInPips * StopLossMultiplier * 0.7; // Меньший стоп для пуллбэка
                double tpDistanceInPips = distanceInPips * TakeProfitMultiplier * 1.5; // Больший тейк для пуллбэка
                
                double lotSize = riskManager.CalculatePositionSize(symbol, slDistanceInPips);
                
                // Ордер на отскок от верхнего уровня (sell limit)
                if(currentPrice < highM15 - distance) {
                    double sellPrice = highM15 - distance * 0.236; // Уровень Фибоначчи
                    double sellSL = sellPrice + (slDistanceInPips * pipSize);
                    double sellTP = sellPrice - (tpDistanceInPips * pipSize);
                    
                    if(CanPlaceOrder(symbol, sellPrice, news.time, news.title)) {
                        datetime expiration = UseOrderExpiration ? news.time + NewsMinutesAfter * 60 : 0;
                        ulong sellTicket = PlacePendingOrder(ORDER_TYPE_SELL_LIMIT, symbol, sellPrice, sellSL, sellTP, lotSize, expiration);
                        if(sellTicket > 0) {
                            RegisterOrderPlaced(symbol, sellPrice, news.time, news.title);
                            RegisterOrderForNews(sellTicket, news.time, news.title, news.currency);
                        }
                    }
                }
                
                // Ордер на отскок от нижнего уровня (buy limit)
                if(bid > lowM15 + distance) {
                    double buyPrice = lowM15 + distance * 0.236;
                    double buySL = buyPrice - (slDistanceInPips * pipSize);
                    double buyTP = buyPrice + (tpDistanceInPips * pipSize);
                    
                    if(CanPlaceOrder(symbol, buyPrice, news.time, news.title)) {
                        datetime expiration = UseOrderExpiration ? news.time + NewsMinutesAfter * 60 : 0;
                        ulong buyTicket = PlacePendingOrder(ORDER_TYPE_BUY_LIMIT, symbol, buyPrice, buySL, buyTP, lotSize, expiration);
                        if(buyTicket > 0) {
                            RegisterOrderPlaced(symbol, buyPrice, news.time, news.title);
                            RegisterOrderForNews(buyTicket, news.time, news.title, news.currency);
                        }
                    }
                }
            }
        }
    }
    
    void ExecuteFundamentalStrategy(string symbol, NewsEvent& news) {
        // Стратегия работает только с новостями, где есть прогноз и фактическое значение
        if(!news.hasForecast || news.actual == 0) {
            return;
        }
        
        // Вычисляем отклонение фактического значения от прогноза
        double deviation = 0;
        if(news.forecast != 0) {
            deviation = ((news.actual - news.forecast) / MathAbs(news.forecast)) * 100.0;
        } else {
            // Если прогноз 0, сравниваем с предыдущим значением
            if(news.previous != 0) {
                deviation = ((news.actual - news.previous) / MathAbs(news.previous)) * 100.0;
            } else {
                return; // Невозможно определить отклонение
            }
        }
        
        // Проверяем минимальное отклонение
        if(MathAbs(deviation) < FundamentalDeviationPercent) {
            return;
        }
        
        // Определяем направление на основе типа новости и отклонения
        bool shouldBuy = false;
        bool shouldSell = false;
        
        // Анализ по типу новости
        string titleUpper = news.title;
        StringToUpper(titleUpper);
        
        // Позитивные для валюты индикаторы (рост = укрепление валюты)
        if(StringFind(titleUpper, "GDP") >= 0 ||
           StringFind(titleUpper, "EMPLOYMENT") >= 0 ||
           StringFind(titleUpper, "NFP") >= 0 ||
           StringFind(titleUpper, "RETAIL SALES") >= 0 ||
           StringFind(titleUpper, "PMI") >= 0 ||
           StringFind(titleUpper, "CONSUMER CONFIDENCE") >= 0) {
            
            if(deviation > 0) { // Лучше прогноза
                // Для базовой валюты пары - покупаем
                if(StringFind(symbol, news.currency) == 0) shouldBuy = true;
                // Для котируемой валюты - продаем
                else if(StringFind(symbol, news.currency) > 0) shouldSell = true;
            } else { // Хуже прогноза
                if(StringFind(symbol, news.currency) == 0) shouldSell = true;
                else if(StringFind(symbol, news.currency) > 0) shouldBuy = true;
            }
        }
        // CPI и процентные ставки - особая логика
        else if(StringFind(titleUpper, "CPI") >= 0 ||
                StringFind(titleUpper, "INTEREST RATE") >= 0 ||
                StringFind(titleUpper, "RATE DECISION") >= 0) {
            
            // Высокая инфляция или повышение ставок обычно укрепляют валюту
            if(deviation > 0) {
                if(StringFind(symbol, news.currency) == 0) shouldBuy = true;
                else if(StringFind(symbol, news.currency) > 0) shouldSell = true;
            } else {
                if(StringFind(symbol, news.currency) == 0) shouldSell = true;
                else if(StringFind(symbol, news.currency) > 0) shouldBuy = true;
            }
        }
        // Безработица - инвертированная логика
        else if(StringFind(titleUpper, "UNEMPLOYMENT") >= 0) {
            if(deviation > 0) { // Больше безработных - плохо для валюты
                if(StringFind(symbol, news.currency) == 0) shouldSell = true;
                else if(StringFind(symbol, news.currency) > 0) shouldBuy = true;
            } else {
                if(StringFind(symbol, news.currency) == 0) shouldBuy = true;
                else if(StringFind(symbol, news.currency) > 0) shouldSell = true;
            }
        }
        
        // Дополнительный фильтр для больших сюрпризов
        if(TradeOnlyMajorSurprises && MathAbs(deviation) < FundamentalDeviationPercent * 2) {
            return;
        }
        
        // Открываем позицию
        if(shouldBuy || shouldSell) {
            double currentPrice = shouldBuy ? SymbolInfoDouble(symbol, SYMBOL_ASK) : SymbolInfoDouble(symbol, SYMBOL_BID);
            
            // Расчет параметров позиции
            int digits = (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS);
            double point = SymbolInfoDouble(symbol, SYMBOL_POINT);
            double pipSize = (digits == 5 || digits == 3) ? point * 10 : point;
            
            // Используем специальный множитель ATR для фундаментальной стратегии
            double distance = currentATR * FundamentalATRMultiplier;
            double distanceInPips = distance / pipSize;
            double slDistanceInPips = distanceInPips * StopLossMultiplier;
            double tpDistanceInPips = distanceInPips * TakeProfitMultiplier;
            
            // Увеличиваем TP для больших отклонений
            if(MathAbs(deviation) > FundamentalDeviationPercent * 3) {
                tpDistanceInPips *= 1.5;
            }
            
            double lotSize = riskManager.CalculatePositionSize(symbol, slDistanceInPips);
            
            if(shouldBuy) {
                if(CanPlaceOrder(symbol, currentPrice, news.time, news.title)) {
                    double sl = currentPrice - (slDistanceInPips * pipSize);
                    double tp = currentPrice + (tpDistanceInPips * pipSize);
                    
                    string comment = StringFormat("Fund Buy: %s %.1f%%", news.title, deviation);
                    if(trade.Buy(lotSize, symbol, 0, sl, tp, comment)) {
                        RegisterOrderPlaced(symbol, currentPrice, news.time, news.title);
                        
                        // Получаем ticket последней позиции
                        ulong ticket = 0;
                        for(int i = PositionsTotal() - 1; i >= 0; i--) {
                            if(PositionSelectByTicket(PositionGetTicket(i))) {
                                if(PositionGetString(POSITION_SYMBOL) == symbol &&
                                   PositionGetInteger(POSITION_MAGIC) == MagicNumber) {
                                    ticket = PositionGetTicket(i);
                                    RegisterPosition(ticket, symbol, currentPrice, sl);
                                    break;
                                }
                            }
                        }
                        if(ticket > 0) {
                            RegisterOrderForNews(ticket, news.time, news.title, news.currency);
                        }
                        
                        SendAlert(StringFormat("Фундаментальная покупка %s: %s отклонение %.1f%%", 
                                             symbol, news.title, deviation));
                    }
                }
            } else if(shouldSell) {
                if(CanPlaceOrder(symbol, currentPrice, news.time, news.title)) {
                    double sl = currentPrice + (slDistanceInPips * pipSize);
                    double tp = currentPrice - (tpDistanceInPips * pipSize);
                    
                    string comment = StringFormat("Fund Sell: %s %.1f%%", news.title, deviation);
                    if(trade.Sell(lotSize, symbol, 0, sl, tp, comment)) {
                        RegisterOrderPlaced(symbol, currentPrice, news.time, news.title);
                        
                        // Получаем ticket последней позиции
                        ulong ticket = 0;
                        for(int i = PositionsTotal() - 1; i >= 0; i--) {
                            if(PositionSelectByTicket(PositionGetTicket(i))) {
                                if(PositionGetString(POSITION_SYMBOL) == symbol &&
                                   PositionGetInteger(POSITION_MAGIC) == MagicNumber) {
                                    ticket = PositionGetTicket(i);
                                    RegisterPosition(ticket, symbol, currentPrice, sl);
                                    break;
                                }
                            }
                        }
                        if(ticket > 0) {
                            RegisterOrderForNews(ticket, news.time, news.title, news.currency);
                        }
                        
                        SendAlert(StringFormat("Фундаментальная продажа %s: %s отклонение %.1f%%", 
                                             symbol, news.title, deviation));
                    }
                }
            }
        }
    }
    
    bool IsBreakoutDetected(string symbol, double breakoutLevel) {
        double currentPrice = SymbolInfoDouble(symbol, SYMBOL_ASK);
        double prevPrice = iClose(symbol, PERIOD_M5, 1);
        
        // Проверяем пробой с подтверждением объемом
        long currentVolume = iVolume(symbol, PERIOD_M1, 0);
        long avgVolume = 0;
        for(int i = 1; i <= 10; i++) {
            avgVolume += iVolume(symbol, PERIOD_M1, i);
        }
        avgVolume /= 10;
        
        bool volumeConfirmed = currentVolume > avgVolume * 1.5;
        
        // Пробой вверх
        if(prevPrice < breakoutLevel && currentPrice > breakoutLevel && volumeConfirmed) {
            return true;
        }
        
        // Пробой вниз
        if(prevPrice > breakoutLevel && currentPrice < breakoutLevel && volumeConfirmed) {
            return true;
        }
        
        return false;
    }
    
    void CreatePullbackSetup(string symbol, double breakoutLevel, NewsEvent& news) {
        int size = ArraySize(pullbackSetups);
        ArrayResize(pullbackSetups, size + 1);
        
        PullbackSetup setup;
        setup.setupTime = TimeCurrent();
        setup.symbol = symbol;
        setup.breakoutLevel = breakoutLevel;
        setup.isActive = true;
        
        // Время истечения сетапа
        if(UseOrderExpiration) {
            setup.expiryTime = news.time + OrderExpirationMinutes * 60;
        } else {
            setup.expiryTime = news.time + NewsMinutesAfter * 60;
        }
        
        double currentPrice = SymbolInfoDouble(symbol, SYMBOL_ASK);
        
        if(currentPrice > breakoutLevel) {
            // Пробой вверх - ждем пуллбэк вниз
            setup.isLongSetup = true;
            double moveSize = currentPrice - breakoutLevel;
            setup.entryZoneHigh = breakoutLevel + moveSize * 0.618; // 61.8% уровень
            setup.entryZoneLow = breakoutLevel + moveSize * 0.382;  // 38.2% уровень
        } else {
            // Пробой вниз - ждем пуллбэк вверх
            setup.isLongSetup = false;
            double moveSize = breakoutLevel - currentPrice;
            setup.entryZoneLow = breakoutLevel - moveSize * 0.618;  // 61.8% уровень
            setup.entryZoneHigh = breakoutLevel - moveSize * 0.382; // 38.2% уровень
        }
        
        pullbackSetups[size] = setup;
    }
    
    bool CheckPullbackEntry(int setupIndex) {
        if(setupIndex < 0 || setupIndex >= ArraySize(pullbackSetups)) return false;
        
        PullbackSetup setup;
        setup = pullbackSetups[setupIndex];
        double currentPrice = SymbolInfoDouble(setup.symbol, SYMBOL_ASK);
        
        // Проверяем, что цена в зоне входа
        if(currentPrice >= setup.entryZoneLow && currentPrice <= setup.entryZoneHigh) {
            // Дополнительное подтверждение - проверка паттернов
            if(IsPullbackConfirmed(setup.symbol, setup.isLongSetup)) {
                return true;
            }
        }
        
        return false;
    }
    
    bool IsPullbackConfirmed(string symbol, bool isLongSetup) {
        // Проверяем формирование разворотного паттерна
        double close1 = iClose(symbol, PERIOD_M5, 1);
        double close2 = iClose(symbol, PERIOD_M5, 2);
        double close3 = iClose(symbol, PERIOD_M5, 3);
        
        double open1 = iOpen(symbol, PERIOD_M5, 1);
        double open2 = iOpen(symbol, PERIOD_M5, 2);
        double high1 = iHigh(symbol, PERIOD_M5, 1);
        double low1 = iLow(symbol, PERIOD_M5, 1);
        
        if(isLongSetup) {
            // Для лонга ищем бычий разворот
            // Паттерн "молот" или поглощение
            bool hammer = (close1 > open1) && ((high1 - close1) < (close1 - open1) * 0.3) && 
                         ((open1 - low1) > (close1 - open1) * 2);
            bool engulfing = (close1 > open1) && (close2 < open2) && (close1 > open2) && (open1 < close2);
            
            return hammer || engulfing || (close3 > close2 && close2 < close1 && close1 > close2);
        } else {
            // Для шорта ищем медвежий разворот
            // Паттерн "падающая звезда" или поглощение
            bool shootingStar = (close1 < open1) && ((close1 - low1) < (open1 - close1) * 0.3) && 
                               ((high1 - open1) > (open1 - close1) * 2);
            bool engulfing = (close1 < open1) && (close2 > open2) && (close1 < open2) && (open1 > close2);
            
            return shootingStar || engulfing || (close3 < close2 && close2 > close1 && close1 < close2);
        }
    }
    
    bool ShouldCancelPullbackSetup(int setupIndex) {
        if(setupIndex < 0 || setupIndex >= ArraySize(pullbackSetups)) return false;
        
        PullbackSetup setup;
        setup = pullbackSetups[setupIndex];
        double currentPrice = SymbolInfoDouble(setup.symbol, SYMBOL_ASK);
        datetime currentTime = TimeCurrent();
        
        // УСЛОВИЯ ОТМЕНЫ:
        
        // 1. Истекло время ожидания
        if(currentTime > setup.expiryTime) {
            return true;
        }
        
        // 2. Цена ушла слишком далеко без пуллбэка
        double distanceFromBreakout = MathAbs(currentPrice - setup.breakoutLevel);
        if(distanceFromBreakout > currentATR * 5) {
            return true;
        }
        
        // 3. Пробой уровня поддержки/сопротивления в противоположном направлении
        if(setup.isLongSetup && currentPrice < setup.breakoutLevel - currentATR) {
            return true;
        }
        
        if(!setup.isLongSetup && currentPrice > setup.breakoutLevel + currentATR) {
            return true;
        }
        
        // 4. Слишком глубокий откат (больше 78.6%)
        if(setup.isLongSetup) {
            double moveSize = setup.entryZoneHigh - setup.breakoutLevel;
            if(currentPrice < setup.breakoutLevel + moveSize * 0.214) { // Ниже 21.4% = глубже 78.6%
                return true;
            }
        } else {
            double moveSize = setup.breakoutLevel - setup.entryZoneLow;
            if(currentPrice > setup.breakoutLevel - moveSize * 0.214) {
                return true;
            }
        }
        
        // 5. Изменение волатильности
        double currentATRLocal = GetCurrentATR(setup.symbol);
        double setupATR = currentATR; // ATR на момент создания сетапа
        if(currentATRLocal < setupATR * 0.5) {
            return true;
        }
        
        return false;
    }
    
    void CancelPullbackSetup(int setupIndex) {
        if(setupIndex < 0 || setupIndex >= ArraySize(pullbackSetups)) return;
        
        pullbackSetups[setupIndex].isActive = false;
        SendAlert(StringFormat("Пуллбэк сетап отменен для %s", pullbackSetups[setupIndex].symbol));
    }
    
    void EnterPullbackTrade(int setupIndex, NewsEvent& news) {
        if(setupIndex < 0 || setupIndex >= ArraySize(pullbackSetups)) return;
        
        PullbackSetup setup;
        setup = pullbackSetups[setupIndex];
        
        double currentPrice = SymbolInfoDouble(setup.symbol, setup.isLongSetup ? SYMBOL_ASK : SYMBOL_BID);
        
        if(!CanPlaceOrder(setup.symbol, currentPrice, news.time, news.title)) {
            return;
        }
        
        // Корректный расчет размера позиции
        int digits = (int)SymbolInfoInteger(setup.symbol, SYMBOL_DIGITS);
        double point = SymbolInfoDouble(setup.symbol, SYMBOL_POINT);
        double pipSize = (digits == 5 || digits == 3) ? point * 10 : point;
        
        double distanceInPips = currentATR / pipSize;
        double slDistanceInPips = distanceInPips * 0.5; // Более тайтный стоп для пуллбэка
        double tpDistanceInPips = distanceInPips * TakeProfitMultiplier * 1.5;
        
        double lotSize = riskManager.CalculatePositionSize(setup.symbol, slDistanceInPips);
        
        if(setup.isLongSetup) {
            double sl = setup.entryZoneLow - (slDistanceInPips * pipSize);
            double tp = setup.breakoutLevel + (tpDistanceInPips * pipSize);
            
            if(trade.Buy(lotSize, setup.symbol, 0, sl, tp, "Pullback Buy")) {
                RegisterOrderPlaced(setup.symbol, currentPrice, news.time, news.title);
                
                // Получаем ticket последней позиции
                ulong ticket = 0;
                for(int i = PositionsTotal() - 1; i >= 0; i--) {
                    if(PositionSelectByTicket(PositionGetTicket(i))) {
                        if(PositionGetString(POSITION_SYMBOL) == setup.symbol &&
                           PositionGetInteger(POSITION_MAGIC) == MagicNumber) {
                            ticket = PositionGetTicket(i);
                            RegisterPosition(ticket, setup.symbol, currentPrice, sl);
                            break;
                        }
                    }
                }
                if(ticket > 0) {
                    RegisterOrderForNews(ticket, news.time, news.title, news.currency);
                }
            }
        } else {
            double sl = setup.entryZoneHigh + (slDistanceInPips * pipSize);
            double tp = setup.breakoutLevel - (tpDistanceInPips * pipSize);
            
            if(trade.Sell(lotSize, setup.symbol, 0, sl, tp, "Pullback Sell")) {
                RegisterOrderPlaced(setup.symbol, currentPrice, news.time, news.title);
                
                // Получаем ticket последней позиции
                ulong ticket = 0;
                for(int i = PositionsTotal() - 1; i >= 0; i--) {
                    if(PositionSelectByTicket(PositionGetTicket(i))) {
                        if(PositionGetString(POSITION_SYMBOL) == setup.symbol &&
                           PositionGetInteger(POSITION_MAGIC) == MagicNumber) {
                            ticket = PositionGetTicket(i);
                            RegisterPosition(ticket, setup.symbol, currentPrice, sl);
                            break;
                        }
                    }
                }
                if(ticket > 0) {
                    RegisterOrderForNews(ticket, news.time, news.title, news.currency);
                }
            }
        }
        
        pullbackSetups[setupIndex].isActive = false; // Деактивируем сетап после входа
    }
    
    int FindActiveSetup(string symbol) {
        for(int i = 0; i < ArraySize(pullbackSetups); i++) {
            if(pullbackSetups[i].symbol == symbol && pullbackSetups[i].isActive) {
                return i;
            }
        }
        return -1;
    }
    
    double GetCurrentATR(string symbol) {
        int atrHandleLocal = iATR(symbol, PERIOD_M15, ATRPeriod);
        double atrBuffer[];
        if(CopyBuffer(atrHandleLocal, 0, 0, 1, atrBuffer) > 0) {
            IndicatorRelease(atrHandleLocal);
            return atrBuffer[0];
        }
        return 0;
    }
    
    // Функция для очистки неактивных сетапов (вызывать периодически)
    void CleanupInactiveSetups() {
        PullbackSetup tempSetups[];
        int tempCount = 0;
        
        for(int i = 0; i < ArraySize(pullbackSetups); i++) {
            if(pullbackSetups[i].isActive || 
               TimeCurrent() - pullbackSetups[i].setupTime < 3600) { // Храним историю час
                ArrayResize(tempSetups, tempCount + 1);
                tempSetups[tempCount] = pullbackSetups[i];
                tempCount++;
            }
        }
        
        ArrayResize(pullbackSetups, tempCount);
        for(int i = 0; i < tempCount; i++) {
            pullbackSetups[i] = tempSetups[i];
        }
    }
    
    double GetBreakoutLevel(string symbol) {
        double high = iHigh(symbol, PERIOD_M15, iHighest(symbol, PERIOD_M15, MODE_HIGH, 20, 1));
        double low = iLow(symbol, PERIOD_M15, iLowest(symbol, PERIOD_M15, MODE_LOW, 20, 1));
        double currentPrice = SymbolInfoDouble(symbol, SYMBOL_ASK);
        
        return (currentPrice > (high + low) / 2) ? high : low;
    }
    
    bool IsValidPullback(string symbol, double breakoutLevel, double ratio) {
        double currentPrice = SymbolInfoDouble(symbol, SYMBOL_ASK);
        double retracement = MathAbs(currentPrice - breakoutLevel) / currentATR;
        
        return (retracement >= ratio * 0.8 && retracement <= ratio * 1.2);
    }
};

CTradingStrategy strategy;

//+------------------------------------------------------------------+
//| Tester News Manager Class
//+------------------------------------------------------------------+
class CTesterNewsManager {
private:
    string dataPath;
    
public:
    CTesterNewsManager() {
        dataPath = NewsDataPath;
    }
    
    bool LoadNewsForMonth(datetime currentTime, NewsEvent &newsArray[]) {
        MqlDateTime dt;
        TimeToStruct(currentTime, dt);
        
        string filename = StringFormat("%02d%04d.csv", dt.mon, dt.year);
        
        int fileHandle = INVALID_HANDLE;
        
        // Попытка 1: Просто имя файла (для тестера)
        fileHandle = FileOpen(filename, FILE_READ|FILE_TXT|FILE_ANSI);
        
        // Попытка 2: С подпапкой NewsData
        if(fileHandle == INVALID_HANDLE && NewsDataPath != "") {
            string filepath = NewsDataPath + "\\" + filename;
            fileHandle = FileOpen(filepath, FILE_READ|FILE_TXT|FILE_ANSI);
        }
        
        // Попытка 3: Использовать FILE_COMMON для доступа к общей папке
        if(fileHandle == INVALID_HANDLE) {
            fileHandle = FileOpen(filename, FILE_READ|FILE_TXT|FILE_ANSI|FILE_COMMON);
        }
        
        // Попытка 4: FILE_COMMON с подпапкой
        if(fileHandle == INVALID_HANDLE && NewsDataPath != "") {
            string filepath = NewsDataPath + "\\" + filename;
            fileHandle = FileOpen(filepath, FILE_READ|FILE_TXT|FILE_ANSI|FILE_COMMON);
        }
        
        if(fileHandle == INVALID_HANDLE) {
            return false;
        }
        
        ArrayResize(newsArray, 0);
        int count = 0;
        int lineNumber = 0;
        
        // Пропускаем заголовок если есть
        string firstLine = FileReadString(fileHandle);
        if(StringFind(firstLine, "DateTime") >= 0) {
            lineNumber = 1;
        } else {
            FileSeek(fileHandle, 0, SEEK_SET);
            lineNumber = 0;
        }
        
        // Читаем данные
        while(!FileIsEnding(fileHandle)) {
            lineNumber++;
            string line = FileReadString(fileHandle);
            
            if(line == "") continue;
            
            // Разбиваем строку по запятым
            string fields[];
            int fieldCount = StringSplit(line, ',', fields);
            
            if(fieldCount < 6) {
                continue;
            }
            
            // Парсим поля
            NewsEvent news;
            
            // DateTime
            news.time = StringToTime(fields[0]);
            if(news.time == 0) {
                continue;
            }
            
            // Currency
            string currencyStr = fields[1];
            StringTrimLeft(currencyStr);
            StringTrimRight(currencyStr);
            StringReplace(currencyStr, "\"", "");
            
            // Title
            news.title = fields[2];
            StringReplace(news.title, "\"", "");
            
            // Impact
            news.impact = (int)StringToInteger(fields[3]);
            
            // Forecast
            if(fields[4] != "" && fields[4] != "-") {
                news.forecast = StringToDouble(fields[4]);
                news.hasForecast = true;
            } else {
                news.forecast = 0;
                news.hasForecast = false;
            }
            
            // Previous
            news.previous = StringToDouble(fields[5]);
            
            news.actual = 0;
            news.processed = false;
            news.actualReleased = false;
            
            // Обрабатываем множественные валюты
            string currencies[];
            int currencyCount = StringSplit(currencyStr, ' ', currencies);
            
            for(int i = 0; i < currencyCount; i++) {
                string currency = currencies[i];
                StringTrimLeft(currency);
                StringTrimRight(currency);
                
                if(StringLen(currency) == 3) {
                    NewsEvent newsCopy = news;
                    newsCopy.currency = currency;
                    
                    ArrayResize(newsArray, count + 1);
                    newsArray[count] = newsCopy;
                    count++;
                }
            }
        }
        
        FileClose(fileHandle);
        
        return count > 0;
    }
    
    void GenerateActualValue(NewsEvent &news) {
        if(news.actualReleased) return;
        
        // Для фундаментальной стратегии важно генерировать значительные отклонения
        if(TradingStrategy == STRATEGY_FUNDAMENTAL) {
            if(news.hasForecast) {
                // Генерируем более выраженные отклонения для фундаментальной стратегии
                double baseVariation = (MathRand() % 2001 - 1000) / 1000.0; // от -1 до 1
                
                // Увеличиваем вероятность больших отклонений
                if(MathRand() % 100 < 30) { // 30% вероятность большого отклонения
                    baseVariation *= 2.0; // Удваиваем отклонение
                }
                
                double variation = baseVariation * ActualVariation / 100.0;
                news.actual = news.forecast * (1 + variation);
                
            } else {
                // Для новостей без прогноза также генерируем значительные изменения
                if(news.previous != 0) {
                    double variation = (MathRand() % 1501 - 750) / 1000.0; // от -0.75 до 0.75
                    news.actual = news.previous * (1 + variation * ActualVariation / 100.0);
                } else {
                    // Генерируем значения на основе типа новости
                    if(StringFind(news.title, "Rate") >= 0 || StringFind(news.title, "CPI") >= 0) {
                        news.actual = 2.0 + (MathRand() % 300) / 100.0; // 2.0-5.0
                    } else if(StringFind(news.title, "GDP") >= 0) {
                        news.actual = -2.0 + (MathRand() % 800) / 100.0; // -2.0 до 6.0
                    } else if(StringFind(news.title, "Employment") >= 0 || StringFind(news.title, "NFP") >= 0) {
                        news.actual = 50 + (MathRand() % 500); // 50-550K
                    } else {
                        news.actual = (MathRand() % 2000 - 1000) / 10.0; // -100 до 100
                    }
                }
            }
            
            // Для фундаментальной стратегии увеличиваем волатильность еще больше
            currentATR *= 1.5;
            
        } else {
            // Обычная генерация для других стратегий
            if(news.hasForecast) {
                double variation = (MathRand() % 2001 - 1000) / 1000.0; // от -1 до 1
                variation = variation * ActualVariation / 100.0;
                
                news.actual = news.forecast * (1 + variation);
                
                // Добавляем случайные сюрпризы (10% вероятность)
                if(MathRand() % 100 < 10) {
                    double surprise = (MathRand() % 2 == 0) ? 1.5 : 0.5;
                    news.actual *= surprise;
                    currentATR *= SurpriseVolatilityMultiplier;
                }
            } else {
                if(news.previous != 0) {
                    double variation = (MathRand() % 1001 - 500) / 1000.0;
                    news.actual = news.previous * (1 + variation * ActualVariation / 100.0);
                } else {
                    // Стандартная генерация
                    if(StringFind(news.title, "Rate") >= 0 || StringFind(news.title, "CPI") >= 0) {
                        news.actual = 2.0 + (MathRand() % 300) / 100.0;
                    } else if(StringFind(news.title, "GDP") >= 0) {
                        news.actual = -2.0 + (MathRand() % 600) / 100.0;
                    } else if(StringFind(news.title, "Employment") >= 0 || StringFind(news.title, "NFP") >= 0) {
                        news.actual = 50 + (MathRand() % 400);
                    } else {
                        news.actual = (MathRand() % 1000 - 500) / 10.0;
                    }
                }
                
                currentATR *= 1.3;
            }
        }
        
        news.actualReleased = true;
    }
    
    void UpdateActualsForCurrentTime(NewsEvent &newsArray[]) {
        datetime currentTime = TimeCurrent();
        
        for(int i = 0; i < ArraySize(newsArray); i++) {
            // Если время новости прошло, генерируем actual
            if(newsArray[i].time <= currentTime && !newsArray[i].actualReleased) {
                GenerateActualValue(newsArray[i]);
            }
        }
    }
    
    void CreateSampleNewsFile() {
        // Создает пример файла новостей для тестирования
        MqlDateTime dt;
        TimeToStruct(TimeCurrent(), dt);
        
        string filename = StringFormat("%02d%04d_sample.csv", dt.mon, dt.year);
        string filepath = NewsDataPath + "\\" + filename;
        
        int fileHandle = FileOpen(filepath, FILE_WRITE|FILE_CSV|FILE_ANSI, ',');
        if(fileHandle == INVALID_HANDLE) {
            Print("Не удалось создать файл примера");
            return;
        }
        
        // Записываем заголовок
        FileWrite(fileHandle, "DateTime", "Currency", "Title", "Impact", "Forecast", "Previous");
        
        // Примеры новостей
        string baseDate = StringFormat("%04d.%02d.", dt.year, dt.mon);
        
        // NFP (первая пятница месяца)
        FileWrite(fileHandle, baseDate + "01 13:30", "USD", "Non-Farm Employment Change", "3", "200", "185");
        FileWrite(fileHandle, baseDate + "01 13:30", "USD", "Unemployment Rate", "3", "3.7", "3.8");
        
        // ECB Rate Decision (обычно в четверг)
        FileWrite(fileHandle, baseDate + "06 12:45", "EUR", "ECB Interest Rate Decision", "3", "4.5", "4.5");
        FileWrite(fileHandle, baseDate + "06 13:30", "EUR", "ECB Press Conference", "3", "", "0");
        
        // UK GDP
        FileWrite(fileHandle, baseDate + "10 07:00", "GBP", "GDP q/q", "3", "0.3", "0.2");
        FileWrite(fileHandle, baseDate + "10 07:00", "GBP", "Manufacturing Production m/m", "2", "0.2", "0.1");
        
        // Japan CPI
        FileWrite(fileHandle, baseDate + "15 00:30", "JPY", "Core CPI y/y", "2", "2.1", "2.0");
        
        // US CPI
        FileWrite(fileHandle, baseDate + "12 13:30", "USD", "Core CPI m/m", "3", "0.3", "0.2");
        FileWrite(fileHandle, baseDate + "12 13:30", "USD", "CPI y/y", "3", "3.2", "3.1");
        
        // NZD Retail Sales
        FileWrite(fileHandle, baseDate + "20 22:45", "NZD", "Retail Sales q/q", "2", "0.8", "0.7");
        
        FileClose(fileHandle);
        
        Print("Создан файл примера новостей: ", filepath);
    }
};

CTesterNewsManager testerNewsManager;

//+------------------------------------------------------------------+
//| News Panel Class
//+------------------------------------------------------------------+
class CNewsPanel {
private:
    int panelX;
    int panelY;
    int panelWidth;
    int panelHeight;
    color backgroundColor;
    color textColor;
    int fontSize;
    bool isVisible;
    
public:
    CNewsPanel() {
        panelX = 10;
        panelY = 50;
        panelWidth = 500;
        panelHeight = 180;
        backgroundColor = clrBlack;
        textColor = clrWhite;
        fontSize = 8;
        isVisible = false;
    }
    
    void SetPosition(int x, int y) {
        panelX = x;
        panelY = y;
    }
    
    void SetColors(color bgColor, color txtColor) {
        backgroundColor = bgColor;
        textColor = txtColor;
    }
    
    void SetWidth(int width) {
        panelWidth = width;
    }
    
    void SetFontSize(int size) {
        fontSize = size;
    }
    
    void Create() {
        if(isVisible) return;
        
        // Рассчитываем высоту панели в зависимости от количества новостей
        int newsCount = MathMin(PanelNewsCount, 10);
        panelHeight = 80 + (newsCount * 25);
        
        // Create main panel background
        string panelName = "NewsPanel_Background";
        ObjectCreate(0, panelName, OBJ_RECTANGLE_LABEL, 0, 0, 0);
        ObjectSetInteger(0, panelName, OBJPROP_XDISTANCE, panelX);
        ObjectSetInteger(0, panelName, OBJPROP_YDISTANCE, panelY);
        ObjectSetInteger(0, panelName, OBJPROP_XSIZE, panelWidth);
        ObjectSetInteger(0, panelName, OBJPROP_YSIZE, panelHeight);
        ObjectSetInteger(0, panelName, OBJPROP_BGCOLOR, backgroundColor);
        ObjectSetInteger(0, panelName, OBJPROP_BORDER_TYPE, BORDER_RAISED);
        ObjectSetInteger(0, panelName, OBJPROP_COLOR, clrGray);
        ObjectSetInteger(0, panelName, OBJPROP_STYLE, STYLE_SOLID);
        ObjectSetInteger(0, panelName, OBJPROP_WIDTH, 2);
        ObjectSetInteger(0, panelName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
        ObjectSetInteger(0, panelName, OBJPROP_BACK, false);
        
        // Create header
        string headerName = "NewsPanel_Header";
        ObjectCreate(0, headerName, OBJ_LABEL, 0, 0, 0);
        ObjectSetInteger(0, headerName, OBJPROP_XDISTANCE, panelX + 10);
        ObjectSetInteger(0, headerName, OBJPROP_YDISTANCE, panelY + 5);
        ObjectSetString(0, headerName, OBJPROP_TEXT, "БЛИЖАЙШИЕ НОВОСТИ FOREXFACTORY");
        ObjectSetString(0, headerName, OBJPROP_FONT, "Arial Bold");
        ObjectSetInteger(0, headerName, OBJPROP_FONTSIZE, 10);
        ObjectSetInteger(0, headerName, OBJPROP_COLOR, textColor);
        ObjectSetInteger(0, headerName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
        
        // Create separator line
        string separatorName = "NewsPanel_Separator";
        ObjectCreate(0, separatorName, OBJ_RECTANGLE_LABEL, 0, 0, 0);
        ObjectSetInteger(0, separatorName, OBJPROP_XDISTANCE, panelX + 5);
        ObjectSetInteger(0, separatorName, OBJPROP_YDISTANCE, panelY + 22);
        ObjectSetInteger(0, separatorName, OBJPROP_XSIZE, panelWidth - 10);
        ObjectSetInteger(0, separatorName, OBJPROP_YSIZE, 1);
        ObjectSetInteger(0, separatorName, OBJPROP_BGCOLOR, clrGray);
        ObjectSetInteger(0, separatorName, OBJPROP_BORDER_TYPE, BORDER_FLAT);
        ObjectSetInteger(0, separatorName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
        ObjectSetInteger(0, separatorName, OBJPROP_BACK, false);
        
        // Create column headers
        CreateColumnHeader("NewsPanel_ColTime", panelX + 10, panelY + 28, "ВРЕМЯ");
        CreateColumnHeader("NewsPanel_ColCurrency", panelX + 100, panelY + 28, "ВАЛЮТА");
        CreateColumnHeader("NewsPanel_ColImpact", panelX + 155, panelY + 28, "ВАЖН.");
        CreateColumnHeader("NewsPanel_ColEvent", panelX + 205, panelY + 28, "СОБЫТИЕ");
        CreateColumnHeader("NewsPanel_ColForecast", panelX + 350, panelY + 28, "ПРОГН.");
        CreateColumnHeader("NewsPanel_ColActual", panelX + 400, panelY + 28, "ФАКТ");
        
        // Create refresh button
        string refreshButton = "NewsPanel_RefreshBtn";
        ObjectCreate(0, refreshButton, OBJ_BUTTON, 0, 0, 0);
        ObjectSetInteger(0, refreshButton, OBJPROP_XDISTANCE, panelX + panelWidth - 50);
        ObjectSetInteger(0, refreshButton, OBJPROP_YDISTANCE, panelY + 3);
        ObjectSetInteger(0, refreshButton, OBJPROP_XSIZE, 30);
        ObjectSetInteger(0, refreshButton, OBJPROP_YSIZE, 15);
        ObjectSetString(0, refreshButton, OBJPROP_TEXT, "⟳");
        ObjectSetString(0, refreshButton, OBJPROP_FONT, "Arial");
        ObjectSetInteger(0, refreshButton, OBJPROP_FONTSIZE, 10);
        ObjectSetInteger(0, refreshButton, OBJPROP_COLOR, clrWhite);
        ObjectSetInteger(0, refreshButton, OBJPROP_BGCOLOR, clrDarkGray);
        ObjectSetInteger(0, refreshButton, OBJPROP_BORDER_COLOR, clrGray);
        ObjectSetInteger(0, refreshButton, OBJPROP_CORNER, CORNER_LEFT_UPPER);
        
        // Create last update time label
        string updateTimeName = "NewsPanel_UpdateTime";
        ObjectCreate(0, updateTimeName, OBJ_LABEL, 0, 0, 0);
        ObjectSetInteger(0, updateTimeName, OBJPROP_XDISTANCE, panelX + 10);
        ObjectSetInteger(0, updateTimeName, OBJPROP_YDISTANCE, panelY + panelHeight - 18);
        ObjectSetString(0, updateTimeName, OBJPROP_TEXT, "Последнее обновление: ---");
        ObjectSetString(0, updateTimeName, OBJPROP_FONT, "Arial");
        ObjectSetInteger(0, updateTimeName, OBJPROP_FONTSIZE, 7);
        ObjectSetInteger(0, updateTimeName, OBJPROP_COLOR, clrGray);
        ObjectSetInteger(0, updateTimeName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
        
        isVisible = true;
    }
    
    void Update(NewsEvent &newsArray[], int totalNews, datetime lastUpdate, int newsMinutesBefore) {
        if(!isVisible) return;
        
        // Update header with count
        string headerName = "NewsPanel_Header";
        string statusIcon = "●";
        color statusColor = totalNews > 0 ? clrLime : clrRed;
        
        // Create/update status indicator
        string statusName = "NewsPanel_Status";
        if(ObjectFind(0, statusName) < 0) {
            ObjectCreate(0, statusName, OBJ_LABEL, 0, 0, 0);
            ObjectSetInteger(0, statusName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
        }
        ObjectSetInteger(0, statusName, OBJPROP_XDISTANCE, panelX + panelWidth - 15);
        ObjectSetInteger(0, statusName, OBJPROP_YDISTANCE, panelY + 5);
        ObjectSetString(0, statusName, OBJPROP_TEXT, statusIcon);
        ObjectSetString(0, statusName, OBJPROP_FONT, "Arial");
        ObjectSetInteger(0, statusName, OBJPROP_FONTSIZE, 10);
        ObjectSetInteger(0, statusName, OBJPROP_COLOR, statusColor);
        
        string headerText = StringFormat("БЛИЖАЙШИЕ НОВОСТИ %s (Всего: %d)", 
                                       isTesting ? "ТЕСТЕР" : "FOREXFACTORY", totalNews);
        ObjectSetString(0, headerName, OBJPROP_TEXT, headerText);
        
        // Update last update time
        string updateTimeName = "NewsPanel_UpdateTime";
        if(lastUpdate > 0) {
            string updateText = StringFormat("Последнее обновление: %s (GMT%+d)", 
                                           TimeToString(lastUpdate, TIME_DATE|TIME_MINUTES),
                                           brokerGMTOffset);
            ObjectSetString(0, updateTimeName, OBJPROP_TEXT, updateText);
        }
        
        // Get upcoming news (max 5)
        NewsEvent upcomingNews[];
        int maxNewsCount = MathMin(PanelNewsCount, 10);
        int upcomingCount = GetUpcomingNews(newsArray, upcomingNews, maxNewsCount);
        
        // Update rows
        int rowHeight = 25;
        int startY = panelY + 45;
        
        for(int i = 0; i < maxNewsCount; i++) {
            string rowPrefix = "NewsPanel_Row" + IntegerToString(i);
            int currentY = startY + (i * rowHeight);
            
            if(i < upcomingCount) {
                // Calculate minutes to news
                int minutesToNews = (int)((upcomingNews[i].time - TimeCurrent()) / 60);
                
                // Time with countdown
                string timeDisplay = TimeToString(upcomingNews[i].time, TIME_DATE|TIME_MINUTES);
                if(minutesToNews >= 0 && minutesToNews < 1440) {
                    timeDisplay = StringFormat("%s (%d м)", TimeToString(upcomingNews[i].time, TIME_MINUTES), minutesToNews);
                }
                UpdateNewsCell(rowPrefix + "_Time", panelX + 10, currentY, 
                              timeDisplay, textColor, fontSize);
                
                // Currency
                UpdateNewsCell(rowPrefix + "_Currency", panelX + 100, currentY, 
                              upcomingNews[i].currency, clrCyan, fontSize + 1);
                
                // Impact
                string impact = "";
                color impactColor = clrGray;
                switch(upcomingNews[i].impact) {
                    case 3: impact = "HIGH"; impactColor = clrRed; break;
                    case 2: impact = "MED"; impactColor = clrOrange; break;
                    case 1: impact = "LOW"; impactColor = clrYellow; break;
                    default: impact = "---"; impactColor = clrGray; break;
                }
                UpdateNewsCell(rowPrefix + "_Impact", panelX + 155, currentY, 
                              impact, impactColor, fontSize);
                
                // Event title
                string title = upcomingNews[i].title;
                if(StringLen(title) > 20) {
                    title = StringSubstr(title, 0, 17) + "...";
                }
                UpdateNewsCell(rowPrefix + "_Event", panelX + 205, currentY, 
                              title, textColor, fontSize);
                
                // Forecast
                string forecast = upcomingNews[i].hasForecast ? DoubleToString(upcomingNews[i].forecast, 2) : "---";
                UpdateNewsCell(rowPrefix + "_Forecast", panelX + 350, currentY, 
                              forecast, clrLightBlue, fontSize);
                
                // Actual
                string actual = upcomingNews[i].actual != 0 ? DoubleToString(upcomingNews[i].actual, 2) : "---";
                color actualColor = clrGray;
                if(upcomingNews[i].actual != 0 && upcomingNews[i].hasForecast) {
                    actualColor = upcomingNews[i].actual > upcomingNews[i].forecast ? clrLime : clrRed;
                }
                UpdateNewsCell(rowPrefix + "_Actual", panelX + 400, currentY, 
                              actual, actualColor, fontSize);
                
                // Highlight if news is coming soon
                UpdateHighlight(rowPrefix, currentY, minutesToNews, newsMinutesBefore);
            } else {
                // Clear row
                UpdateNewsCell(rowPrefix + "_Time", panelX + 10, currentY, "---", clrGray, fontSize);
                UpdateNewsCell(rowPrefix + "_Currency", panelX + 100, currentY, "---", clrGray, fontSize);
                UpdateNewsCell(rowPrefix + "_Impact", panelX + 155, currentY, "---", clrGray, fontSize);
                UpdateNewsCell(rowPrefix + "_Event", panelX + 205, currentY, "---", clrGray, fontSize);
                UpdateNewsCell(rowPrefix + "_Forecast", panelX + 350, currentY, "---", clrGray, fontSize);
                UpdateNewsCell(rowPrefix + "_Actual", panelX + 400, currentY, "---", clrGray, fontSize);
                
                // Remove highlight
                string highlightName = rowPrefix + "_Highlight";
                if(ObjectFind(0, highlightName) >= 0) {
                    ObjectDelete(0, highlightName);
                }
            }
        }
    }
    
    void Delete() {
        ObjectDelete(0, "NewsPanel_Background");
        ObjectDelete(0, "NewsPanel_Header");
        ObjectDelete(0, "NewsPanel_Status");
        ObjectDelete(0, "NewsPanel_RefreshBtn");
        ObjectDelete(0, "NewsPanel_Separator");
        ObjectDelete(0, "NewsPanel_UpdateTime");
        ObjectDelete(0, "NewsPanel_ColTime");
        ObjectDelete(0, "NewsPanel_ColCurrency");
        ObjectDelete(0, "NewsPanel_ColImpact");
        ObjectDelete(0, "NewsPanel_ColEvent");
        ObjectDelete(0, "NewsPanel_ColForecast");
        ObjectDelete(0, "NewsPanel_ColActual");
        
        for(int i = 0; i < 10; i++) {
            string rowPrefix = "NewsPanel_Row" + IntegerToString(i);
            ObjectDelete(0, rowPrefix + "_Time");
            ObjectDelete(0, rowPrefix + "_Currency");
            ObjectDelete(0, rowPrefix + "_Impact");
            ObjectDelete(0, rowPrefix + "_Event");
            ObjectDelete(0, rowPrefix + "_Forecast");
            ObjectDelete(0, rowPrefix + "_Actual");
            ObjectDelete(0, rowPrefix + "_Highlight");
        }
        
        isVisible = false;
    }
    
    bool IsRefreshClicked(string sparam) {
        return (sparam == "NewsPanel_RefreshBtn");
    }
    
private:
    void CreateColumnHeader(string name, int x, int y, string text) {
        ObjectCreate(0, name, OBJ_LABEL, 0, 0, 0);
        ObjectSetInteger(0, name, OBJPROP_XDISTANCE, x);
        ObjectSetInteger(0, name, OBJPROP_YDISTANCE, y);
        ObjectSetString(0, name, OBJPROP_TEXT, text);
        ObjectSetString(0, name, OBJPROP_FONT, "Arial");
        ObjectSetInteger(0, name, OBJPROP_FONTSIZE, fontSize);
        ObjectSetInteger(0, name, OBJPROP_COLOR, clrYellow);
        ObjectSetInteger(0, name, OBJPROP_CORNER, CORNER_LEFT_UPPER);
    }
    
    void UpdateNewsCell(string name, int x, int y, string text, color cellColor, int cellFontSize) {
        if(ObjectFind(0, name) < 0) {
            ObjectCreate(0, name, OBJ_LABEL, 0, 0, 0);
        }
        ObjectSetInteger(0, name, OBJPROP_XDISTANCE, x);
        ObjectSetInteger(0, name, OBJPROP_YDISTANCE, y);
        ObjectSetString(0, name, OBJPROP_TEXT, text);
        ObjectSetString(0, name, OBJPROP_FONT, "Arial");
        ObjectSetInteger(0, name, OBJPROP_FONTSIZE, cellFontSize > 0 ? cellFontSize : fontSize);
        ObjectSetInteger(0, name, OBJPROP_COLOR, cellColor);
        ObjectSetInteger(0, name, OBJPROP_CORNER, CORNER_LEFT_UPPER);
    }
    
    void UpdateHighlight(string rowPrefix, int y, int minutesToNews, int newsMinutesBefore) {
        string highlightName = rowPrefix + "_Highlight";
        
        if(minutesToNews <= newsMinutesBefore && minutesToNews >= 0) {
            if(ObjectFind(0, highlightName) < 0) {
                ObjectCreate(0, highlightName, OBJ_RECTANGLE_LABEL, 0, 0, 0);
                ObjectSetInteger(0, highlightName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
                ObjectSetInteger(0, highlightName, OBJPROP_BACK, true);
            }
            
            ObjectSetInteger(0, highlightName, OBJPROP_XDISTANCE, panelX + 5);
            ObjectSetInteger(0, highlightName, OBJPROP_YDISTANCE, y - 2);
            ObjectSetInteger(0, highlightName, OBJPROP_XSIZE, panelWidth - 10);
            ObjectSetInteger(0, highlightName, OBJPROP_YSIZE, 20);
            
            // Blinking effect for urgent news
            if(minutesToNews <= 5) {
                int seconds = (int)(TimeCurrent() % 2);
                ObjectSetInteger(0, highlightName, OBJPROP_BGCOLOR, seconds == 0 ? clrDarkRed : clrDarkGreen);
            } else {
                ObjectSetInteger(0, highlightName, OBJPROP_BGCOLOR, clrDarkGreen);
            }
            
            ObjectSetInteger(0, highlightName, OBJPROP_BORDER_TYPE, BORDER_FLAT);
        } else {
            if(ObjectFind(0, highlightName) >= 0) {
                ObjectDelete(0, highlightName);
            }
        }
    }
    
    int GetUpcomingNews(NewsEvent &allNews[], NewsEvent &result[], int maxCount) {
        ArrayResize(result, 0);
        datetime current = TimeCurrent();
        int count = 0;
        
        // Сначала добавляем новости, которые еще не вышли
        for(int i = 0; i < ArraySize(allNews) && count < maxCount; i++) {
            if(allNews[i].time >= current) {
                // Проверяем релевантность через глобальный указатель
                if(newsManagerPtr != NULL && newsManagerPtr.IsCurrencyRelevant(allNews[i].currency)) {
                    ArrayResize(result, count + 1);
                    result[count] = allNews[i];
                    count++;
                }
            }
        }
        
        // Если есть место, добавляем недавние новости за NewsHistoryHours часов
        if(count < maxCount) {
            for(int i = ArraySize(allNews) - 1; i >= 0 && count < maxCount; i--) {
                if(allNews[i].time < current && 
                   allNews[i].time >= current - (NewsHistoryHours * 3600)) {
                    if(newsManagerPtr != NULL && newsManagerPtr.IsCurrencyRelevant(allNews[i].currency)) {
                        // Проверяем, не добавили ли мы уже эту новость
                        bool alreadyAdded = false;
                        for(int j = 0; j < count; j++) {
                            if(result[j].time == allNews[i].time && 
                               result[j].currency == allNews[i].currency &&
                               result[j].title == allNews[i].title) {
                                alreadyAdded = true;
                                break;
                            }
                        }
                        
                        if(!alreadyAdded) {
                            ArrayResize(result, count + 1);
                            result[count] = allNews[i];
                            count++;
                        }
                    }
                }
            }
        }
        
        return count;
    }
};

// Global news panel object
CNewsPanel newsPanel;

//+------------------------------------------------------------------+
//| ForexFactory Parser Class (ИСПРАВЛЕННАЯ)
//+------------------------------------------------------------------+
class CForexFactoryParser {
private:
    string apiUrl;
    int timeout;
    datetime lastProcessedTime;
    
public:
    CForexFactoryParser() {
        apiUrl = ForexFactoryURL;
        timeout = WebRequestTimeout;
        lastProcessedTime = 0;
    }
    
    bool ParseForexFactoryNews(NewsEvent &newsArray[]) {
        string cookie = NULL;
        string referer = NULL;
        char post[];
        char result[];
        string headers;
        
        string requestUrl;
        
        if(LoadTodayOnly) {
            MqlDateTime dt;
            TimeToStruct(TimeCurrent(), dt);
            string dateStr = StringFormat("%s+%d%%2C+%d", GetMonthName(dt.mon), dt.day, dt.year);
            requestUrl = apiUrl + "?day=" + dateStr;
        } else {
            requestUrl = apiUrl + "?week=this";
        }
        
        Print("Запрос новостей ForexFactory: ", requestUrl);
        
        // Добавляем заголовки для имитации браузера
        headers = "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36\r\n";
        headers += "Accept: text/html,application/xhtml+xml\r\n";
        headers += "Accept-Language: en-US,en;q=0.9\r\n";
        
        int res = WebRequest("GET", requestUrl, headers, timeout, post, result, headers);
        
        if(res == -1) {
            int error = GetLastError();
            Print("Ошибка WebRequest. Код ошибки = ", error);
            if(error == 4014) {
                Print("ВАЖНО: Добавьте 'https://www.forexfactory.com' в список разрешенных URL!");
                Print("Сервис -> Настройки -> Советники -> Разрешить WebRequest");
            }
            return false;
        }
        
        string html = CharArrayToString(result);
        
        return ParseHTMLContent(html, newsArray);
    }
    
    string GetMonthName(int month) {
        string months[] = {"", "jan", "feb", "mar", "apr", "may", "jun", 
                          "jul", "aug", "sep", "oct", "nov", "dec"};
        if(month >= 1 && month <= 12) {
            return months[month];
        }
        return "";
    }
    
    int GetMonthNumber(string monthStr) {
        string monthLower = monthStr;
        StringToLower(monthLower);
        
        if(monthLower == "jan" || monthLower == "january") return 1;
        if(monthLower == "feb" || monthLower == "february") return 2;
        if(monthLower == "mar" || monthLower == "march") return 3;
        if(monthLower == "apr" || monthLower == "april") return 4;
        if(monthLower == "may") return 5;
        if(monthLower == "jun" || monthLower == "june") return 6;
        if(monthLower == "jul" || monthLower == "july") return 7;
        if(monthLower == "aug" || monthLower == "august") return 8;
        if(monthLower == "sep" || monthLower == "september") return 9;
        if(monthLower == "oct" || monthLower == "october") return 10;
        if(monthLower == "nov" || monthLower == "november") return 11;
        if(monthLower == "dec" || monthLower == "december") return 12;
        
        return 0;
    }
    
    bool ParseHTMLContent(string html, NewsEvent &newsArray[]) {
       int newsCount = 0;
       ArrayResize(newsArray, 0);
       
       // Find calendar table
       int tableStart = StringFind(html, "calendar__table");
       if(tableStart == -1) {
           return false;
       }
       
       // Текущая дата для новостей
       datetime currentDate = 0;
       lastProcessedTime = 0;  // Сброс времени последней обработки
       
       // Parse each row
       int pos = tableStart;
       while(pos < StringLen(html) && newsCount < 500) {
           // Ищем любую строку календаря
           int rowStart = StringFind(html, "<tr", pos);
           if(rowStart == -1) break;
           
           int rowEnd = StringFind(html, "</tr>", rowStart);
           if(rowEnd == -1) break;
           
           string row = StringSubstr(html, rowStart, rowEnd - rowStart);
           
           // Проверяем, является ли это строкой с датой
           if(StringFind(row, "calendar__date") >= 0 && StringFind(row, "calendar__row") >= 0) {
               // Извлекаем дату из строки
               datetime parsedDate = ExtractDateFromRow(row);
               if(parsedDate > 0) {
                   currentDate = parsedDate;
                   lastProcessedTime = 0;  // Сброс времени для новой даты
               }
           }
           // Проверяем, является ли это строкой с новостью
           else if(StringFind(row, "calendar__time") >= 0) {
               ParseNewsRow(row, newsArray, newsCount, currentDate);
           }
           
           pos = rowEnd;
       }
       
       return newsCount > 0;
   }
   
   void ParseNewsRow(string row, NewsEvent &newsArray[], int &count, datetime baseDate) {
       NewsEvent baseNews;
       
       // Extract time - ИСПРАВЛЕНИЕ для новостей без времени
       string time = ExtractData(row, "calendar__time", "</td>");
       datetime newsTime = 0;
       
       if(time == "" || StringFind(time, "nbsp") >= 0 || StringLen(CleanHTML(time)) == 0) {
           // Если время пустое, используем время предыдущей новости
           if(lastProcessedTime > 0) {
               newsTime = lastProcessedTime;
           } else {
               return;  // Если нет времени и нет предыдущего времени, пропускаем
           }
       } else {
           // Парсим время
           newsTime = CombineDateAndTime(baseDate, time);
           if(newsTime > 0) {
               lastProcessedTime = newsTime;  // Сохраняем для следующих новостей
           }
       }
       
       if(newsTime == 0) return;
       
       // Корректируем время с учетом GMT смещения
       int totalOffset = brokerGMTOffset - GMTOffset;
       newsTime = newsTime + totalOffset * 3600;
       
       // Extract currency - может быть множественная
       string currencyStr = ExtractData(row, "calendar__currency", "</td>");
       StringTrimLeft(currencyStr);
       StringTrimRight(currencyStr);
       
       // Extract impact
       baseNews.impact = 0;
       int impactStart = StringFind(row, "calendar__impact");
       if(impactStart >= 0) {
           int impactEnd = StringFind(row, "</td>", impactStart);
           if(impactEnd > impactStart) {
               string impactSection = StringSubstr(row, impactStart, impactEnd - impactStart);
               
               int iconCount = 0;
               int spanPos = 0;
               
               while(true) {
                   spanPos = StringFind(impactSection, "<span", spanPos);
                   if(spanPos == -1) break;
                   
                   int spanEnd = StringFind(impactSection, ">", spanPos);
                   if(spanEnd > spanPos) {
                       string spanTag = StringSubstr(impactSection, spanPos, spanEnd - spanPos);
                       
                       if(StringFind(spanTag, "icon--ff-impact-red") >= 0 || 
                          StringFind(spanTag, "high") >= 0) {
                           iconCount = 3;
                           break;
                       }
                       else if(StringFind(spanTag, "icon--ff-impact-ora") >= 0 || 
                               StringFind(spanTag, "icon--ff-impact-orange") >= 0 ||
                               StringFind(spanTag, "medium") >= 0) {
                           iconCount = 2;
                       }
                       else if(StringFind(spanTag, "icon--ff-impact-yel") >= 0 || 
                               StringFind(spanTag, "icon--ff-impact-yellow") >= 0 ||
                               StringFind(spanTag, "low") >= 0) {
                           if(iconCount < 1) iconCount = 1;
                       }
                   }
                   spanPos = spanEnd + 1;
               }
               
               baseNews.impact = iconCount;
           }
       }
       
       // Extract event title
       string title = ExtractData(row, "calendar__event", "</span>");
       if(title == "") {
           title = ExtractData(row, "calendar__event", "</td>");
       }
       baseNews.title = CleanHTML(title);
       
       // Extract forecast/actual values
       string forecast = ExtractData(row, "calendar__forecast", "</td>");
       string actual = ExtractData(row, "calendar__actual", "</td>");
       
       if(forecast != "" && forecast != "---") {
           baseNews.forecast = ParseNumericValue(forecast);
           baseNews.hasForecast = true;
       } else {
           baseNews.forecast = 0;
           baseNews.hasForecast = false;
       }
       
       baseNews.actual = ParseNumericValue(actual);
       baseNews.processed = false;
       baseNews.actualReleased = false;
       
       baseNews.time = newsTime;
       
       if(baseNews.time == 0) return;
       
       // Разбираем множественные валюты
       string currencies[];
       if(StringFind(currencyStr, ",") >= 0) {
           StringSplit(currencyStr, ',', currencies);
       } else {
           ArrayResize(currencies, 1);
           currencies[0] = currencyStr;
       }
       
       // Создаем отдельную новость для каждой валюты
       for(int i = 0; i < ArraySize(currencies); i++) {
           NewsEvent news = baseNews;
           
           string currency = currencies[i];
           StringTrimLeft(currency);
           StringTrimRight(currency);
           news.currency = currency;
           
           if(news.currency != "" && IsDateRelevant(news.time)) {
               ArrayResize(newsArray, count + 1);
               newsArray[count] = news;
               count++;
           }
       }
   }

datetime ExtractDateFromRow(string row) {
       // Ищем тег с датой
       int dateStart = StringFind(row, "calendar__date");
       if(dateStart == -1) return 0;
       
       // Ищем конец тега
       int contentStart = StringFind(row, ">", dateStart);
       if(contentStart == -1) return 0;
       
       int contentEnd = StringFind(row, "</", contentStart);
       if(contentEnd == -1) return 0;
       
       string dateText = StringSubstr(row, contentStart + 1, contentEnd - contentStart - 1);
       dateText = CleanHTML(dateText);
       
       return ParseFullDate(dateText);
   }
   
   bool IsDateRelevant(datetime newsTime) {
       if(newsTime == 0) return false;
       
       datetime current = TimeCurrent();
       
       // Если загружаем только сегодняшние новости
       if(LoadTodayOnly) {
           MqlDateTime currentDt, newsDt;
           TimeToStruct(current, currentDt);
           TimeToStruct(newsTime, newsDt);
           
           // Проверяем, что новость за сегодня
           if(currentDt.year != newsDt.year || 
              currentDt.mon != newsDt.mon || 
              currentDt.day != newsDt.day) {
               // Исключение: прошедшие новости за последние NewsHistoryHours часов
               if(newsTime >= current - (NewsHistoryHours * 3600)) {
                   return true;
               }
               return false;
           }
       }
       
       // Фильтруем слишком старые новости (более недели назад)
       if(newsTime < current - 7 * 24 * 3600) {
           return false;
       }
       
       return true;
   }
   
   datetime ParseFullDate(string dateStr) {
       // Парсим полную дату формата "Mon Nov 4" или "Today"
       StringTrimLeft(dateStr);
       StringTrimRight(dateStr);
       
       if(dateStr == "" || dateStr == "---") return 0;
       
       MqlDateTime dt;
       TimeToStruct(TimeCurrent(), dt);
       
       // Проверяем специальные случаи
       if(StringFind(dateStr, "Today") >= 0) {
           // Сегодня
           dt.hour = 0;
           dt.min = 0;
           dt.sec = 0;
           return StructToTime(dt);
       }
       
       if(StringFind(dateStr, "Tomorrow") >= 0) {
           // Завтра
           datetime tomorrow = TimeCurrent() + 86400;
           TimeToStruct(tomorrow, dt);
           dt.hour = 0;
           dt.min = 0;
           dt.sec = 0;
           return StructToTime(dt);
       }
       
       if(StringFind(dateStr, "Yesterday") >= 0) {
           // Вчера
           datetime yesterday = TimeCurrent() - 86400;
           TimeToStruct(yesterday, dt);
           dt.hour = 0;
           dt.min = 0;
           dt.sec = 0;
           return StructToTime(dt);
       }
       
       // Парсим обычную дату (например, "Tue Aug 19")
       string parts[];
       StringSplit(dateStr, ' ', parts);
       
       if(ArraySize(parts) >= 2) {
           // Пропускаем день недели, если он есть
           int monthIndex = 0;
           int dayIndex = 1;
           
           // Проверяем, является ли первая часть днем недели
           string firstPart = parts[0];
           StringToLower(firstPart);
           if(firstPart == "mon" || firstPart == "tue" || firstPart == "wed" || 
              firstPart == "thu" || firstPart == "fri" || firstPart == "sat" || firstPart == "sun") {
               monthIndex = 1;
               dayIndex = 2;
           }
           
           if(ArraySize(parts) > monthIndex) {
               // Месяц
               dt.mon = GetMonthNumber(parts[monthIndex]);
               
               // День
               if(ArraySize(parts) > dayIndex) {
                   dt.day = (int)StringToInteger(parts[dayIndex]);
               }
               
               // Год - берем текущий год, но корректируем если нужно
               dt.year = dt.year;
               
               // Проверка на переход года
               // Если текущий месяц январь, а новость в декабре - это прошлый год
               MqlDateTime currentDt;
               TimeToStruct(TimeCurrent(), currentDt);
               
               if(currentDt.mon == 1 && dt.mon == 12) {
                   dt.year = currentDt.year - 1;
               }
               // Если текущий месяц декабрь, а новость в январе - это следующий год
               else if(currentDt.mon == 12 && dt.mon == 1) {
                   dt.year = currentDt.year + 1;
               }
               // Если текущий месяц август, а новость в январе - возможно следующий год
               else if(currentDt.mon >= 8 && dt.mon <= 2) {
                   dt.year = currentDt.year + 1;
               }
               
               // Время обнуляем
               dt.hour = 0;
               dt.min = 0;
               dt.sec = 0;
               
               return StructToTime(dt);
           }
       }
       
       return 0;
   }
    
    datetime ParseForexFactoryDate(string dateStr) {
        return ParseFullDate(dateStr);
    }
    
    datetime CombineDateAndTime(datetime date, string timeStr) {
        if(date == 0) return 0;
        
        MqlDateTime dt;
        TimeToStruct(date, dt);
        
        // Парсим время
        string clean = timeStr;
        StringTrimLeft(clean);
        StringTrimRight(clean);
        
        if(clean == "" || clean == "---" || clean == "All Day") {
            // Для событий "All Day" устанавливаем время 00:00
            dt.hour = 0;
            dt.min = 0;
            dt.sec = 0;
            return StructToTime(dt);
        }
        
        // Убираем лишние пробелы и теги
        clean = CleanHTML(clean);
        
        int colonPos = StringFind(clean, ":");
        if(colonPos == -1) return date;
        
        int hour = (int)StringToInteger(StringSubstr(clean, 0, colonPos));
        int minute = (int)StringToInteger(StringSubstr(clean, colonPos + 1, 2));
        
        // Проверяем AM/PM
        StringToLower(clean);
        if(StringFind(clean, "pm") >= 0 && hour != 12) hour += 12;
        if(StringFind(clean, "am") >= 0 && hour == 12) hour = 0;
        
        dt.hour = hour;
        dt.min = minute;
        dt.sec = 0;
        
        return StructToTime(dt);
    }
    
    string ExtractData(string source, string startMarker, string endMarker) {
        int start = StringFind(source, startMarker);
        if(start == -1) return "";
        
        start = StringFind(source, ">", start) + 1;
        if(start == 0) return "";
        
        int end = StringFind(source, endMarker, start);
        if(end == -1) return "";
        
        return StringSubstr(source, start, end - start);
    }
    
    string CleanHTML(string html) {
        string clean = html;
        
        // Удаляем HTML теги
        while(true) {
            int tagStart = StringFind(clean, "<");
            if(tagStart == -1) break;
            
            int tagEnd = StringFind(clean, ">", tagStart);
            if(tagEnd == -1) break;
            
            clean = StringSubstr(clean, 0, tagStart) + 
                   StringSubstr(clean, tagEnd + 1);
        }
        
        // Заменяем HTML entities
        StringReplace(clean, "&nbsp;", " ");
        StringReplace(clean, "&amp;", "&");
        StringReplace(clean, "&lt;", "<");
        StringReplace(clean, "&gt;", ">");
        StringReplace(clean, "&quot;", "\"");
        
        // Удаляем лишние пробелы
        while(StringFind(clean, "  ") >= 0) {
            StringReplace(clean, "  ", " ");
        }
        
        StringTrimLeft(clean);
        StringTrimRight(clean);
        
        return clean;
    }
    
    double ParseNumericValue(string value) {
        string clean = value;
        clean = CleanHTML(clean);
        
        // Обрабатываем специальные случаи
        if(StringFind(clean, "<") >= 0) {
            // Значение типа "<0.2%" -> 0.2
            int pos = StringFind(clean, "<");
            clean = StringSubstr(clean, pos + 1);
        }
        
        string result = "";
        bool hasDecimal = false;
        
        for(int i = 0; i < StringLen(clean); i++) {
            ushort ch = StringGetCharacter(clean, i);
            if((ch >= '0' && ch <= '9') || ch == '-') {
                result += CharToString((uchar)ch);
            }
            else if(ch == '.' && !hasDecimal) {
                result += CharToString((uchar)ch);
                hasDecimal = true;
            }
        }
        
        if(result == "") return 0;
        return StringToDouble(result);
    }
    
    datetime ParseForexFactoryTime(string timeStr, string dateStr = "") {
        string clean = timeStr;
        StringTrimLeft(clean);
        StringTrimRight(clean);
        if(clean == "" || clean == "---") return 0;
        
        MqlDateTime dt;
        TimeToStruct(TimeCurrent(), dt);
        
        // Если передана дата, пытаемся её распарсить
        if(dateStr != "") {
            datetime parsedDate = ParseForexFactoryDate(dateStr);
            if(parsedDate > 0) {
                TimeToStruct(parsedDate, dt);
            }
        }
        
        // Обработка "All Day" событий
        if(StringFind(clean, "All Day") >= 0) {
            dt.hour = 0;
            dt.min = 0;
            dt.sec = 0;
            return StructToTime(dt);
        }
        
        // Парсим время
        clean = CleanHTML(clean);
        int colonPos = StringFind(clean, ":");
        if(colonPos == -1) return 0;
        
        int hour = (int)StringToInteger(StringSubstr(clean, 0, colonPos));
        int minute = (int)StringToInteger(StringSubstr(clean, colonPos + 1, 2));
        
        // Проверяем AM/PM
        StringToLower(clean);
        if(StringFind(clean, "pm") >= 0 && hour != 12) hour += 12;
        if(StringFind(clean, "am") >= 0 && hour == 12) hour = 0;
        
        dt.hour = hour;
        dt.min = minute;
        dt.sec = 0;
        
        return StructToTime(dt);
    }
};

CForexFactoryParser ffParser;

//+------------------------------------------------------------------+
//| News Manager Class
//+------------------------------------------------------------------+
class CNewsManager {
private:
    string currencies[];
    string newsKeywords[];
    
public:
    void ParseCurrencies(string currencyList) {
        StringSplit(currencyList, ',', currencies);
        for(int i = 0; i < ArraySize(currencies); i++) {
            string temp = currencies[i];
            StringTrimLeft(temp);
            StringTrimRight(temp);
            currencies[i] = temp;
        }
    }
    
    void ParseKeywords(string keywordList) {
        // ИСПРАВЛЕНИЕ: сначала заменяем экранированные слэши
        StringReplace(keywordList, "\\/", "/");
        
        StringSplit(keywordList, ',', newsKeywords);
        for(int i = 0; i < ArraySize(newsKeywords); i++) {
            string temp = newsKeywords[i];
            StringTrimLeft(temp);
            StringTrimRight(temp);
            StringToUpper(temp);
            newsKeywords[i] = temp;
        }
    }
    
    bool LoadNewsFromForexFactory() {
        // В режиме тестера загружаем из файлов
        if(isTesting) {
            return LoadNewsFromFile();
        }
        
        // В реальном режиме загружаем с ForexFactory
        NewsEvent ffNews[];
        
        if(ffParser.ParseForexFactoryNews(ffNews)) {
            // Фильтруем только актуальные новости
            NewsEvent filteredNews[];
            datetime current = TimeCurrent();
            int filteredCount = 0;
            
            for(int i = 0; i < ArraySize(ffNews); i++) {
                // Берем только будущие новости и новости за последние NewsHistoryHours часов
                if(ffNews[i].time >= current - (NewsHistoryHours * 3600)) {
                    // Проверяем дополнительные фильтры
                    if(IsNewsMatchingFilter(ffNews[i])) {
                        ArrayResize(filteredNews, filteredCount + 1);
                        filteredNews[filteredCount] = ffNews[i];
                        filteredCount++;
                    }
                }
            }
            
            // Заменяем календарь отфильтрованными новостями
            ArrayResize(newsCalendar, ArraySize(filteredNews));
            for(int i = 0; i < ArraySize(filteredNews); i++) {
                newsCalendar[i] = filteredNews[i];
            }
            
            SortNewsByTime();
            lastNewsCheck = TimeCurrent();
            
            return true;
        }
        return false;
    }
    
    bool LoadNewsFromFile() {
        // Проверяем, нужно ли загрузить новый месяц
        MqlDateTime currentDt;
        TimeToStruct(TimeCurrent(), currentDt);
        datetime currentMonth = StringToTime(StringFormat("%04d.%02d.01", currentDt.year, currentDt.mon));
        
        if(currentMonth != lastLoadedMonth) {
            NewsEvent monthNews[];
            
            if(testerNewsManager.LoadNewsForMonth(TimeCurrent(), monthNews)) {
                // Заменяем календарь новостями текущего месяца
                ArrayResize(newsCalendar, ArraySize(monthNews));
                for(int i = 0; i < ArraySize(monthNews); i++) {
                    newsCalendar[i] = monthNews[i];
                }
                
                SortNewsByTime();
                lastLoadedMonth = currentMonth;
                lastNewsCheck = TimeCurrent();
                
                // Применяем фильтры
                FilterNews();
                
                return true;
            }
            return false;
        }
        
        return true; // Месяц уже загружен
    }
    
    void FilterNews() {
        NewsEvent filteredNews[];
        int filteredCount = 0;
        
        for(int i = 0; i < ArraySize(newsCalendar); i++) {
            bool matchesFilter = IsNewsMatchingFilter(newsCalendar[i]);
            bool currencyRelevant = IsCurrencyRelevant(newsCalendar[i].currency);
            
            if(matchesFilter && currencyRelevant) {
                ArrayResize(filteredNews, filteredCount + 1);
                filteredNews[filteredCount] = newsCalendar[i];
                filteredCount++;
            }
        }
        
        // Заменяем календарь отфильтрованными новостями
        ArrayResize(newsCalendar, ArraySize(filteredNews));
        for(int i = 0; i < ArraySize(filteredNews); i++) {
            newsCalendar[i] = filteredNews[i];
        }
    }
    
    void SortNewsByTime() {
        int n = ArraySize(newsCalendar);
        for(int i = 0; i < n-1; i++) {
            for(int j = 0; j < n-i-1; j++) {
                if(newsCalendar[j].time > newsCalendar[j+1].time) {
                    NewsEvent temp = newsCalendar[j];
                    newsCalendar[j] = newsCalendar[j+1];
                    newsCalendar[j+1] = temp;
                }
            }
        }
    }
    
    NewsEvent GetNextHighImpactNews() {
        NewsEvent nextEvent;
        datetime current = TimeCurrent();
        datetime nextTime = 0;
        
        for(int i = 0; i < ArraySize(newsCalendar); i++) {
            if(newsCalendar[i].time > current && 
               newsCalendar[i].impact >= MinNewsImpact &&
               IsCurrencyRelevant(newsCalendar[i].currency) &&
               IsNewsMatchingFilter(newsCalendar[i]) &&
               !newsCalendar[i].processed) {
                
                if(nextTime == 0 || newsCalendar[i].time < nextTime) {
                    nextTime = newsCalendar[i].time;
                    nextEvent = newsCalendar[i];
                }
            }
        }
        return nextEvent;
    }
    
    bool IsCurrencyRelevant(string currency) {
        for(int i = 0; i < ArraySize(currencies); i++) {
            if(currencies[i] == currency) return true;
        }
        return false;
    }
    
    bool IsNewsMatchingFilter(NewsEvent& news) {
        // Проверяем уровень важности
        if(news.impact < MinNewsImpact) {
            return false;
        }
        
        // Если торгуем на всех новостях высокой важности
        if(TradeAllHighImpact && news.impact == 3) {
            return true;
        }
        
        // Проверяем ключевые слова
        string titleUpper = news.title;
        StringToUpper(titleUpper);
        
        // Добавляем специальную проверку для Retail Sales
        if(StringFind(titleUpper, "RETAIL") >= 0 && StringFind(titleUpper, "SALES") >= 0) {
            return true;
        }
        
        // Проверяем каждое ключевое слово
        for(int i = 0; i < ArraySize(newsKeywords); i++) {
            if(newsKeywords[i] == "") continue;
            
            string keyword = newsKeywords[i];
            
            // Проверяем различные варианты написания
            if(StringFind(titleUpper, keyword) >= 0) {
                return true;
            }
            
            // Специальная проверка для m/m, y/y, q/q
            if(keyword == "M/M" && (StringFind(titleUpper, "M/M") >= 0 || StringFind(titleUpper, "MOM") >= 0)) {
                return true;
            }
            if(keyword == "Y/Y" && (StringFind(titleUpper, "Y/Y") >= 0 || StringFind(titleUpper, "YOY") >= 0)) {
                return true;
            }
            if(keyword == "Q/Q" && (StringFind(titleUpper, "Q/Q") >= 0 || StringFind(titleUpper, "QOQ") >= 0)) {
                return true;
            }
            
            // Проверка для частичного совпадения (например, "Employment" найдет "Unemployment")
            if(StringLen(keyword) >= 4 && StringFind(titleUpper, keyword) >= 0) {
                return true;
            }
        }
        
        // Дополнительная проверка для важных индикаторов
        string importantIndicators[] = {
            "PRODUCTION", "MANUFACTURING", "INDUSTRIAL", "INFLATION", 
            "UNEMPLOYMENT", "JOBLESS", "CONSUMER", "HOUSING", "TRADE"
        };
        
        for(int i = 0; i < ArraySize(importantIndicators); i++) {
            if(StringFind(titleUpper, importantIndicators[i]) >= 0) {
                return true;
            }
        }
        
        return false;
    }
    
    bool IsNewsTimeActive(datetime newsTime) {
        datetime current = TimeCurrent();
        int diffMinutes = (int)((current - newsTime) / 60);
        
        bool isActive = false;
        
        // Проверяем, попадает ли время в активный диапазон
        if(diffMinutes >= -NewsMinutesBefore && diffMinutes <= NewsMinutesAfter) {
            isActive = true;
        }
        
        return isActive;
    }
};

CNewsManager newsManager;

//+------------------------------------------------------------------+
//| Alert System
//+------------------------------------------------------------------+
void SendAlert(string message, bool critical = false) {
    string fullMessage = "News Trader: " + message;
    
    Alert(fullMessage);
    
    if(critical && !isTesting) {
        SendNotification(fullMessage);
        SendMail("News Trader Alert", fullMessage);
    }
    
    Print(fullMessage);
}

//+------------------------------------------------------------------+
//| Expert initialization function
//+------------------------------------------------------------------+
int OnInit() {
    // Определяем режим работы
    isTesting = MQLInfoInteger(MQL_TESTER) || TesterMode;
    
    Print("Инициализация News Trader Pro (ForexFactory Edition)...");
    Print("Режим работы: ", isTesting ? "ТЕСТЕР" : "РЕАЛЬНЫЙ");
    
    // Определяем GMT смещение брокера
    if(AutoDetectBrokerGMT) {
        brokerGMTOffset = GetBrokerGMTOffset();
        
        // Проверка разумности значения
        if(brokerGMTOffset < -12 || brokerGMTOffset > 14) {
            Print("Ошибка автоопределения GMT. Используется ручное значение.");
            brokerGMTOffset = ManualBrokerGMT;
        }
    } else {
        brokerGMTOffset = ManualBrokerGMT;
    }
    
    Print("GMT смещение брокера: ", brokerGMTOffset);
    Print("GMT смещение ForexFactory: ", GMTOffset);
    Print("Общая корректировка времени: ", brokerGMTOffset - GMTOffset, " часов");
    
    // В режиме тестера создаем пример файла новостей
    if(isTesting && !FileIsExist(NewsDataPath + "\\sample.csv")) {
        Print("Создание примера файла новостей для тестирования...");
        testerNewsManager.CreateSampleNewsFile();
    }
    
    // Устанавливаем глобальный указатель для панели
    newsManagerPtr = GetPointer(newsManager);
    
    // Устанавливаем магический номер для объекта trade
    trade.SetExpertMagicNumber(MagicNumber);
    trade.SetDeviationInPoints(MaxSlippagePoints);
    
    riskManager.SetRiskLevel(RiskLevel);
    newsManager.ParseCurrencies(NewsCurrencies);
    newsManager.ParseKeywords(NewsFilterKeywords);
    
    StringSplit(TradingPairs, ',', validPairs);
    for(int i = 0; i < ArraySize(validPairs); i++) {
        string temp = validPairs[i];
        StringTrimLeft(temp);
        StringTrimRight(temp);
        validPairs[i] = temp;
    }
    
    atrHandle = iATR(_Symbol, PERIOD_M15, ATRPeriod);
    if(atrHandle == INVALID_HANDLE) {
        Print("Ошибка создания индикатора ATR");
        return INIT_FAILED;
    }
    
    if(UseNewsFilter) {
        if(!newsManager.LoadNewsFromForexFactory()) {
            if(isTesting) {
                Print("Предупреждение: Не удалось загрузить новости для тестирования");
                Print("Убедитесь, что файлы новостей находятся в папке: ", NewsDataPath);
            } else {
                Print("Предупреждение: Не удалось загрузить календарь ForexFactory");
                Print("Проверьте настройки WebRequest!");
            }
        }
    }
    
    // Initialize news panel
    if(ShowNewsPanel && !isTesting) {
        newsPanel.SetPosition(PanelX, PanelY);
        newsPanel.SetColors(PanelBackgroundColor, PanelTextColor);
        newsPanel.SetWidth(PanelWidth);
        newsPanel.SetFontSize(PanelFontSize);
        newsPanel.Create();
        newsPanel.Update(newsCalendar, ArraySize(newsCalendar), lastNewsCheck, NewsMinutesBefore);
    }
    
    EventSetTimer(NewsUpdateMinutes * 60);
    
    Comment("News Trader Pro (FF) активен\n" +
            "Режим: " + (isTesting ? "ТЕСТЕР" : "РЕАЛЬНЫЙ") + "\n" +
            "Стратегия: " + EnumToString(TradingStrategy) + "\n" +
            "Источник: " + (isTesting ? "Файлы" : "ForexFactory") + "\n" +
            "GMT брокера: " + IntegerToString(brokerGMTOffset) + "\n" +
            "Фильтр новостей: " + (TradeAllHighImpact ? "Все HIGH + " : "") + NewsFilterKeywords + "\n" +
            "Лимиты: " + (LimitOrdersPerNews ? "По новостям (" + IntegerToString(MaxOrdersPerNews) + ")" : "Общие"));
    
    SendAlert("EA запущен. Режим: " + (isTesting ? "ТЕСТЕР" : "РЕАЛЬНЫЙ"));
    
    return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
//| Expert deinitialization function  
//+------------------------------------------------------------------+
void OnDeinit(const int reason) {
    EventKillTimer();
    IndicatorRelease(atrHandle);
    
    // Delete news panel
    if(ShowNewsPanel) {
        newsPanel.Delete();
    }
    
    Comment("");
    Print("News Trader Pro деактивирован");
}

//+------------------------------------------------------------------+
//| Expert tick function
//+------------------------------------------------------------------+
void OnTick() {
    // Обновляем ATR для текущего символа
    double atrBuffer[];
    if(CopyBuffer(atrHandle, 0, 0, 1, atrBuffer) > 0) {
        currentATR = atrBuffer[0];
    }
    
    // В режиме тестера обновляем фактические значения новостей
    if(isTesting) {
        testerNewsManager.UpdateActualsForCurrentTime(newsCalendar);
    }
    
    if(!riskManager.CheckDailyLoss() || !riskManager.CheckConsecutiveLosses()) {
        return;
    }
    
    // Проверяем парные ордера стрэддла на срабатывание
    if(CancelOppositeOrdersOnFill && TradingStrategy == STRATEGY_STRADDLE) {
        CheckAndCancelOppositeOrders();
    }
    
    // Проверяем истечение срока ордеров
    if(UseOrderExpiration) {
        CheckOrderExpiration();
    }
    
    // Очищаем информацию о ценовых уровнях
    CleanupSymbolOrders();
    
    // Очищаем неактивные пуллбэк сетапы
    if(TradingStrategy == STRATEGY_PULLBACK) {
        strategy.CleanupInactiveSetups();
    }
    
    // Обновляем SL/TP по ATR
    UpdatePositionsByATR();
    
    // Обновляем трейлинг стоп
    UpdateTrailingStop();
    
    if(!UseNewsFilter || ArraySize(newsCalendar) == 0) return;
    
    datetime current = TimeCurrent();
    
    // Обрабатываем все новости
    for(int i = 0; i < ArraySize(newsCalendar); i++) {
        // Проверяем активность времени новости
        bool isTimeActive = newsManager.IsNewsTimeActive(newsCalendar[i].time);
        
        // Для фундаментальной стратегии проверяем также выход фактических данных
        if(TradingStrategy == STRATEGY_FUNDAMENTAL && !newsCalendar[i].processed) {
            if(newsCalendar[i].actualReleased && newsCalendar[i].actual != 0) {
                int minutesSinceRelease = (int)((current - newsCalendar[i].time) / 60);
                if(minutesSinceRelease >= 0 && minutesSinceRelease <= NewsMinutesAfter) {
                    isTimeActive = true;
                }
            }
        }
        
        if(!newsCalendar[i].processed && isTimeActive) {
            if(newsManager.IsNewsMatchingFilter(newsCalendar[i]) && 
               newsManager.IsCurrencyRelevant(newsCalendar[i].currency)) {
                
                // Проверяем, есть ли торговые пары для этой валюты
                string tradePairs[];
                GetTradingPairsForCurrency(newsCalendar[i].currency, tradePairs);
                
                if(ArraySize(tradePairs) > 0) {
                    for(int j = 0; j < ArraySize(tradePairs); j++) {
                        string symbol = tradePairs[j];
                        
                        // Обязательно выбираем символ и обновляем его данные
                        if(!SymbolSelect(symbol, true)) {
                            continue;
                        }
                        
                        // Обновляем рыночные данные для символа
                        MqlTick tick;
                        SymbolInfoTick(symbol, tick);
                        
                        // Получаем локальный ATR для символа
                        int localATRHandle = iATR(symbol, PERIOD_M15, ATRPeriod);
                        double localATRBuffer[];
                        double symbolATR = currentATR;
                        
                        if(CopyBuffer(localATRHandle, 0, 0, 1, localATRBuffer) > 0) {
                            symbolATR = localATRBuffer[0];
                            currentATR = symbolATR;
                        }
                        IndicatorRelease(localATRHandle);
                        
                        // Проверяем спред
                        double spread = SymbolInfoInteger(symbol, SYMBOL_SPREAD) * SymbolInfoDouble(symbol, SYMBOL_POINT);
                        double maxSpread = MaxSpreadPoints * SymbolInfoDouble(symbol, SYMBOL_POINT);
                        
                        if(spread > maxSpread) {
                            continue;
                        }
                        
                        switch(TradingStrategy) {
                            case STRATEGY_STRADDLE:
                                strategy.ExecuteStraddleStrategy(symbol, newsCalendar[i]);
                                break;
                            case STRATEGY_BREAKOUT:
                                strategy.ExecuteBreakoutStrategy(symbol, newsCalendar[i]);
                                break;
                            case STRATEGY_PULLBACK:
                                strategy.ExecutePullbackStrategy(symbol, newsCalendar[i]);
                                break;
                            case STRATEGY_FUNDAMENTAL:
                                strategy.ExecuteFundamentalStrategy(symbol, newsCalendar[i]);
                                break;
                        }
                    }
                    
                    newsCalendar[i].processed = true;
                    
                    SendAlert(StringFormat("Новость обработана: %s %s", 
                                         newsCalendar[i].currency, 
                                         newsCalendar[i].title));
                }
            }
        }
        
        // Отправляем звуковой сигнал о приближающейся новости
        if(EnableSoundAlert && !newsCalendar[i].processed) {
            int minutesToNews = (int)((newsCalendar[i].time - current) / 60);
            if(minutesToNews == SoundAlertMinutes && 
               newsManager.IsNewsMatchingFilter(newsCalendar[i]) &&
               newsManager.IsCurrencyRelevant(newsCalendar[i].currency)) {
                
                if(!isTesting) PlaySound("alert.wav");
                SendAlert(StringFormat("Через %d минут: %s %s (Важность: %d)", 
                                    minutesToNews,
                                    newsCalendar[i].currency,
                                    newsCalendar[i].title,
                                    newsCalendar[i].impact));
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Timer event
//+------------------------------------------------------------------+
void OnTimer() {
    // Регулярное обновление новостей
    if(UseNewsFilter && TimeCurrent() - lastNewsCheck >= NewsUpdateMinutes * 60) {
        Print("Обновление календаря новостей...");
        
        if(newsManager.LoadNewsFromForexFactory()) {
            lastNewsCheck = TimeCurrent();
            SendAlert("Календарь новостей обновлен");
            
            // Update panel
            if(ShowNewsPanel && !isTesting) {
                newsPanel.Update(newsCalendar, ArraySize(newsCalendar), lastNewsCheck, NewsMinutesBefore);
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Chart event
//+------------------------------------------------------------------+
void OnChartEvent(const int id,
                  const long &lparam,
                  const double &dparam,
                  const string &sparam) {
    
    if(id == CHARTEVENT_OBJECT_CLICK) {
        if(newsPanel.IsRefreshClicked(sparam)) {
            Print("Ручное обновление календаря новостей...");
            if(newsManager.LoadNewsFromForexFactory()) {
                lastNewsCheck = TimeCurrent();
                SendAlert("Календарь новостей обновлен вручную");
                newsPanel.Update(newsCalendar, ArraySize(newsCalendar), lastNewsCheck, NewsMinutesBefore);
            }
        }
    }
}

//+------------------------------------------------------------------+
//| OnTester - Custom optimization criterion
//+------------------------------------------------------------------+
double OnTester()
{
    // Get basic statistics
    double profit = TesterStatistics(STAT_PROFIT);                     // Total profit
    double profitable_trades = TesterStatistics(STAT_PROFIT_TRADES);   // Profitable trades
    double loss_trades = TesterStatistics(STAT_LOSS_TRADES);          // Loss trades
    double drawdown = TesterStatistics(STAT_BALANCE_DDREL_PERCENT);   // Maximum drawdown
    double sumtrades = TesterStatistics(STAT_TRADES);                 // Total trades
    double depozit = TesterStatistics(STAT_INITIAL_DEPOSIT);
    
    double totalsum = profit + depozit;
    
    // Initialize and calculate win rate
    double winrate = 0.0;
    if(sumtrades == 0)
        winrate = 0.0;
    else
        winrate = profitable_trades / sumtrades;
    
    // Set minimum drawdown to 1%
    if(drawdown < 1.1)
        drawdown = 1.0;
    
    // Calculate win/loss ratio
    double win_loss_ratio;
    if(loss_trades == 0)
        win_loss_ratio = profitable_trades;
    else    
        win_loss_ratio = profitable_trades / loss_trades;
    
    // Calculate TP/SL ratio based on multipliers
    double tp_sl_ratio = TakeProfitMultiplier / StopLossMultiplier;
    
    // Calculate initial criterion
    double criterion = 0;
    
    if(drawdown != 0)
        criterion = profit * winrate * profitable_trades / drawdown;
    else
        criterion = profit * winrate * profitable_trades;
    
    // Apply TP/SL penalty if ratio is outside acceptable range
    if(tp_sl_ratio < 1.0 || tp_sl_ratio > 5.0)
    {
        criterion /= 150.0;
    }
    
    // Apply win rate penalty if below threshold
    if(winrate < 0.5)
    {
        criterion /= 150.0;
    }
    
    // Check profit factor
    if(totalsum > 0 && depozit > 0)
    {
        double profitFactor = totalsum / depozit;
        if(profitFactor < 1.02 || profitFactor > 1.30)
        {
            criterion /= 150.0;
        }
    }
    
    // Apply trailing stop penalty
    if(UseTrailingStop && TrailingStopMultiplier < 0.6)
    {
        criterion /= 150.0;
    }
    
    // Apply minimum trades requirement
    double minimum_required_trades = 23.0;
    
    if(sumtrades < minimum_required_trades)
        criterion /= (minimum_required_trades - sumtrades);
    
    // Add debug logging
    if(MQLInfoInteger(MQL_DEBUG))
    {
        Print("=== OnTester Calculation Details ===");
        Print("Profit: ", profit);
        Print("Win Rate: ", winrate);
        Print("Win/Loss Ratio: ", win_loss_ratio);
        Print("TP/SL Ratio: ", tp_sl_ratio);
        Print("Drawdown: ", drawdown);
        Print("Total Trades: ", sumtrades);
        Print("Minimum Required Trades: ", minimum_required_trades);
        Print("Final Criterion: ", criterion);
    }
    
    return criterion;
}

//+------------------------------------------------------------------+
//| Trade event  
//+------------------------------------------------------------------+
void OnTrade() {
    // Обработка торговых событий
    static int lastPositions = 0;
    int currentPositions = PositionsTotal();
    
    // Если позиция была закрыта
    if(currentPositions < lastPositions) {
        // Проверяем последнюю закрытую сделку
        HistorySelect(TimeCurrent() - 3600, TimeCurrent());
        int deals = HistoryDealsTotal();
        
        if(deals > 0) {
            ulong ticket = HistoryDealGetTicket(deals - 1);
            if(ticket > 0) {
                double profit = HistoryDealGetDouble(ticket, DEAL_PROFIT);
                
                if(profit < 0) {
                    consecutiveLosses++;
                } else if(profit > 0) {
                    consecutiveLosses = 0;
                }
                
                // Удаляем из отслеживания
                RemovePositionTracking(ticket);
            }
        }
    }
    
    lastPositions = currentPositions;
}

//+------------------------------------------------------------------+
//| Helper Functions
//+------------------------------------------------------------------+
void GetTradingPairsForCurrency(string currency, string &result[]) {
    ArrayResize(result, 0);
    
    for(int i = 0; i < ArraySize(validPairs); i++) {
        if(StringFind(validPairs[i], currency) >= 0) {
            int size = ArraySize(result);
            ArrayResize(result, size + 1);
            result[size] = validPairs[i];
        }
    }
}

//+------------------------------------------------------------------+
//| Get trade retcode description
//+------------------------------------------------------------------+
string GetTradeRetcodeDescription(uint retcode) {
    switch(retcode) {
        case TRADE_RETCODE_DONE: return "Успешно выполнено";
        case TRADE_RETCODE_REQUOTE: return "Реквота";
        case TRADE_RETCODE_REJECT: return "Запрос отклонен";
        case TRADE_RETCODE_CANCEL: return "Запрос отменен трейдером";
        case TRADE_RETCODE_PLACED: return "Ордер размещен";
        case TRADE_RETCODE_DONE_PARTIAL: return "Выполнено частично";
        case TRADE_RETCODE_ERROR: return "Ошибка обработки запроса";
        case TRADE_RETCODE_TIMEOUT: return "Тайм-аут запроса";
        case TRADE_RETCODE_INVALID: return "Неправильный запрос";
        case TRADE_RETCODE_INVALID_VOLUME: return "Неправильный объем";
        case TRADE_RETCODE_INVALID_PRICE: return "Неправильная цена";
        case TRADE_RETCODE_INVALID_STOPS: return "Неправильные стопы";
        case TRADE_RETCODE_TRADE_DISABLED: return "Торговля запрещена";
        case TRADE_RETCODE_MARKET_CLOSED: return "Рынок закрыт";
        case TRADE_RETCODE_NO_MONEY: return "Недостаточно средств";
        case TRADE_RETCODE_PRICE_CHANGED: return "Цена изменилась";
        case TRADE_RETCODE_NO_CHANGES: return "Нет изменений";
        case TRADE_RETCODE_SERVER_DISABLES_AT: return "Автоторговля запрещена сервером";
        case TRADE_RETCODE_CLIENT_DISABLES_AT: return "Автоторговля запрещена терминалом";
        case TRADE_RETCODE_LOCKED: return "Запрос заблокирован";
        case TRADE_RETCODE_FROZEN: return "Ордер заморожен";
        case TRADE_RETCODE_INVALID_FILL: return "Неверный тип исполнения";
        case TRADE_RETCODE_CONNECTION: return "Нет соединения";
        default: return "Неизвестная ошибка";
    }
}

//+------------------------------------------------------------------+
//| Check for updates in panel
//+------------------------------------------------------------------+
void UpdateNewsPanel() {
    if(ShowNewsPanel && !isTesting) {
        newsPanel.Update(newsCalendar, ArraySize(newsCalendar), lastNewsCheck, NewsMinutesBefore);
    }
}
