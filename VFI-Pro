//+------------------------------------------------------------------+
//|                                                 |
//|                        Copyright 2025, MetaQuotes Software Corp. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Dubravaspb"
#property link      "https://www.mql5.com"
#property version   "1.02"
#property description "Advanced implementation of Dubravaspb's Volume Flow Indicator with comprehensive analysis tools featuring buy/sell signals with customizable parameters, pattern recognition, rea"
#property indicator_separate_window
#property indicator_buffers 11
#property indicator_plots   9

//--- plot VFI
#property indicator_label1  "VFI"
#property indicator_type1   DRAW_LINE
#property indicator_color1  clrGreen
#property indicator_style1  STYLE_SOLID
#property indicator_width1  2

//--- plot VFI EMA
#property indicator_label2  "EMA of VFI"
#property indicator_type2   DRAW_LINE
#property indicator_color2  clrOrange
#property indicator_style2  STYLE_SOLID
#property indicator_width2  1

//--- plot Histogram
#property indicator_label3  "Histogram"
#property indicator_type3   DRAW_HISTOGRAM
#property indicator_color3  clrGray
#property indicator_style3  STYLE_SOLID
#property indicator_width3  3

//--- plot Buy Signal
#property indicator_label4  "Buy Signal"
#property indicator_type4   DRAW_ARROW
#property indicator_color4  clrLime
#property indicator_style4  STYLE_SOLID
#property indicator_width4  2

//--- plot Sell Signal
#property indicator_label5  "Sell Signal"
#property indicator_type5   DRAW_ARROW
#property indicator_color5  clrRed
#property indicator_style5  STYLE_SOLID
#property indicator_width5  2

//--- plot Risk Level
#property indicator_label9  "Risk Level"
#property indicator_type9   DRAW_COLOR_HISTOGRAM
#property indicator_color9  clrGreen, clrYellow, clrRed
#property indicator_style9  STYLE_SOLID
#property indicator_width9  2

//--- input parameters
input int      VFI_Length = 130;        // VFI length
input double   Coef = 0.2;              // Coefficient
input double   VCoef = 2.5;             // Max. vol. cutoff
input int      SignalLength = 5;        // Signal length
input bool     SmoothVFI = false;       // Smooth VFI
input bool     ShowHisto = false;       // Show Histogram
input bool     UseRealVolume = false;   // Use Real Volume (if available)
input bool     ShowPatterns = true;     // Enable Pattern Detection (now for display only)
input bool     EnableAlerts = true;     // Enable Sound Alerts
input bool     EnableNotifications = false; // Enable Push Notifications
input bool     EnableDynamicColors = true;  // Enable Dynamic Colors

// Настройки тренда и зон перекупленности/перепроданности
input int      TrendPeriod = 20;        // The period for determining the trend
input int      TrendSmoothingPeriod = 5; // Smoothing period to determine the trend
input int      ZonesAutoCalculationPeriod = 200; // The period for automatic zone calculation
input double   ZonePercentile = 80.0;   // Percentile for zones (80% = upper/lower 20%)
input color    OverboughtColor = clrRed; // The color of the overbought zone
input color    OversoldColor = clrGreen; // Oversold zone color
input int      ZoneTransparency = 80;   // Transparency of zones (0-255, where 0=transparent, 255=opaque)

// Настройки информационной панели
input bool     ShowInfoPanel = true;    // Show Information Panel
input ENUM_BASE_CORNER InfoPanelCorner = CORNER_LEFT_UPPER; // Info Panel Corner
input int      InfoPanelX = 10;         // Info Panel X Distance
input int      InfoPanelY = 10;         // Info Panel Y Distance
input int      InfoPanelWidth = 200;    // Info Panel Width
input int      InfoPanelHeight = 140;   // Info Panel Height (увеличена для тренда)
input color    InfoPanelColor = clrDarkBlue; // Info Panel Background Color
input color    InfoPanelTextColor = clrWhite; // Info Panel Text Color

input int      RiskAssessmentPeriod = 14;   // Risk Assessment Period

//--- indicator buffers
double VFI_Buffer[];
double VFI_EMA_Buffer[];
double Histogram_Buffer[];
double VCP_Buffer[];
double Buy_Signal_Buffer[];
double Sell_Signal_Buffer[];
double DoubleBottom_Buffer[];
double DoubleTop_Buffer[];
double Divergence_Buffer[];
double Risk_Buffer[];
double Risk_Colors_Buffer[];

//--- arrays for calculations
double inter_array[];
double typical_array[];
double volatility_array[];
double price_array[];
double trend_buffer[];         // Буфер для хранения данных о тренде

//--- global variables
bool real_volumes_available = false;
bool is_russian_system = false;
int alert_delay = 300; // 5 минут между алертами
datetime indicator_load_time = 0;  // Время загрузки индикатора
datetime last_alert_time = 0;

// Переменные для отслеживания изменения параметров
static int prev_vfi_length = -1;
static double prev_coef = -1;
static double prev_vcoef = -1;
static int prev_signal_length = -1;
static bool prev_smooth_vfi = false;
static bool prev_show_histo = false;
static bool prev_use_real_volume = false;
static bool parameters_changed = false;

// Добавляем переменную для хранения последнего количества баров
static int last_rates_total = 0;
static bool first_run = true;

// Для мини-дисплея информации
string info_panel_id = "VFI_InfoPanel";
string pattern_text_id = "VFI_PatternText";
string datetime_text_id = "VFI_DatetimeText";
string username_text_id = "VFI_UsernameText";
string risk_text_id = "VFI_RiskText";
string trend_text_id = "VFI_TrendText";    // Текстовый объект для тренда
string zones_text_id = "VFI_ZonesText";    // Текстовый объект для зон
datetime last_update_time = 0;
int update_frequency = 5; // Обновлять информацию каждые 5 секунд

// Глобальные переменные для уровней перекупленности/перепроданности
double dynamic_overbought_level = 0;
double dynamic_oversold_level = 0;
datetime last_zone_calculation = 0;
int zone_calculation_delay = 300; // 5 минут между пересчетами

// Идентификаторы объектов зон
string overbought_zone_id = "VFI_Overbought_Zone";
string oversold_zone_id = "VFI_Oversold_Zone";
string overbought_line_id = "VFI_Overbought_Line";
string oversold_line_id = "VFI_Oversold_Line";

// Enum для уровней риска
enum ENUM_RISK_LEVEL
{
    RISK_LOW = 0,    // Низкий риск (зеленый)
    RISK_MEDIUM = 1, // Средний риск (желтый)
    RISK_HIGH = 2    // Высокий риск (красный)
};

// Enum для направления тренда
enum ENUM_TREND_DIRECTION
{
    TREND_UP = 1,       // Восходящий тренд
    TREND_DOWN = -1,    // Нисходящий тренд
    TREND_SIDEWAYS = 0  // Боковой тренд
};

// Переменные для отслеживания сессии
datetime session_start_time = 0;

//+------------------------------------------------------------------+
//| Определение языка системы                                       |
//+------------------------------------------------------------------+
bool IsRussianSystem()
{
    // Получаем язык терминала
    string terminal_language = TerminalInfoString(TERMINAL_LANGUAGE);
    
    // Проверяем, является ли язык русским
    if(terminal_language == "Russian" || terminal_language == "Русский" || 
       StringFind(terminal_language, "RU") >= 0 || StringFind(terminal_language, "ru") >= 0)
    {
        return true;
    }
    
    // Дополнительная проверка через локализацию чисел
    string test_number = DoubleToString(1.5, 1);
    if(StringFind(test_number, ",") >= 0) // В русской локали десятичный разделитель - запятая
    {
        return true;
    }
    
    return false;
}

//+------------------------------------------------------------------+
//| Получение локализованного текста                                |
//+------------------------------------------------------------------+
string GetLocalizedText(string key)
{
    if(!is_russian_system)
    {
        // English texts
        if(key == "volume_check_header") return "           VFI INDICATOR VOLUME CHECK           ";
        if(key == "symbol") return "Symbol";
        if(key == "datetime") return "Date/time";
        if(key == "user") return "User";
        if(key == "execution_type") return "Execution type";
        if(key == "terminal_paths") return "DEBUG - Terminal paths";
        if(key == "bars_analyzed") return "Bars analyzed";
        if(key == "tick_volumes") return "TICK VOLUMES";
        if(key == "average") return "Average";
        if(key == "maximum") return "Maximum";
        if(key == "minimum") return "Minimum";
        if(key == "zero_bars") return "Bars with zero volume";
        if(key == "real_volumes") return "REAL VOLUMES";
        if(key == "real_volumes_unavailable") return "REAL VOLUMES: Unavailable";
        if(key == "quality_assessment") return "QUALITY ASSESSMENT";
        if(key == "recommendation") return "RECOMMENDATION";
        if(key == "indicator_settings") return "INDICATOR SETTINGS";
        if(key == "will_use_real") return "Will use: REAL VOLUMES";
        if(key == "will_use_tick") return "Will use: TICK VOLUMES";
        if(key == "yes") return "YES";
        if(key == "no") return "NO";
        if(key == "error_no_data") return "❌ ERROR: Could not get price data!";
        if(key == "critical_no_volumes") return "❌ CRITICAL: Very little volume data";
        if(key == "poor_no_variation") return " POOR: Volumes hardly change";
        if(key == "satisfactory_tick_only") return " SATISFACTORY: Tick volumes only";
        if(key == "excellent_real_volumes") return " EXCELLENT: Quality real volumes";
        if(key == "good_real_gaps") return " GOOD: Real volumes with gaps";
        if(key == "change_instrument") return "Change instrument or broker";
        if(key == "may_work_incorrectly") return "Indicator may work incorrectly";
        if(key == "will_work_less_accurate") return "Indicator will work, but less accurately";
        if(key == "will_work_max_accurate") return "Indicator will work with maximum accuracy";
        if(key == "will_work_correctly") return "Indicator will work correctly";
        if(key == "indicator_finished") return "         VFI INDICATOR FINISHED WORK         ";
        if(key == "reason") return "Reason";
        if(key == "time") return "Time";
        if(key == "parameter_error") return "Parameter Error";
        if(key == "invalid_vfi_length") return "VFI_Length must be >= 10";
        if(key == "invalid_signal_length") return "SignalLength must be >= 1";
        if(key == "invalid_coefficients") return "Coefficients must be positive";
        if(key == "settings_changed") return "Settings changed - recalculating all data";
        if(key == "buffer_reset") return "Buffer reset detected - recalculating";
        if(key == "buy_signals_enabled") return "Buy signals enabled";
        if(key == "sell_signals_enabled") return "Sell signals enabled";
        if(key == "pattern_recognition_enabled") return "Pattern recognition enabled";
        if(key == "alerts_enabled") return "Alerts enabled";
        if(key == "notifications_enabled") return "Push notifications enabled";
        if(key == "dynamic_colors_enabled") return "Dynamic colors enabled";
        if(key == "info_panel_enabled") return "Information panel enabled";
        if(key == "buy_signal_detected") return "VFI Buy Signal detected";
        if(key == "sell_signal_detected") return "VFI Sell Signal detected";
        if(key == "double_bottom_detected") return "Double Bottom pattern detected";
        if(key == "double_top_detected") return "Double Top pattern detected";
        if(key == "divergence_detected") return "Divergence pattern detected";
        if(key == "risk_assessment") return "Risk Level";
        if(key == "risk_low") return "Low";
        if(key == "risk_medium") return "Medium";
        if(key == "risk_high") return "High";
        if(key == "current_user") return "Current User";
        if(key == "current_time") return "Current Time";
        if(key == "detected_patterns") return "Detected Patterns";
        if(key == "no_patterns_detected") return "No patterns detected";
        if(key == "panel_title") return "VFI Info Panel";
        // Тексты для тренда
        if(key == "trend") return "Trend";
        if(key == "trend_up") return "Uptrend";
        if(key == "trend_down") return "Downtrend";
        if(key == "trend_sideways") return "Sideways";
        if(key == "trend_strength") return "Strength";
        if(key == "overbought_zones") return "Overbought zones enabled";
        if(key == "oversold_zones") return "Oversold zones enabled";
        // Тексты для автоматических зон
        if(key == "auto_zones") return "Auto zones calculation enabled";
        if(key == "overbought_level") return "Overbought level";
        if(key == "oversold_level") return "Oversold level";
        if(key == "zones") return "Zones";
        if(key == "recalculating_zones") return "Recalculating zone levels";
        // Тексты для сессии
        if(key == "minutes") return "min";
        if(key == "hours") return "h";
        if(key == "days") return "d";
    }
    else
    {
        // Russian texts
        if(key == "volume_check_header") return "           ПРОВЕРКА ОБЪЕМОВ VFI ИНДИКАТОРА           ";
        if(key == "symbol") return "Символ";
        if(key == "datetime") return "Дата/время";
        if(key == "user") return "Пользователь";
        if(key == "execution_type") return "Тип исполнения";
        if(key == "terminal_paths") return "DEBUG - Пути терминала";
        if(key == "bars_analyzed") return "Получено баров для анализа";
        if(key == "tick_volumes") return "ТИКОВЫЕ ОБЪЕМЫ";
        if(key == "average") return "Средний";
        if(key == "maximum") return "Максимальный";
        if(key == "minimum") return "Минимальный";
        if(key == "zero_bars") return "Баров с нулевым объемом";
        if(key == "real_volumes") return "РЕАЛЬНЫЕ ОБЪЕМЫ";
        if(key == "real_volumes_unavailable") return "РЕАЛЬНЫЕ ОБЪЕМЫ: Недоступны";
        if(key == "quality_assessment") return "ОЦЕНКА КАЧЕСТВА";
        if(key == "recommendation") return "РЕКОМЕНДАЦИЯ";
        if(key == "indicator_settings") return "НАСТРОЙКИ ИНДИКАТОРА";
        if(key == "will_use_real") return "Будут использованы: РЕАЛЬНЫЕ ОБЪЕМЫ";
        if(key == "will_use_tick") return "Будут использованы: ТИКОВЫЕ ОБЪЕМЫ";
        if(key == "yes") return "ДА";
        if(key == "no") return "НЕТ";
        if(key == "error_no_data") return "❌ ОШИБКА: Не удалось получить данные по ценам!";
        if(key == "critical_no_volumes") return "❌ КРИТИЧНО: Очень мало данных по объемам";
        if(key == "poor_no_variation") return " ПЛОХО: Объемы практически не меняются";
        if(key == "satisfactory_tick_only") return " УДОВЛЕТВОРИТЕЛЬНО: Только тиковые объемы";
        if(key == "excellent_real_volumes") return " ОТЛИЧНО: Качественные реальные объемы";
        if(key == "good_real_gaps") return " ХОРОШО: Реальные объемы с пропусками";
        if(key == "change_instrument") return "Смените инструмент или брокера";
        if(key == "may_work_incorrectly") return "Индикатор может работать некорректно";
        if(key == "will_work_less_accurate") return "Индикатор будет работать, но менее точно";
        if(key == "will_work_max_accurate") return "Индикатор будет работать максимально точно";
        if(key == "will_work_correctly") return "Индикатор будет работать корректно";
        if(key == "indicator_finished") return "         VFI ИНДИКАТОР ЗАВЕРШИЛ РАБОТУ         ";
        if(key == "reason") return "Причина";
        if(key == "time") return "Время";
        if(key == "parameter_error") return "Ошибка параметров";
        if(key == "invalid_vfi_length") return "VFI_Length должно быть >= 10";
        if(key == "invalid_signal_length") return "SignalLength должно быть >= 1";
        if(key == "invalid_coefficients") return "Коэффициенты должны быть положительными";
        if(key == "settings_changed") return "Настройки изменены - пересчитываем все данные";
        if(key == "buffer_reset") return "Обнаружен сброс буфера - пересчитываем";
        if(key == "buy_signals_enabled") return "Сигналы покупки включены";
        if(key == "sell_signals_enabled") return "Сигналы продажи включены";
        if(key == "pattern_recognition_enabled") return "Распознавание паттернов включено";
        if(key == "alerts_enabled") return "Звуковые алерты включены";
        if(key == "notifications_enabled") return "Push-уведомления включены";
        if(key == "dynamic_colors_enabled") return "Динамические цвета включены";
        if(key == "info_panel_enabled") return "Информационная панель включена";
        if(key == "buy_signal_detected") return "Обнаружен сигнал покупки VFI";
        if(key == "sell_signal_detected") return "Обнаружен сигнал продажи VFI";
        if(key == "double_bottom_detected") return "Обнаружен паттерн Двойное Дно";
        if(key == "double_top_detected") return "Обнаружен паттерн Двойная Вершина";
        if(key == "divergence_detected") return "Обнаружен паттерн Дивергенция";
        if(key == "risk_assessment") return "Уровень риска";
        if(key == "risk_low") return "Низкий";
        if(key == "risk_medium") return "Средний";
        if(key == "risk_high") return "Высокий";
        if(key == "current_user") return "Текущий пользователь";
        if(key == "current_time") return "Текущее время";
        if(key == "detected_patterns") return "Обнаруженные паттерны";
        if(key == "no_patterns_detected") return "Паттерны не обнаружены";
        if(key == "panel_title") return "VFI Инфо Панель";
        // Тексты для тренда
        if(key == "trend") return "Тренд";
        if(key == "trend_up") return "Восходящий";
        if(key == "trend_down") return "Нисходящий";
        if(key == "trend_sideways") return "Боковой";
        if(key == "trend_strength") return "Сила";
        if(key == "overbought_zones") return "Зоны перекупленности включены";
        if(key == "oversold_zones") return "Зоны перепроданности включены";
        // Тексты для автоматических зон
        if(key == "auto_zones") return "Автоматический расчет зон включен";
        if(key == "overbought_level") return "Уровень перекупленности";
        if(key == "oversold_level") return "Уровень перепроданности";
        if(key == "zones") return "Зоны";
        if(key == "recalculating_zones") return "Пересчёт уровней зон";
        // Тексты для сессии
        if(key == "minutes") return "мин";
        if(key == "hours") return "ч";
        if(key == "days") return "д";
    }
    
    return key;
}

//+------------------------------------------------------------------+
//| Получение имени пользователя компьютера                         |
//+------------------------------------------------------------------+
string GetComputerUserName()
{
    string username = "YassAbdelali1"; // Значение по умолчанию
    
    // Получаем путь к данным терминала
    string data_path = TerminalInfoString(TERMINAL_DATA_PATH);
    
    if(StringLen(data_path) > 0)
    {
        int pos = StringFind(data_path, "Users\\");
        if(pos >= 0)
        {
            int start = pos + 6; // длина "Users\"
            int end = StringFind(data_path, "\\", start);
            if(end > start)
            {
                string extracted = StringSubstr(data_path, start, end - start);
                if(StringLen(extracted) > 0 && extracted != "AppData" && 
                   extracted != "Roaming" && extracted != "MetaQuotes")
                {
                    username = extracted;
                }
            }
        }
    }
    
    // Очистка имени пользователя
    StringReplace(username, " ", "_");
    if(StringLen(username) > 20)
        username = StringSubstr(username, 0, 20);
    
    return username;
}

//+------------------------------------------------------------------+
//| Получение текущей даты и времени                                |
//+------------------------------------------------------------------+
string GetCurrentDateTime()
{
    // Получаем текущее время из терминала
    datetime current_time = TimeGMT(); // Используем GMT время
    
    MqlDateTime dt;
    TimeToStruct(current_time, dt);
    
    return StringFormat("%04d-%02d-%02d %02d:%02d:%02d", 
                      dt.year, dt.mon, dt.day, dt.hour, dt.min, dt.sec);
}

//+------------------------------------------------------------------+
//| Получение времени работы сессии                                 |
//+------------------------------------------------------------------+
string GetSessionUptime()
{
    if(session_start_time == 0)
        return "00:00";
    
    datetime current_time = TimeGMT();
    int uptime_seconds = (int)(current_time - session_start_time);
    
    int days = uptime_seconds / 86400;
    uptime_seconds %= 86400;
    int hours = uptime_seconds / 3600;
    uptime_seconds %= 3600;
    int minutes = uptime_seconds / 60;
    
    string uptime_str = "";
    
    if(days > 0)
        uptime_str += IntegerToString(days) + GetLocalizedText("days") + " ";
    if(hours > 0)
        uptime_str += IntegerToString(hours) + GetLocalizedText("hours") + " ";
    
    uptime_str += IntegerToString(minutes) + GetLocalizedText("minutes");
    
    return uptime_str;
}

//+------------------------------------------------------------------+
//| Send Alert Function                                             |
//+------------------------------------------------------------------+
void SendAlert(string message, datetime signal_time)
{
    datetime current_time = TimeCurrent();
    
    // Проверяем, прошло ли достаточно времени с предыдущего алерта
    if(current_time - last_alert_time < alert_delay)
        return;
    
    // Проверяем, что сигнал относится к текущему или предыдущему бару
    int current_bar = iBarShift(Symbol(), PERIOD_CURRENT, signal_time);
    if(current_bar > 1) // Игнорируем сигналы старше 1 бара
        return;
        
    // Сохраняем время отправки алерта
    last_alert_time = current_time;
    
    // Выводим сообщение в журнал
    Print(message);
    
    // Отправляем звуковой алерт
    if(EnableAlerts)
        Alert(message);
        
    // Отправляем push-уведомление
    if(EnableNotifications)
        SendNotification(message);
}

//+------------------------------------------------------------------+
//| Автоматический расчет уровней перекупленности/перепроданности  |
//+------------------------------------------------------------------+
void CalculateOverboughtOversoldLevels(int bar_pos)
{
    if(bar_pos < ZonesAutoCalculationPeriod)
        return;
    
    // Проверяем, не слишком ли часто пересчитываем зоны
    datetime current_time = TimeCurrent();
    if(current_time - last_zone_calculation < zone_calculation_delay && dynamic_overbought_level != 0)
        return;
        
    last_zone_calculation = current_time;
    
    // Собираем статистику по значениям индикатора
    double vfi_values[];
    ArrayResize(vfi_values, ZonesAutoCalculationPeriod);
    
    int count = 0;
    for(int i = bar_pos; i > bar_pos - ZonesAutoCalculationPeriod && i >= 0; i--)
    {
        if(VFI_Buffer[i] != EMPTY_VALUE)
        {
            vfi_values[count] = VFI_Buffer[i];
            count++;
        }
    }
    
    // Если недостаточно данных, используем значения по умолчанию
    if(count < ZonesAutoCalculationPeriod / 2)
    {
        // Значения по умолчанию
        dynamic_overbought_level = 1.0;
        dynamic_oversold_level = -1.0;
        Print("Warning: Not enough data to calculate zones, using default values");
        return;
    }
    
    // Подгоняем размер массива под количество реальных элементов
    ArrayResize(vfi_values, count);
    
    // Сортируем для определения процентилей
    ArraySort(vfi_values);
    
    // Вычисляем позиции процентилей
    int upper_pos = (int)((count - 1) * ZonePercentile / 100.0);
    int lower_pos = (int)((count - 1) * (100.0 - ZonePercentile) / 100.0);
    
    // Проверяем корректность индексов
    if(upper_pos >= count) upper_pos = count - 1;
    if(lower_pos < 0) lower_pos = 0;
    
    // Обновляем уровни
    dynamic_overbought_level = vfi_values[upper_pos];
    dynamic_oversold_level = vfi_values[lower_pos];
    
    // Проверяем, что overbought > oversold
    if(dynamic_overbought_level <= dynamic_oversold_level)
    {
        // Если что-то пошло не так, используем среднее и стандартное отклонение
        double sum = 0, sum_sq = 0;
        for(int i = 0; i < count; i++)
        {
            sum += vfi_values[i];
            sum_sq += MathPow(vfi_values[i], 2);
        }
        double mean = sum / count;
        double std_dev = MathSqrt(sum_sq / count - mean * mean);
        
        dynamic_overbought_level = mean + 1.5 * std_dev;
        dynamic_oversold_level = mean - 1.5 * std_dev;
    }
    
    Print(" ", GetLocalizedText("recalculating_zones"), ": OB=", 
          DoubleToString(dynamic_overbought_level, 4), ", OS=", 
          DoubleToString(dynamic_oversold_level, 4));
    
    // Обновляем объекты зон для визуализации
    UpdateZoneObjects(bar_pos);
}

//+------------------------------------------------------------------+
//| Обновление объектов зон                                        |
//+------------------------------------------------------------------+
void UpdateZoneObjects(int bar_pos)
{
    // Force removal of old objects
    ObjectDelete(0, overbought_zone_id);
    ObjectDelete(0, oversold_zone_id);
    ObjectDelete(0, overbought_line_id);
    ObjectDelete(0, oversold_line_id);
    
    // If levels aren't calculated or are 0, set base values
    if(dynamic_overbought_level == 0 || dynamic_oversold_level == 0)
    {
        dynamic_overbought_level = 1.0;
        dynamic_oversold_level = -1.0;
    }
    
    // Get indicator window
    int window = ChartWindowFind();
    if(window < 0) return;
    
    // Get chart boundaries
    double chart_max = 0, chart_min = 0;
    ChartGetDouble(0, CHART_PRICE_MAX, window, chart_max);
    ChartGetDouble(0, CHART_PRICE_MIN, window, chart_min);
    
    // Calculate boundaries if not available
    if(chart_max <= 0 || chart_min >= 0)
    {
        chart_max = MathMax(2.0, dynamic_overbought_level * 1.5);
        chart_min = MathMin(-2.0, dynamic_oversold_level * 1.5);
        
        // Find max/min indicator values
        double max_value = -DBL_MAX;
        double min_value = DBL_MAX;
        
        for(int i = bar_pos; i >= MathMax(0, bar_pos - 500); i--)
        {
            if(VFI_Buffer[i] != EMPTY_VALUE)
            {
                if(VFI_Buffer[i] > max_value) max_value = VFI_Buffer[i];
                if(VFI_Buffer[i] < min_value) min_value = VFI_Buffer[i];
            }
        }
        
        chart_max = MathMax(chart_max, max_value * 1.2);
        chart_min = MathMin(chart_min, min_value * 1.2);
    }
    
    // Time coordinates
    datetime time_start, time_end;
    
    // Check if we're in the strategy tester
    bool is_tester = MQLInfoInteger(MQL_TESTER);
    
    if(is_tester)
    {
        // In strategy tester, use fixed range relative to visible bars
        int first_visible_bar = ChartGetInteger(0, CHART_FIRST_VISIBLE_BAR);
        int window_bars = ChartGetInteger(0, CHART_VISIBLE_BARS);
        
        // Get time for start and end based on visible chart range
        time_start = iTime(Symbol(), PERIOD_CURRENT, first_visible_bar);
        time_end = iTime(Symbol(), PERIOD_CURRENT, MathMax(0, first_visible_bar - window_bars));
        
        // If time values are invalid, use a fallback approach
        if(time_start <= 0 || time_end <= 0)
        {
            time_start = iTime(Symbol(), PERIOD_CURRENT, MathMin(bar_pos, 100));
            time_end = TimeCurrent() + 86400; // Add one day for display to the right
        }
    }
    else
    {
        // Normal chart mode
        time_start = iTime(Symbol(), PERIOD_CURRENT, MathMin(bar_pos, 100));
        time_end = TimeCurrent() + 86400; // Add one day for display to the right
    }
    
    // Fallback if times are still invalid
    if(time_start <= 0) time_start = TimeCurrent() - 86400 * 10;
    if(time_end <= 0 || time_end <= time_start) time_end = time_start + 86400 * 30;
    
    // Create horizontal lines for levels
    if(ObjectCreate(0, overbought_line_id, OBJ_TREND, window, time_start, dynamic_overbought_level, 
                                                       time_end, dynamic_overbought_level))
    {
        ObjectSetInteger(0, overbought_line_id, OBJPROP_COLOR, OverboughtColor);
        ObjectSetInteger(0, overbought_line_id, OBJPROP_STYLE, STYLE_DASH);
        ObjectSetInteger(0, overbought_line_id, OBJPROP_WIDTH, 1);
        ObjectSetInteger(0, overbought_line_id, OBJPROP_RAY_RIGHT, false);
        ObjectSetInteger(0, overbought_line_id, OBJPROP_RAY_LEFT, false);
        ObjectSetInteger(0, overbought_line_id, OBJPROP_BACK, true);
        ObjectSetInteger(0, overbought_line_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, overbought_line_id, OBJPROP_SELECTED, false);
        ObjectSetInteger(0, overbought_line_id, OBJPROP_HIDDEN, true);
    }
    
    if(ObjectCreate(0, oversold_line_id, OBJ_TREND, window, time_start, dynamic_oversold_level, 
                                                    time_end, dynamic_oversold_level))
    {
        ObjectSetInteger(0, oversold_line_id, OBJPROP_COLOR, OversoldColor);
        ObjectSetInteger(0, oversold_line_id, OBJPROP_STYLE, STYLE_DASH);
        ObjectSetInteger(0, oversold_line_id, OBJPROP_WIDTH, 1);
        ObjectSetInteger(0, oversold_line_id, OBJPROP_RAY_RIGHT, false);
        ObjectSetInteger(0, oversold_line_id, OBJPROP_RAY_LEFT, false);
        ObjectSetInteger(0, oversold_line_id, OBJPROP_BACK, true);
        ObjectSetInteger(0, oversold_line_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, oversold_line_id, OBJPROP_SELECTED, false);
        ObjectSetInteger(0, oversold_line_id, OBJPROP_HIDDEN, true);
    }
    
    // Create zone fills
    if(ObjectCreate(0, overbought_zone_id, OBJ_RECTANGLE, window, 
                   time_start, dynamic_overbought_level, time_end, chart_max))
    {
        ObjectSetInteger(0, overbought_zone_id, OBJPROP_COLOR, OverboughtColor);
        ObjectSetInteger(0, overbought_zone_id, OBJPROP_FILL, true);
        ObjectSetInteger(0, overbought_zone_id, OBJPROP_BGCOLOR, OverboughtColor);
        ObjectSetInteger(0, overbought_zone_id, OBJPROP_BACK, true);
        ObjectSetInteger(0, overbought_zone_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, overbought_zone_id, OBJPROP_SELECTED, false);
        ObjectSetInteger(0, overbought_zone_id, OBJPROP_HIDDEN, true);
        ObjectSetInteger(0, overbought_zone_id, OBJPROP_WIDTH, 1);
        ObjectSetInteger(0, overbought_zone_id, OBJPROP_ZORDER, 0);
    }
    
    if(ObjectCreate(0, oversold_zone_id, OBJ_RECTANGLE, window, 
                   time_start, chart_min, time_end, dynamic_oversold_level))
    {
        ObjectSetInteger(0, oversold_zone_id, OBJPROP_COLOR, OversoldColor);
        ObjectSetInteger(0, oversold_zone_id, OBJPROP_FILL, true);
        ObjectSetInteger(0, oversold_zone_id, OBJPROP_BGCOLOR, OversoldColor);
        ObjectSetInteger(0, oversold_zone_id, OBJPROP_BACK, true);
        ObjectSetInteger(0, oversold_zone_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, oversold_zone_id, OBJPROP_SELECTED, false);
        ObjectSetInteger(0, oversold_zone_id, OBJPROP_HIDDEN, true);
        ObjectSetInteger(0, oversold_zone_id, OBJPROP_WIDTH, 1);
        ObjectSetInteger(0, oversold_zone_id, OBJPROP_ZORDER, 0);
    }
}

//+------------------------------------------------------------------+
//| Определение тренда                                             |
//+------------------------------------------------------------------+
ENUM_TREND_DIRECTION DetermineTrend(int bar_pos, int period, double &strength)
{
    if(bar_pos <= period || ArraySize(VFI_Buffer) <= period)
        return TREND_SIDEWAYS;
    
    // Используем скользящее среднее VFI для более гладкого определения тренда
    double ma_current = 0, ma_previous = 0;
    int valid_bars = 0;
    
    // Рассчитываем SMA для текущего периода
    for(int i = 0; i < TrendSmoothingPeriod; i++)
    {
        if(bar_pos - i >= 0 && VFI_Buffer[bar_pos - i] != EMPTY_VALUE)
        {
            ma_current += VFI_Buffer[bar_pos - i];
            valid_bars++;
        }
    }
    
    if(valid_bars > 0)
        ma_current /= valid_bars;
    else
        return TREND_SIDEWAYS;
    
    // Рассчитываем SMA для предыдущего периода
    valid_bars = 0;
    for(int i = period; i < period + TrendSmoothingPeriod; i++)
    {
        if(bar_pos - i >= 0 && VFI_Buffer[bar_pos - i] != EMPTY_VALUE)
        {
            ma_previous += VFI_Buffer[bar_pos - i];
            valid_bars++;
        }
    }
    
    if(valid_bars > 0)
        ma_previous /= valid_bars;
    else
        return TREND_SIDEWAYS;
    
    // Определяем направление тренда
    double diff = ma_current - ma_previous;
    
    // Нормализуем силу тренда на основе изменения за период
    double max_diff = 0;
    for(int i = 0; i < period; i++)
    {
        if(bar_pos - i >= 0 && bar_pos - i - 1 >= 0)
        {
            double bar_diff = MathAbs(VFI_Buffer[bar_pos - i] - VFI_Buffer[bar_pos - i - 1]);
            if(bar_diff > max_diff)
                max_diff = bar_diff;
        }
    }
    
    // Сила тренда - нормализованное значение от 0 до 1
    if(max_diff > 0)
        strength = MathMin(MathAbs(diff) / max_diff, 1.0);
    else
        strength = 0;
    
    // Определяем боковой тренд при малых изменениях
    if(MathAbs(diff) < 0.05)
        return TREND_SIDEWAYS;
        
    if(diff > 0)
        return TREND_UP;
    else
        return TREND_DOWN;
}

//+------------------------------------------------------------------+
//| Создание информационной панели                                  |
//+------------------------------------------------------------------+
void CreateInfoPanel()
{
    if(!ShowInfoPanel)
        return;
    
    // Создаем фон панели
    if(ObjectFind(0, info_panel_id) < 0)
    {
        ObjectCreate(0, info_panel_id, OBJ_RECTANGLE_LABEL, 0, 0, 0);
        ObjectSetInteger(0, info_panel_id, OBJPROP_CORNER, InfoPanelCorner);
        ObjectSetInteger(0, info_panel_id, OBJPROP_XDISTANCE, InfoPanelX);
        ObjectSetInteger(0, info_panel_id, OBJPROP_YDISTANCE, InfoPanelY);
        ObjectSetInteger(0, info_panel_id, OBJPROP_XSIZE, InfoPanelWidth);
        ObjectSetInteger(0, info_panel_id, OBJPROP_YSIZE, InfoPanelHeight);
        ObjectSetInteger(0, info_panel_id, OBJPROP_BGCOLOR, InfoPanelColor);
        ObjectSetInteger(0, info_panel_id, OBJPROP_BORDER_TYPE, BORDER_FLAT);
        ObjectSetInteger(0, info_panel_id, OBJPROP_COLOR, InfoPanelTextColor);
        ObjectSetInteger(0, info_panel_id, OBJPROP_STYLE, STYLE_SOLID);
        ObjectSetInteger(0, info_panel_id, OBJPROP_WIDTH, 1);
        ObjectSetInteger(0, info_panel_id, OBJPROP_BACK, false);
        ObjectSetInteger(0, info_panel_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, info_panel_id, OBJPROP_SELECTED, false);
        ObjectSetInteger(0, info_panel_id, OBJPROP_HIDDEN, true);
        ObjectSetInteger(0, info_panel_id, OBJPROP_ZORDER, 1);
    }
    
    // Адаптируем координаты в зависимости от угла
    int title_x, title_y, dt_y, user_y, risk_y, pattern_y, trend_y, zones_y;
    
    // Создаем заголовок панели
    string title_id = info_panel_id + "_Title";
    if(ObjectFind(0, title_id) < 0)
    {
        // Определяем координаты в зависимости от угла
        switch(InfoPanelCorner)
        {
            case CORNER_LEFT_UPPER:
            case CORNER_RIGHT_UPPER:
                title_y = 15;
                dt_y = 35;
                user_y = 55;
                risk_y = 75;
                pattern_y = 95;
                trend_y = 115;
                zones_y = 135;
                break;
            case CORNER_LEFT_LOWER:
            case CORNER_RIGHT_LOWER:
                title_y = InfoPanelHeight - 15;
                dt_y = InfoPanelHeight - 35;
                user_y = InfoPanelHeight - 55;
                risk_y = InfoPanelHeight - 75;
                pattern_y = InfoPanelHeight - 95;
                trend_y = InfoPanelHeight - 115;
                zones_y = InfoPanelHeight - 135;
                break;
        }
        
        // Определяем X координату в зависимости от угла
        switch(InfoPanelCorner)
        {
            case CORNER_LEFT_UPPER:
            case CORNER_LEFT_LOWER:
                title_x = InfoPanelWidth - 10;
                break;
            case CORNER_RIGHT_UPPER:
            case CORNER_RIGHT_LOWER:
                title_x = 10;
                break;
        }
        
        // Создаем заголовок
        ObjectCreate(0, title_id, OBJ_LABEL, 0, 0, 0);
        ObjectSetInteger(0, title_id, OBJPROP_CORNER, InfoPanelCorner);
        ObjectSetInteger(0, title_id, OBJPROP_XDISTANCE, title_x);
        ObjectSetInteger(0, title_id, OBJPROP_YDISTANCE, title_y);
        ObjectSetInteger(0, title_id, OBJPROP_COLOR, InfoPanelTextColor);
        ObjectSetInteger(0, title_id, OBJPROP_FONTSIZE, 10);
        ObjectSetInteger(0, title_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, title_id, OBJPROP_HIDDEN, true);
        ObjectSetString(0, title_id, OBJPROP_TEXT, GetLocalizedText("panel_title"));
        ObjectSetString(0, title_id, OBJPROP_FONT, "Arial Bold");
        
        // Устанавливаем выравнивание текста
        if(InfoPanelCorner == CORNER_LEFT_UPPER || InfoPanelCorner == CORNER_LEFT_LOWER)
            ObjectSetInteger(0, title_id, OBJPROP_ANCHOR, ANCHOR_RIGHT_UPPER);
    }
    
    // Текст для даты и времени
    if(ObjectFind(0, datetime_text_id) < 0)
    {
        ObjectCreate(0, datetime_text_id, OBJ_LABEL, 0, 0, 0);
        ObjectSetInteger(0, datetime_text_id, OBJPROP_CORNER, InfoPanelCorner);
        ObjectSetInteger(0, datetime_text_id, OBJPROP_XDISTANCE, title_x);
        ObjectSetInteger(0, datetime_text_id, OBJPROP_YDISTANCE, dt_y);
        ObjectSetInteger(0, datetime_text_id, OBJPROP_COLOR, InfoPanelTextColor);
        ObjectSetInteger(0, datetime_text_id, OBJPROP_FONTSIZE, 8);
        ObjectSetInteger(0, datetime_text_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, datetime_text_id, OBJPROP_HIDDEN, true);
        ObjectSetString(0, datetime_text_id, OBJPROP_TEXT, GetLocalizedText("current_time") + ": " + GetCurrentDateTime());
        
        // Устанавливаем выравнивание текста
        if(InfoPanelCorner == CORNER_LEFT_UPPER || InfoPanelCorner == CORNER_LEFT_LOWER)
            ObjectSetInteger(0, datetime_text_id, OBJPROP_ANCHOR, ANCHOR_RIGHT_UPPER);
    }
    
    // Текст для имени пользователя
    if(ObjectFind(0, username_text_id) < 0)
    {
        ObjectCreate(0, username_text_id, OBJ_LABEL, 0, 0, 0);
        ObjectSetInteger(0, username_text_id, OBJPROP_CORNER, InfoPanelCorner);
        ObjectSetInteger(0, username_text_id, OBJPROP_XDISTANCE, title_x);
        ObjectSetInteger(0, username_text_id, OBJPROP_YDISTANCE, user_y);
        ObjectSetInteger(0, username_text_id, OBJPROP_COLOR, InfoPanelTextColor);
        ObjectSetInteger(0, username_text_id, OBJPROP_FONTSIZE, 8);
        ObjectSetInteger(0, username_text_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, username_text_id, OBJPROP_HIDDEN, true);
        ObjectSetString(0, username_text_id, OBJPROP_TEXT, GetLocalizedText("current_user") + ": " + GetComputerUserName());
        
        // Устанавливаем выравнивание текста
        if(InfoPanelCorner == CORNER_LEFT_UPPER || InfoPanelCorner == CORNER_LEFT_LOWER)
            ObjectSetInteger(0, username_text_id, OBJPROP_ANCHOR, ANCHOR_RIGHT_UPPER);
    }
    
    // Текст для уровня риска
    if(ObjectFind(0, risk_text_id) < 0)
    {
        ObjectCreate(0, risk_text_id, OBJ_LABEL, 0, 0, 0);
        ObjectSetInteger(0, risk_text_id, OBJPROP_CORNER, InfoPanelCorner);
        ObjectSetInteger(0, risk_text_id, OBJPROP_XDISTANCE, title_x);
        ObjectSetInteger(0, risk_text_id, OBJPROP_YDISTANCE, risk_y);
        ObjectSetInteger(0, risk_text_id, OBJPROP_COLOR, InfoPanelTextColor);
        ObjectSetInteger(0, risk_text_id, OBJPROP_FONTSIZE, 8);
        ObjectSetInteger(0, risk_text_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, risk_text_id, OBJPROP_HIDDEN, true);
        ObjectSetString(0, risk_text_id, OBJPROP_TEXT, GetLocalizedText("risk_assessment") + ": " + GetLocalizedText("risk_medium"));
        
        // Устанавливаем выравнивание текста
        if(InfoPanelCorner == CORNER_LEFT_UPPER || InfoPanelCorner == CORNER_LEFT_LOWER)
            ObjectSetInteger(0, risk_text_id, OBJPROP_ANCHOR, ANCHOR_RIGHT_UPPER);
    }
    
    // Текст для обнаруженных паттернов
    if(ObjectFind(0, pattern_text_id) < 0)
    {
        ObjectCreate(0, pattern_text_id, OBJ_LABEL, 0, 0, 0);
        ObjectSetInteger(0, pattern_text_id, OBJPROP_CORNER, InfoPanelCorner);
        ObjectSetInteger(0, pattern_text_id, OBJPROP_XDISTANCE, title_x);
        ObjectSetInteger(0, pattern_text_id, OBJPROP_YDISTANCE, pattern_y);
        ObjectSetInteger(0, pattern_text_id, OBJPROP_COLOR, InfoPanelTextColor);
        ObjectSetInteger(0, pattern_text_id, OBJPROP_FONTSIZE, 8);
        ObjectSetInteger(0, pattern_text_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, pattern_text_id, OBJPROP_HIDDEN, true);
        ObjectSetString(0, pattern_text_id, OBJPROP_TEXT, GetLocalizedText("detected_patterns") + ": -");
        
        // Устанавливаем выравнивание текста
        if(InfoPanelCorner == CORNER_LEFT_UPPER || InfoPanelCorner == CORNER_LEFT_LOWER)
            ObjectSetInteger(0, pattern_text_id, OBJPROP_ANCHOR, ANCHOR_RIGHT_UPPER);
    }
    
    // Текст для текущего тренда
    if(ObjectFind(0, trend_text_id) < 0)
    {
        ObjectCreate(0, trend_text_id, OBJ_LABEL, 0, 0, 0);
        ObjectSetInteger(0, trend_text_id, OBJPROP_CORNER, InfoPanelCorner);
        ObjectSetInteger(0, trend_text_id, OBJPROP_XDISTANCE, title_x);
        ObjectSetInteger(0, trend_text_id, OBJPROP_YDISTANCE, trend_y);
        ObjectSetInteger(0, trend_text_id, OBJPROP_COLOR, InfoPanelTextColor);
        ObjectSetInteger(0, trend_text_id, OBJPROP_FONTSIZE, 8);
        ObjectSetInteger(0, trend_text_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, trend_text_id, OBJPROP_HIDDEN, true);
        ObjectSetString(0, trend_text_id, OBJPROP_TEXT, GetLocalizedText("trend") + ": " + GetLocalizedText("trend_sideways"));
        
        // Устанавливаем выравнивание текста
        if(InfoPanelCorner == CORNER_LEFT_UPPER || InfoPanelCorner == CORNER_LEFT_LOWER)
            ObjectSetInteger(0, trend_text_id, OBJPROP_ANCHOR, ANCHOR_RIGHT_UPPER);
    }
    
    // Текст для уровней зон перекупленности/перепроданности
    if(ObjectFind(0, zones_text_id) < 0)
    {
        ObjectCreate(0, zones_text_id, OBJ_LABEL, 0, 0, 0);
        ObjectSetInteger(0, zones_text_id, OBJPROP_CORNER, InfoPanelCorner);
        ObjectSetInteger(0, zones_text_id, OBJPROP_XDISTANCE, title_x);
        ObjectSetInteger(0, zones_text_id, OBJPROP_YDISTANCE, zones_y);
        ObjectSetInteger(0, zones_text_id, OBJPROP_COLOR, InfoPanelTextColor);
        ObjectSetInteger(0, zones_text_id, OBJPROP_FONTSIZE, 8);
        ObjectSetInteger(0, zones_text_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, zones_text_id, OBJPROP_HIDDEN, true);
        ObjectSetString(0, zones_text_id, OBJPROP_TEXT, GetLocalizedText("zones") + ": -");
        
        // Устанавливаем выравнивание текста
        if(InfoPanelCorner == CORNER_LEFT_UPPER || InfoPanelCorner == CORNER_LEFT_LOWER)
            ObjectSetInteger(0, zones_text_id, OBJPROP_ANCHOR, ANCHOR_RIGHT_UPPER);
    }
}

//+------------------------------------------------------------------+
//| Обновление информации на панели                                 |
//+------------------------------------------------------------------+
void UpdateInfoPanel(int bar_index, const datetime &time[])
{
    if(!ShowInfoPanel || bar_index <= 0)
        return;
        
    datetime current_time = TimeCurrent();
    
    // Обновляем панель не чаще, чем раз в указанное время
    if(current_time - last_update_time < update_frequency)
        return;
        
    last_update_time = current_time;
    
    // Расчёт и установка уровня риска с созданием переменной risk_text
    double risk_value = 0.0;
    ENUM_RISK_LEVEL risk_level = CalculateRiskLevel(bar_index, RiskAssessmentPeriod, risk_value);
    string risk_text = "";
    
    switch(risk_level)
    {
        case RISK_LOW:
            risk_text = GetLocalizedText("risk_assessment") + ": " + GetLocalizedText("risk_low");
            ObjectSetInteger(0, risk_text_id, OBJPROP_COLOR, clrLimeGreen);
            break;
        case RISK_MEDIUM:
            risk_text = GetLocalizedText("risk_assessment") + ": " + GetLocalizedText("risk_medium");
            ObjectSetInteger(0, risk_text_id, OBJPROP_COLOR, clrYellow);
            break;
        case RISK_HIGH:
            risk_text = GetLocalizedText("risk_assessment") + ": " + GetLocalizedText("risk_high");
            ObjectSetInteger(0, risk_text_id, OBJPROP_COLOR, clrTomato);
            break;
    }
    
    ObjectSetString(0, risk_text_id, OBJPROP_TEXT, risk_text);
    
    // Обновляем информацию о паттернах
    string patterns = "";
    bool has_patterns = false;
    
    // Проверяем последние 5 баров на наличие паттернов
    for(int i = bar_index; i >= MathMax(0, bar_index - 5); i--)
    {
        if(i < ArraySize(VFI_Buffer))
        {
            // Получим цены напрямую из буфера для проверки паттернов
            if(IsDoubleBottom(i, VFI_Length))
            {
                patterns += "W ";  // Double Bottom
                has_patterns = true;
            }
            
            if(IsDoubleTop(i, VFI_Length))
            {
                patterns += "M ";  // Double Top
                has_patterns = true;
            }
            
            // Добавьте здесь проверки на другие паттерны
        }
    }
    
    if(has_patterns)
        ObjectSetString(0, pattern_text_id, OBJPROP_TEXT, GetLocalizedText("detected_patterns") + ": " + patterns);
    else
        ObjectSetString(0, pattern_text_id, OBJPROP_TEXT, GetLocalizedText("detected_patterns") + ": " + GetLocalizedText("no_patterns_detected"));
    
    // Обновляем информацию о тренде
    double trend_strength = 0.0;
    ENUM_TREND_DIRECTION trend = DetermineTrend(bar_index, TrendPeriod, trend_strength);
    string trend_text = GetLocalizedText("trend") + ": ";
    
    switch(trend)
    {
        case TREND_UP:
            trend_text += GetLocalizedText("trend_up");
            ObjectSetInteger(0, trend_text_id, OBJPROP_COLOR, clrLimeGreen);
            break;
        case TREND_DOWN:
            trend_text += GetLocalizedText("trend_down");
            ObjectSetInteger(0, trend_text_id, OBJPROP_COLOR, clrTomato);
            break;
        case TREND_SIDEWAYS:
        default:
            trend_text += GetLocalizedText("trend_sideways");
            ObjectSetInteger(0, trend_text_id, OBJPROP_COLOR, InfoPanelTextColor);
            break;
    }
    
    // Добавляем информацию о силе тренда
    trend_text += " (" + GetLocalizedText("trend_strength") + ": " + DoubleToString(trend_strength * 100.0, 1) + "%)";
    ObjectSetString(0, trend_text_id, OBJPROP_TEXT, trend_text);
    
    // Обновляем информацию о зонах
    if(dynamic_overbought_level != 0 || dynamic_oversold_level != 0)
    {
        string zones_text = GetLocalizedText("zones") + ": " +
                          GetLocalizedText("overbought_level") + "=" + DoubleToString(dynamic_overbought_level, 2) +
                          ", " + GetLocalizedText("oversold_level") + "=" + DoubleToString(dynamic_oversold_level, 2);
        ObjectSetString(0, zones_text_id, OBJPROP_TEXT, zones_text);
    }
    else
    {
        ObjectSetString(0, zones_text_id, OBJPROP_TEXT, GetLocalizedText("zones") + ": -");
    }
    
    // Обновляем время
    ObjectSetString(0, datetime_text_id, OBJPROP_TEXT, GetLocalizedText("current_time") + ": " + 
                 TimeToString(TimeCurrent(), TIME_DATE | TIME_SECONDS));
}

//+------------------------------------------------------------------+
//| Расчет уровня риска                                            |
//+------------------------------------------------------------------+
ENUM_RISK_LEVEL CalculateRiskLevel(int bar_index, int period, double &risk_value)
{
    if(bar_index <= period || period <= 0)
    {
        risk_value = 0.5; // Средний риск по умолчанию
        return RISK_MEDIUM;
    }
    
    // Используем несколько метрик для оценки риска
    
    // 1. Волатильность
    double volatility = CalculateVolatility(bar_index, period);
    
    // 2. Тренд и его сила
    double trend_strength = 0;
    ENUM_TREND_DIRECTION trend = DetermineTrend(bar_index, period, trend_strength);
    
    // 3. Позиция относительно уровней перекупленности/перепроданности
    double overbought_oversold_factor = 0;
    if(dynamic_overbought_level != 0 && dynamic_oversold_level != 0)
    {
        double current_vfi = VFI_Buffer[bar_index];
        double range = dynamic_overbought_level - dynamic_oversold_level;
        if(range != 0)
        {
            // Нормализуем положение в диапазоне от 0 до 1
            double position = (current_vfi - dynamic_oversold_level) / range;
            // Преобразуем в фактор риска: чем ближе к крайним значениям, тем выше риск
            overbought_oversold_factor = 2.0 * MathAbs(position - 0.5);
        }
    }
    
        // 4. Расхождение между VFI и ценой (дивергенция)
    double divergence_factor = CalculateDivergenceFactor(bar_index, period);
    
    // Объединяем факторы с весами
    risk_value = 0.3 * volatility + 0.2 * trend_strength + 0.3 * overbought_oversold_factor + 0.2 * divergence_factor;
    
    // Ограничиваем значение от 0 до 1
    risk_value = MathMin(MathMax(risk_value, 0.0), 1.0);
    
    // Определяем уровень риска на основе значения
    if(risk_value < 0.33)
        return RISK_LOW;
    else if(risk_value < 0.66)
        return RISK_MEDIUM;
    else
        return RISK_HIGH;
}

//+------------------------------------------------------------------+
//| Расчет волатильности                                           |
//+------------------------------------------------------------------+
double CalculateVolatility(int bar_index, int period)
{
    if(bar_index <= period || period <= 0)
        return 0.5;
    
    // Рассчитываем стандартное отклонение VFI
    double sum = 0.0;
    double sum_sq = 0.0;
    int count = 0;
    
    for(int i = bar_index; i > bar_index - period && i >= 0; i--)
    {
        if(VFI_Buffer[i] != EMPTY_VALUE)
        {
            sum += VFI_Buffer[i];
            sum_sq += VFI_Buffer[i] * VFI_Buffer[i];
            count++;
        }
    }
    
    if(count < 2)
        return 0.5;
    
    double mean = sum / count;
    double variance = (sum_sq / count) - (mean * mean);
    
    // Избегаем отрицательных значений из-за ошибок округления
    variance = MathMax(0, variance);
    
    double std_dev = MathSqrt(variance);
    
    // Нормализуем волатильность на основе исторических данных
    // (можно было бы использовать ATR или другие методы)
    double norm_volatility = MathMin(std_dev / 0.5, 1.0);
    
    return norm_volatility;
}

//+------------------------------------------------------------------+
//| Расчет фактора дивергенции                                     |
//+------------------------------------------------------------------+
double CalculateDivergenceFactor(int bar_index, int period)
{
    if(bar_index <= period || period <= 0)
        return 0.0;
    
    // Упрощенный расчет дивергенции
    // Сравниваем направление движения VFI и цены
    double vfi_change = 0.0;
    double price_change = 0.0;
    
    if(bar_index < ArraySize(VFI_Buffer) && bar_index - period >= 0)
    {
        vfi_change = VFI_Buffer[bar_index] - VFI_Buffer[bar_index - period];
        
        // Получаем цены закрытия
        MqlRates rates[];
        if(CopyRates(Symbol(), PERIOD_CURRENT, bar_index - period, period + 1, rates) == period + 1)
        {
            price_change = rates[period].close - rates[0].close;
        }
    }
    
    // Если знаки изменений противоположны, есть дивергенция
    bool divergence = (vfi_change * price_change < 0);
    
    return divergence ? 0.8 : 0.2;
}

//+------------------------------------------------------------------+
//| Проверка на паттерн Двойное Дно                               |
//+------------------------------------------------------------------+
bool IsDoubleBottom(int bar_index, int lookback_period)
{
    if(bar_index < 20 || lookback_period <= 0)
        return false;
    
    int left_bottom = -1;
    int right_bottom = -1;
    double min_value = DBL_MAX;
    
    // Ищем первый минимум
    for(int i = bar_index - 15; i <= bar_index - 5; i++)
    {
        if(i < 0) continue;
        
        if(i < ArraySize(VFI_Buffer) && VFI_Buffer[i] != EMPTY_VALUE && 
           VFI_Buffer[i] < min_value && 
           (i == 0 || VFI_Buffer[i] < VFI_Buffer[i-1]) && 
           (i == ArraySize(VFI_Buffer)-1 || VFI_Buffer[i] < VFI_Buffer[i+1]))
        {
            min_value = VFI_Buffer[i];
            left_bottom = i;
        }
    }
    
    if(left_bottom == -1)
        return false;
    
    min_value = DBL_MAX;
    
    // Ищем второй минимум
    for(int i = bar_index - 5; i <= bar_index; i++)
    {
        if(i < 0) continue;
        
        if(i < ArraySize(VFI_Buffer) && VFI_Buffer[i] != EMPTY_VALUE && 
           VFI_Buffer[i] < min_value && 
           (i == 0 || VFI_Buffer[i] < VFI_Buffer[i-1]) && 
           (i == ArraySize(VFI_Buffer)-1 || VFI_Buffer[i] < VFI_Buffer[i+1]))
        {
            min_value = VFI_Buffer[i];
            right_bottom = i;
        }
    }
    
    if(right_bottom == -1 || left_bottom == right_bottom)
        return false;
    
    // Проверяем, что между минимумами есть локальный максимум
    double peak = VFI_Buffer[left_bottom];
    for(int i = left_bottom + 1; i < right_bottom; i++)
    {
        if(i < ArraySize(VFI_Buffer) && VFI_Buffer[i] != EMPTY_VALUE && VFI_Buffer[i] > peak)
            peak = VFI_Buffer[i];
    }
    
    // Минимальная высота паттерна
    double min_height = 0.2;
    
    // Проверка условий двойного дна
    bool valid_height = (peak - VFI_Buffer[left_bottom] > min_height) && (peak - VFI_Buffer[right_bottom] > min_height);
    bool similar_bottoms = MathAbs(VFI_Buffer[left_bottom] - VFI_Buffer[right_bottom]) < 0.1;
    
    return valid_height && similar_bottoms;
}

//+------------------------------------------------------------------+
//| Проверка на паттерн Двойная Вершина                            |
//+------------------------------------------------------------------+
bool IsDoubleTop(int bar_index, int lookback_period)
{
    if(bar_index < 20 || lookback_period <= 0)
        return false;
    
    int left_top = -1;
    int right_top = -1;
    double max_value = -DBL_MAX;
    
    // Ищем первый максимум
    for(int i = bar_index - 15; i <= bar_index - 5; i++)
    {
        if(i < 0) continue;
        
        if(i < ArraySize(VFI_Buffer) && VFI_Buffer[i] != EMPTY_VALUE && 
           VFI_Buffer[i] > max_value && 
           (i == 0 || VFI_Buffer[i] > VFI_Buffer[i-1]) && 
           (i == ArraySize(VFI_Buffer)-1 || VFI_Buffer[i] > VFI_Buffer[i+1]))
        {
            max_value = VFI_Buffer[i];
            left_top = i;
        }
    }
    
    if(left_top == -1)
        return false;
    
    max_value = -DBL_MAX;
    
    // Ищем второй максимум
    for(int i = bar_index - 5; i <= bar_index; i++)
    {
        if(i < 0) continue;
        
        if(i < ArraySize(VFI_Buffer) && VFI_Buffer[i] != EMPTY_VALUE && 
           VFI_Buffer[i] > max_value && 
           (i == 0 || VFI_Buffer[i] > VFI_Buffer[i-1]) && 
           (i == ArraySize(VFI_Buffer)-1 || VFI_Buffer[i] > VFI_Buffer[i+1]))
        {
            max_value = VFI_Buffer[i];
            right_top = i;
        }
    }
    
    if(right_top == -1 || left_top == right_top)
        return false;
    
    // Проверяем, что между максимумами есть локальный минимум
    double valley = VFI_Buffer[left_top];
    for(int i = left_top + 1; i < right_top; i++)
    {
        if(i < ArraySize(VFI_Buffer) && VFI_Buffer[i] != EMPTY_VALUE && VFI_Buffer[i] < valley)
            valley = VFI_Buffer[i];
    }
    
    // Минимальная высота паттерна
    double min_height = 0.2;
    
    // Проверка условий двойной вершины
    bool valid_height = (VFI_Buffer[left_top] - valley > min_height) && (VFI_Buffer[right_top] - valley > min_height);
    bool similar_tops = MathAbs(VFI_Buffer[left_top] - VFI_Buffer[right_top]) < 0.1;
    
    return valid_height && similar_tops;
}

//+------------------------------------------------------------------+
//| Custom indicator initialization function                         |
//+------------------------------------------------------------------+
int OnInit()
{
    // Determine system language first
    is_russian_system = IsRussianSystem();
    
    // Validate input parameters
    if(VFI_Length < 10)
    {
        Print("❌ ", GetLocalizedText("parameter_error"), ": ", GetLocalizedText("invalid_vfi_length"));
        return(INIT_PARAMETERS_INCORRECT);
    }
    
    if(SignalLength < 1)
    {
        Print("❌ ", GetLocalizedText("parameter_error"), ": ", GetLocalizedText("invalid_signal_length"));
        return(INIT_PARAMETERS_INCORRECT);
    }
    
    if(Coef <= 0 || VCoef <= 0)
    {
        Print("❌ ", GetLocalizedText("parameter_error"), ": ", GetLocalizedText("invalid_coefficients"));
        return(INIT_PARAMETERS_INCORRECT);
    }
    
    //--- indicator buffers mapping
    SetIndexBuffer(0, VFI_Buffer, INDICATOR_DATA);
    SetIndexBuffer(1, VFI_EMA_Buffer, INDICATOR_DATA);
    SetIndexBuffer(2, Histogram_Buffer, INDICATOR_DATA);
    SetIndexBuffer(3, Buy_Signal_Buffer, INDICATOR_DATA);
    SetIndexBuffer(4, Sell_Signal_Buffer, INDICATOR_DATA);
    SetIndexBuffer(5, DoubleBottom_Buffer, INDICATOR_DATA);
    SetIndexBuffer(6, DoubleTop_Buffer, INDICATOR_DATA);
    SetIndexBuffer(7, Divergence_Buffer, INDICATOR_DATA);
    SetIndexBuffer(8, Risk_Buffer, INDICATOR_DATA);
    SetIndexBuffer(9, Risk_Colors_Buffer, INDICATOR_COLOR_INDEX);
    SetIndexBuffer(10, VCP_Buffer, INDICATOR_CALCULATIONS);
    
    // Установка важного свойства для сохранения истории (!)
    PlotIndexSetInteger(0, PLOT_DRAW_BEGIN, VFI_Length);
    PlotIndexSetInteger(1, PLOT_DRAW_BEGIN, VFI_Length);
    PlotIndexSetInteger(2, PLOT_DRAW_BEGIN, VFI_Length);
    PlotIndexSetInteger(3, PLOT_DRAW_BEGIN, VFI_Length);
    PlotIndexSetInteger(4, PLOT_DRAW_BEGIN, VFI_Length);
    PlotIndexSetInteger(8, PLOT_DRAW_BEGIN, VFI_Length);
    
    // Arrow settings
    PlotIndexSetInteger(3, PLOT_ARROW, 233); // Buy signal arrow
    PlotIndexSetInteger(4, PLOT_ARROW, 234); // Sell signal arrow
    
    //--- set accuracy
    IndicatorSetInteger(INDICATOR_DIGITS, 4);
    
    //--- set short name
    IndicatorSetString(INDICATOR_SHORTNAME, "VFI_DubravaSPB(" + 
                      IntegerToString(VFI_Length) + "," + 
                      DoubleToString(Coef, 1) + "," + 
                      DoubleToString(VCoef, 1) + ")");
    
    //--- set zero level
    IndicatorSetDouble(INDICATOR_LEVELVALUE, 0, 0.0);
    
    //--- set empty values
    PlotIndexSetDouble(0, PLOT_EMPTY_VALUE, EMPTY_VALUE);
    PlotIndexSetDouble(1, PLOT_EMPTY_VALUE, EMPTY_VALUE);
    PlotIndexSetDouble(2, PLOT_EMPTY_VALUE, EMPTY_VALUE);
    PlotIndexSetDouble(3, PLOT_EMPTY_VALUE, EMPTY_VALUE);
    PlotIndexSetDouble(4, PLOT_EMPTY_VALUE, EMPTY_VALUE);
    PlotIndexSetDouble(5, PLOT_EMPTY_VALUE, EMPTY_VALUE);
    PlotIndexSetDouble(6, PLOT_EMPTY_VALUE, EMPTY_VALUE);
    PlotIndexSetDouble(7, PLOT_EMPTY_VALUE, EMPTY_VALUE);
    PlotIndexSetDouble(8, PLOT_EMPTY_VALUE, EMPTY_VALUE);
    
    //--- hide histogram if not needed
    if(!ShowHisto)
        PlotIndexSetInteger(2, PLOT_DRAW_TYPE, DRAW_NONE);
    else
        PlotIndexSetInteger(2, PLOT_DRAW_TYPE, DRAW_HISTOGRAM);
    
    //--- initialize calculation arrays with sufficient size
    int initial_size = 1000; // Задаем начальный размер с запасом
    ArrayResize(inter_array, initial_size);
    ArrayResize(typical_array, initial_size);
    ArrayResize(volatility_array, initial_size);
    ArrayResize(price_array, initial_size);
    ArrayResize(trend_buffer, initial_size);
    
    // Инициализируем массивы нулевыми значениями
    ArrayInitialize(inter_array, 0.0);
    ArrayInitialize(typical_array, 0.0);
    ArrayInitialize(volatility_array, 0.0);
    ArrayInitialize(price_array, 0.0);
    ArrayInitialize(trend_buffer, 0.0);
    
    // Сохраняем текущие параметры
    prev_vfi_length = VFI_Length;
    prev_coef = Coef;
    prev_vcoef = VCoef;
    prev_signal_length = SignalLength;
    prev_smooth_vfi = SmoothVFI;
    prev_show_histo = ShowHisto;
    prev_use_real_volume = UseRealVolume;
    
    // Инициализируем переменные
    indicator_load_time = TimeCurrent();
    session_start_time = indicator_load_time;
    
    // Сбрасываем счетчик баров при инициализации
    last_rates_total = 0;
    
    // Создаем информационную панель
    if(ShowInfoPanel)
        CreateInfoPanel();
    
    // Выводим информацию о настройках
    Print("--- VFI Pro Indicator Settings ---");
    Print(GetLocalizedText("indicator_settings"), ":");
    Print("  VFI Length: ", VFI_Length);
    Print("  Coefficient: ", Coef);
    Print("  Max Volume Cutoff: ", VCoef);
    Print("  Signal Length: ", SignalLength);
    Print("  Smooth VFI: ", SmoothVFI ? GetLocalizedText("yes") : GetLocalizedText("no"));
    Print("  Show Histogram: ", ShowHisto ? GetLocalizedText("yes") : GetLocalizedText("no"));
    Print("  Use Real Volume: ", UseRealVolume ? GetLocalizedText("yes") : GetLocalizedText("no"));
    Print("  Show Patterns: ", ShowPatterns ? GetLocalizedText("yes") : GetLocalizedText("no"));
    Print("  Alerts: ", EnableAlerts ? GetLocalizedText("yes") : GetLocalizedText("no"));
    Print("  Notifications: ", EnableNotifications ? GetLocalizedText("yes") : GetLocalizedText("no"));
    Print("  Dynamic Colors: ", EnableDynamicColors ? GetLocalizedText("yes") : GetLocalizedText("no"));
    Print("  Info Panel: ", ShowInfoPanel ? GetLocalizedText("yes") : GetLocalizedText("no"));
    
    // Запускаем проверку объемов
    CheckVolumeData();
    
    return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Проверка наличия и качества данных по объемам                   |
//+------------------------------------------------------------------+
void CheckVolumeData()
{
    string symbol = Symbol();
    string username = GetComputerUserName();
    string current_datetime = GetCurrentDateTime();
    
    Print(GetLocalizedText("volume_check_header"));
    Print(GetLocalizedText("symbol"), ": ", symbol);
    Print(GetLocalizedText("datetime"), ": ", current_datetime);
    Print(GetLocalizedText("user"), ": ", username);
    
    // Check execution type
    ENUM_SYMBOL_TRADE_EXECUTION execution = (ENUM_SYMBOL_TRADE_EXECUTION)SymbolInfoInteger(symbol, SYMBOL_TRADE_EXEMODE);
    string exec_type = "";
    switch(execution)
    {
        case SYMBOL_TRADE_EXECUTION_REQUEST: exec_type = "Request"; break;
        case SYMBOL_TRADE_EXECUTION_INSTANT: exec_type = "Instant"; break;
        case SYMBOL_TRADE_EXECUTION_MARKET: exec_type = "Market"; break;
        case SYMBOL_TRADE_EXECUTION_EXCHANGE: exec_type = "Exchange"; break;
        default: exec_type = "Unknown";
    }
    Print(GetLocalizedText("execution_type"), ": ", exec_type);
    
    // Get test data
    MqlRates rates[];
    int copied = CopyRates(symbol, PERIOD_CURRENT, 0, 30, rates);
    
    if(copied <= 0)
    {
        Print(GetLocalizedText("error_no_data"));
        return;
    }
    
    Print(GetLocalizedText("bars_analyzed"), ": ", copied);
    
    // Analyze tick volumes
    long total_tick_volume = 0;
    long max_tick_volume = 0;
    long min_tick_volume = LONG_MAX;
    int zero_tick_volumes = 0;
    
    // Analyze real volumes
    long total_real_volume = 0;
    long max_real_volume = 0;
    long min_real_volume = LONG_MAX;
    int zero_real_volumes = 0;
    bool has_real_volumes = false;
    
    // Оптимизированный цикл - обработка за один проход
    for(int i = 0; i < copied; i++)
    {
        // Tick volumes
        long tick_vol = rates[i].tick_volume;
        total_tick_volume += tick_vol;
        
        if(tick_vol == 0)
            zero_tick_volumes++;
            
        if(tick_vol > max_tick_volume)
            max_tick_volume = tick_vol;
            
        if(tick_vol < min_tick_volume && tick_vol > 0)
            min_tick_volume = tick_vol;
        
        // Real volumes
        long real_vol = rates[i].real_volume;
        if(real_vol > 0)
        {
            has_real_volumes = true;
            total_real_volume += real_vol;
            
            if(real_vol > max_real_volume)
                max_real_volume = real_vol;
                
            if(real_vol < min_real_volume)
                min_real_volume = real_vol;
        }
        else
        {
            zero_real_volumes++;
        }
    }
    
    // Tick volume results
    double avg_tick_volume = (double)total_tick_volume / copied;
    Print(GetLocalizedText("tick_volumes"), ":");
    Print("  ", GetLocalizedText("average"), ": ", (long)avg_tick_volume);
    Print("  ", GetLocalizedText("maximum"), ": ", max_tick_volume);
    Print("  ", GetLocalizedText("minimum"), ": ", min_tick_volume);
    Print("  ", GetLocalizedText("zero_bars"), ": ", zero_tick_volumes, " (", 
          MathRound(zero_tick_volumes * 100.0 / copied), "%)");
    
    // Real volume results
    real_volumes_available = has_real_volumes;
    if(has_real_volumes)
    {
        double avg_real_volume = (double)total_real_volume / (copied - zero_real_volumes);
        Print(GetLocalizedText("real_volumes"), ":");
        Print("  ", GetLocalizedText("average"), ": ", (long)avg_real_volume);
        Print("  ", GetLocalizedText("maximum"), ": ", max_real_volume);
        Print("  ", GetLocalizedText("minimum"), ": ", min_real_volume);
        Print("  ", GetLocalizedText("zero_bars"), ": ", zero_real_volumes, " (", 
              MathRound(zero_real_volumes * 100.0 / copied), "%)");
    }
    else
    {
        Print(GetLocalizedText("real_volumes_unavailable"));
    }
    
    // Data quality assessment
    string quality_assessment = "";
    string recommendation = "";
    
    if(!has_real_volumes && zero_tick_volumes > copied * 0.5)
    {
        quality_assessment = GetLocalizedText("critical_no_volumes");
        recommendation = GetLocalizedText("change_instrument");
    }
    else if(!has_real_volumes && (max_tick_volume - min_tick_volume) < avg_tick_volume * 0.1)
    {
        quality_assessment = GetLocalizedText("poor_no_variation");
        recommendation = GetLocalizedText("may_work_incorrectly");
    }
    else if(!has_real_volumes)
    {
        quality_assessment = GetLocalizedText("satisfactory_tick_only");
        recommendation = GetLocalizedText("will_work_less_accurate");
    }
    else if(has_real_volumes && zero_real_volumes < copied * 0.1)
    {
        quality_assessment = GetLocalizedText("excellent_real_volumes");
        recommendation = GetLocalizedText("will_work_max_accurate");
    }
    else
    {
        quality_assessment = GetLocalizedText("good_real_gaps");
        recommendation = GetLocalizedText("will_work_correctly");
    }
    
    Print(GetLocalizedText("quality_assessment"), ": ", quality_assessment);
    Print(GetLocalizedText("recommendation"), ": ", recommendation);
}

//+------------------------------------------------------------------+
//| Custom indicator iteration function                              |
//+------------------------------------------------------------------+
int OnCalculate(const int rates_total,
                const int prev_calculated,
                const datetime &time[],
                const double &open[],
                const double &high[],
                const double &low[],
                const double &close[],
                const long &tick_volume[],
                const long &volume[],
                const int &spread[])
{
    // Проверяем наличие минимального количества данных
    if(rates_total <= 0)
        return(0);
    
    // Минимальное количество баров для расчета
    int min_bars = VFI_Length + 50;
    if(rates_total < min_bars)
        return(0);
    
    // Проверяем, изменились ли параметры
    parameters_changed = false;
    if(prev_vfi_length != VFI_Length || 
       prev_coef != Coef || 
       prev_vcoef != VCoef || 
       prev_signal_length != SignalLength || 
       prev_smooth_vfi != SmoothVFI ||
       prev_show_histo != ShowHisto ||
       prev_use_real_volume != UseRealVolume)
    {
        parameters_changed = true;
        prev_vfi_length = VFI_Length;
        prev_coef = Coef;
        prev_vcoef = VCoef;
        prev_signal_length = SignalLength;
        prev_smooth_vfi = SmoothVFI;
        prev_show_histo = ShowHisto;
        prev_use_real_volume = UseRealVolume;
    }
    
    // Определяем, произошел ли сброс буфера (например, из-за прокрутки графика)
    bool buffer_reset = false;
    
    // Проверка, изменилось ли количество баров необычным образом
    if(last_rates_total > 0)
    {
        // Стандартная ситуация - добавление новых баров
        if(rates_total > last_rates_total)
        {
            if(rates_total - last_rates_total > 10) // если добавлено более 10 баров за раз, возможно это сброс
            {
                buffer_reset = true;
                Print(GetLocalizedText("buffer_reset"));
            }
        }
        else if(rates_total < last_rates_total)
        {
            // График был сжат или что-то подобное, нужен полный пересчет
            buffer_reset = true;
        }
        
        // Проверка первого значения буфера на сброс (EMPTY_VALUE)
        if(!buffer_reset && rates_total > 0)
        {
            // Проверяем только первые несколько баров
            for(int i = 0; i < MathMin(5, rates_total); i++)
            {
                if(VFI_Buffer[i] == EMPTY_VALUE && i < last_rates_total - 1)
                {
                    buffer_reset = true;
                    Print(GetLocalizedText("buffer_reset"), " at bar ", i);
                    break;
                }
            }
        }
    }
    
    // Сохраняем текущее количество баров для следующего вызова
    last_rates_total = rates_total;
    
    // Определяем, нужен ли полный пересчет
    bool recalculate_all = (prev_calculated <= 0 || parameters_changed || buffer_reset);
    
    // Выводим сообщение только при необходимости
    if(recalculate_all && (first_run || parameters_changed || buffer_reset))
    {
        if(parameters_changed)
            Print(" ", GetLocalizedText("settings_changed"));
        else if(buffer_reset)
            Print(" ", GetLocalizedText("buffer_reset"));
        first_run = false;
    }
    
    //--- resize calculation arrays if needed
    if(ArraySize(inter_array) < rates_total + 10)
    {
        int new_size = rates_total + 100; // Добавляем запас в 100 элементов
        ArrayResize(inter_array, new_size);
        ArrayResize(typical_array, new_size);
        ArrayResize(volatility_array, new_size);
        ArrayResize(price_array, new_size);
        ArrayResize(trend_buffer, new_size);
    }
    
    int calc_start;
    if(recalculate_all)
    {
        calc_start = 1;
        
        // Инициализируем буферы
        ArrayInitialize(VFI_Buffer, EMPTY_VALUE);
        ArrayInitialize(VFI_EMA_Buffer, EMPTY_VALUE);
        ArrayInitialize(Histogram_Buffer, EMPTY_VALUE);
        ArrayInitialize(Buy_Signal_Buffer, EMPTY_VALUE);
        ArrayInitialize(Sell_Signal_Buffer, EMPTY_VALUE);
        ArrayInitialize(DoubleBottom_Buffer, EMPTY_VALUE);
        ArrayInitialize(DoubleTop_Buffer, EMPTY_VALUE);
        ArrayInitialize(Divergence_Buffer, EMPTY_VALUE);
        ArrayInitialize(Risk_Buffer, EMPTY_VALUE);
        ArrayInitialize(Risk_Colors_Buffer, 0);
        ArrayInitialize(VCP_Buffer, 0.0);
        
        // Инициализируем расчетные массивы
        ArrayInitialize(inter_array, 0.0);
        ArrayInitialize(typical_array, 0.0);
        ArrayInitialize(volatility_array, 0.0);
        ArrayInitialize(price_array, 0.0);
        ArrayInitialize(trend_buffer, 0.0);
    }
    else
    {
        // Начинаем расчет только с нового бара
        calc_start = prev_calculated - 1;
        if(calc_start < 1) calc_start = 1;
    }
    
    // Проверяем, что массивы имеют нужный размер
    if(ArraySize(VFI_Buffer) < rates_total || 
       ArraySize(VFI_EMA_Buffer) < rates_total || 
       ArraySize(Histogram_Buffer) < rates_total || 
       ArraySize(VCP_Buffer) < rates_total)
    {
        Print("Error: Buffer sizes are smaller than rates_total");
        return(0);
    }
    
    // Оптимизация 1: Предварительно вычисляем типичные цены
    for(int i = calc_start; i < rates_total; i++)
    {
        // Проверяем валидность цен
        if(high[i] <= 0 || low[i] <= 0 || close[i] <= 0)
        {
            typical_array[i] = i > 0 ? typical_array[i-1] : close[i];
        }
        else
        {
            typical_array[i] = (high[i] + low[i] + close[i]) / 3.0;
        }
        
        // Сохраняем цены закрытия для использования в паттернах
        price_array[i] = close[i];
        
        // Вычисляем logarithm difference
        if(i > 0 && typical_array[i-1] > 0 && typical_array[i] > 0)
        {
            double log_diff = MathLog(typical_array[i]) - MathLog(typical_array[i-1]);
            // Ограничиваем экстремальные значения
            if(MathAbs(log_diff) > 1.0)
                log_diff = log_diff > 0 ? 1.0 : -1.0;
            inter_array[i] = log_diff;
        }
        else
        {
            inter_array[i] = 0.0;
        }
    }
    
    int start;
    if(recalculate_all)
    {
        start = min_bars;
        // При полном пересчете инициализируем начальные значения
        for(int i = 0; i < start && i < rates_total; i++)
        {
            VFI_Buffer[i] = EMPTY_VALUE;
            VFI_EMA_Buffer[i] = EMPTY_VALUE;
            Histogram_Buffer[i] = EMPTY_VALUE;
            Buy_Signal_Buffer[i] = EMPTY_VALUE;
            Sell_Signal_Buffer[i] = EMPTY_VALUE;
            Risk_Buffer[i] = EMPTY_VALUE;
            Risk_Colors_Buffer[i] = 0;
        }
    }
    else
    {
        // Начинаем расчет с последнего рассчитанного бара
        start = prev_calculated - 1;
        if(start < min_bars) start = min_bars;
    }
    
    // Оптимизация 2: Определяем, какие объемы использовать
    bool use_real = UseRealVolume && real_volumes_available;
    
    // Оптимизация 3: Избегаем многократных вычислений внутри цикла
    double alpha = 2.0 / (SignalLength + 1.0);
    double one_minus_alpha = 1.0 - alpha;
    
    //--- main calculation loop - оптимизированный
    for(int i = start; i < rates_total; i++)
    {
        //--- calculate vinter (standard deviation of inter over 30 periods)
        double vinter = CalculateStdDev(inter_array, i, MathMin(30, i));
        
        // Защита от слишком маленьких значений
        if(vinter < 0.0001)
            vinter = 0.0001;
        
        //--- calculate cutoff
        double cutoff = Coef * vinter * close[i];
        
        //--- Оптимизация 4: Использование более эффективного алгоритма расчета средних
        //--- calculate volume average over VFI_Length periods
        double vave = 0.0;
        int vol_start = MathMax(0, i - VFI_Length);
        int vol_count = 0;
        
        // Оптимизированный подсчет среднего объема
        for(int j = vol_start; j < i; j++)
        {
            double vol_value = use_real ? (double)volume[j] : (double)tick_volume[j];
            if(vol_value > 0) // Исключаем нулевые объемы
            {
                vave += vol_value;
                vol_count++;
            }
        }
        
        // Защита от деления на ноль
        if(vol_count > 0)
            vave /= (double)vol_count;
        else
            vave = use_real ? (double)volume[i] : (double)tick_volume[i];
            
        if(vave <= 0)
            vave = 1.0; // Минимальное значение
        
        //--- calculate vmax
        double vmax = vave * VCoef;
        
        //--- calculate vc (min of current volume and vmax)
        double vol_current = use_real ? (double)volume[i] : (double)tick_volume[i];
        if(vol_current <= 0)
            vol_current = vave; // Используем среднее значение
            
        double vc = MathMin(vol_current, vmax);
        
        //--- calculate mf (money flow)
        double mf = 0.0;
        if(i > 0)
            mf = typical_array[i] - typical_array[i-1];
        
        //--- calculate vcp - оптимизировано с использованием тернарного оператора
        double vcp = mf > cutoff ? vc : (mf < -cutoff ? -vc : 0.0);
        VCP_Buffer[i] = vcp;
        
        //--- calculate VFI (sum of vcp over VFI_Length periods divided by vave)
        double vcp_sum = 0.0;
        int vcp_start = MathMax(0, i - VFI_Length + 1);
        
        for(int j = vcp_start; j <= i; j++)
        {
            vcp_sum += VCP_Buffer[j];
        }
        
        // Дополнительная защита от больших значений
        double vfi_raw = vcp_sum / vave;
        
        // Оптимизация 6: Быстрое ограничение значений
        if(vfi_raw > 1000)
            vfi_raw = 1000;
        else if(vfi_raw < -1000)
            vfi_raw = -1000;
        
        //--- apply smoothing if needed (SMA with period 3)
        if(SmoothVFI && i >= start + 2)
        {
            // Оптимизация 7: Более эффективное сглаживание
            double vfi_sum = vfi_raw;
            int count = 1;
            
            for(int j = 1; j <= 2 && (i-j) >= start; j++)
            {
                if(VFI_Buffer[i-j] != EMPTY_VALUE)
                {
                    vfi_sum += VFI_Buffer[i-j];
                    count++;
                }
            }
            
            VFI_Buffer[i] = vfi_sum / count;
        }
        else
        {
            VFI_Buffer[i] = vfi_raw;
        }
        
        //--- calculate VFI EMA - оптимизированное с предварительно рассчитанной alpha
        if(i == start || VFI_EMA_Buffer[i-1] == EMPTY_VALUE)
        {
            VFI_EMA_Buffer[i] = VFI_Buffer[i];
        }
        else
        {
            VFI_EMA_Buffer[i] = alpha * VFI_Buffer[i] + one_minus_alpha * VFI_EMA_Buffer[i-1];
        }
        
        //--- calculate histogram - оптимизировано с использованием тернарного оператора
        Histogram_Buffer[i] = ShowHisto ? VFI_Buffer[i] - VFI_EMA_Buffer[i] : EMPTY_VALUE;
        
        //--- Generate signals
        GenerateSignals(i);
        
        //--- Calculate risk level
        double risk_value = 0.0;
        ENUM_RISK_LEVEL risk_level = CalculateRiskLevel(i, RiskAssessmentPeriod, risk_value);
        Risk_Buffer[i] = risk_value * 0.5; // Масштабируем для отображения
        Risk_Colors_Buffer[i] = (int)risk_level;
    }
    
    // Расчет и обновление уровней перекупленности/перепроданности
    CalculateOverboughtOversoldLevels(rates_total - 1);
    
    // Обновление инфо панели
    if(ShowInfoPanel)
        UpdateInfoPanel(rates_total - 1, time);
    
    return(rates_total);
}

//+------------------------------------------------------------------+
//| Calculate Standard Deviation                                    |
//+------------------------------------------------------------------+
double CalculateStdDev(const double &array[], int pos, int period)
{
    if(pos < 1 || period < 1)
        return(0.0001); // Минимальное значение вместо 0
    
    int actual_period = MathMin(period, pos + 1);
    int start_pos = pos - actual_period + 1;
    
    //--- calculate mean & sum of squares in one loop
    double sum = 0.0;
    double sum_sq = 0.0;
    int valid_count = 0;
    
    for(int i = start_pos; i <= pos; i++)
    {
        if(i >= 0 && i < ArraySize(array))
        {
            double val = array[i];
            sum += val;
            sum_sq += val * val;
            valid_count++;
        }
    }
    
    if(valid_count == 0)
        return(0.0001);
        
    double mean = sum / valid_count;
    
    // Fast calculation of variance using E(X²) - (E(X))²
    double variance = (sum_sq / valid_count) - (mean * mean);
    
    // Avoid negative values due to rounding errors
    if(variance < 0)
        variance = 0;
    
    return MathMax(MathSqrt(variance), 0.0001);
}

//+------------------------------------------------------------------+
//| Генерация сигналов                                             |
//+------------------------------------------------------------------+
void GenerateSignals(int i)
{
    // Должно быть хотя бы несколько баров истории
    if(i <= 5) 
        return;
    
    // Buy signal: VFI crosses its EMA upward
    bool buy_signal = false;
    if(VFI_Buffer[i] > VFI_EMA_Buffer[i] && 
       VFI_Buffer[i-1] <= VFI_EMA_Buffer[i-1])
    {
        buy_signal = true;
        Buy_Signal_Buffer[i] = VFI_Buffer[i] - 0.05; // Размещаем стрелку немного ниже линии
        
        if(EnableAlerts && i == ArraySize(VFI_Buffer) - 1)
            SendAlert(GetLocalizedText("buy_signal_detected"), TimeGMT());
    }
    
    // Sell signal: VFI crosses its EMA downward
    bool sell_signal = false;
    if(VFI_Buffer[i] < VFI_EMA_Buffer[i] && 
       VFI_Buffer[i-1] >= VFI_EMA_Buffer[i-1])
    {
        sell_signal = true;
        Sell_Signal_Buffer[i] = VFI_Buffer[i] + 0.05; // Размещаем стрелку немного выше линии
        
        if(EnableAlerts && i == ArraySize(VFI_Buffer) - 1)
            SendAlert(GetLocalizedText("sell_signal_detected"), TimeGMT());
    }
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
    string username = GetComputerUserName();
    string current_datetime = GetCurrentDateTime();
    
    Print(GetLocalizedText("indicator_finished"));
    Print(GetLocalizedText("reason"), ": ", reason);
    Print(GetLocalizedText("time"), ": ", current_datetime);
    Print(GetLocalizedText("user"), ": ", username);
    
    // Удаляем все созданные объекты
    ObjectDelete(0, info_panel_id);
    ObjectDelete(0, pattern_text_id);
    ObjectDelete(0, datetime_text_id);
    ObjectDelete(0, username_text_id);
    ObjectDelete(0, risk_text_id);
    ObjectDelete(0, trend_text_id);
    ObjectDelete(0, zones_text_id);
    ObjectDelete(0, info_panel_id + "_Title");
    
    ObjectDelete(0, overbought_zone_id);
    ObjectDelete(0, oversold_zone_id);
    ObjectDelete(0, overbought_line_id);
    ObjectDelete(0, oversold_line_id);
}
