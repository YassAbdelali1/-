//+------------------------------------------------------------------+
//|                                                 |
//|                        Copyright 2025, MetaQuotes Software Corp. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Dubravaspb"
#property link      "https://www.mql5.com"
#property version   "1.02"
#property description "Advanced implementation of Dubravaspb's Volume Flow Indicator with comprehensive analysis tools featuring buy/sell signals with customizable parameters, pattern recognition, rea"
#property indicator_separate_window
#property indicator_buffers 11
#property indicator_plots   9

//--- plot VFI
#property indicator_label1  "VFI"
#property indicator_type1   DRAW_LINE
#property indicator_color1  clrGreen
#property indicator_style1  STYLE_SOLID
#property indicator_width1  2

//--- plot VFI EMA
#property indicator_label2  "EMA of VFI"
#property indicator_type2   DRAW_LINE
#property indicator_color2  clrOrange
#property indicator_style2  STYLE_SOLID
#property indicator_width2  1

//--- plot Histogram
#property indicator_label3  "Histogram"
#property indicator_type3   DRAW_HISTOGRAM
#property indicator_color3  clrGray
#property indicator_style3  STYLE_SOLID
#property indicator_width3  3

//--- plot Buy Signal
#property indicator_label4  "Buy Signal"
#property indicator_type4   DRAW_ARROW
#property indicator_color4  clrLime
#property indicator_style4  STYLE_SOLID
#property indicator_width4  2

//--- plot Sell Signal
#property indicator_label5  "Sell Signal"
#property indicator_type5   DRAW_ARROW
#property indicator_color5  clrRed
#property indicator_style5  STYLE_SOLID
#property indicator_width5  2

//--- plot Risk Level
#property indicator_label9  "Risk Level"
#property indicator_type9   DRAW_COLOR_HISTOGRAM
#property indicator_color9  clrGreen, clrYellow, clrRed
#property indicator_style9  STYLE_SOLID
#property indicator_width9  2

//--- input parameters
input int      VFI_Length = 130;        // VFI length
input double   Coef = 0.2;              // Coefficient
input double   VCoef = 2.5;             // Max. vol. cutoff
input int      SignalLength = 5;        // Signal length
input bool     SmoothVFI = false;       // Smooth VFI
input bool     ShowHisto = false;       // Show Histogram
input bool     UseRealVolume = false;   // Use Real Volume (if available)
input bool     ShowPatterns = true;     // Enable Pattern Detection (now for display only)
input bool     EnableAlerts = true;     // Enable Sound Alerts
input bool     EnableNotifications = false; // Enable Push Notifications
input bool     EnableDynamicColors = true;  // Enable Dynamic Colors

// –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ç—Ä–µ–Ω–¥–∞ –∏ –∑–æ–Ω –ø–µ—Ä–µ–∫—É–ø–ª–µ–Ω–Ω–æ—Å—Ç–∏/–ø–µ—Ä–µ–ø—Ä–æ–¥–∞–Ω–Ω–æ—Å—Ç–∏
input int      TrendPeriod = 20;        // The period for determining the trend
input int      TrendSmoothingPeriod = 5; // Smoothing period to determine the trend
input int      ZonesAutoCalculationPeriod = 200; // The period for automatic zone calculation
input double   ZonePercentile = 80.0;   // Percentile for zones (80% = upper/lower 20%)
input color    OverboughtColor = clrRed; // The color of the overbought zone
input color    OversoldColor = clrGreen; // Oversold zone color
input int      ZoneTransparency = 80;   // Transparency of zones (0-255, where 0=transparent, 255=opaque)

// –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π –ø–∞–Ω–µ–ª–∏
input bool     ShowInfoPanel = true;    // Show Information Panel
input ENUM_BASE_CORNER InfoPanelCorner = CORNER_LEFT_UPPER; // Info Panel Corner
input int      InfoPanelX = 10;         // Info Panel X Distance
input int      InfoPanelY = 10;         // Info Panel Y Distance
input int      InfoPanelWidth = 200;    // Info Panel Width
input int      InfoPanelHeight = 140;   // Info Panel Height (—É–≤–µ–ª–∏—á–µ–Ω–∞ –¥–ª—è —Ç—Ä–µ–Ω–¥–∞)
input color    InfoPanelColor = clrDarkBlue; // Info Panel Background Color
input color    InfoPanelTextColor = clrWhite; // Info Panel Text Color

input int      RiskAssessmentPeriod = 14;   // Risk Assessment Period

//--- indicator buffers
double VFI_Buffer[];
double VFI_EMA_Buffer[];
double Histogram_Buffer[];
double VCP_Buffer[];
double Buy_Signal_Buffer[];
double Sell_Signal_Buffer[];
double DoubleBottom_Buffer[];
double DoubleTop_Buffer[];
double Divergence_Buffer[];
double Risk_Buffer[];
double Risk_Colors_Buffer[];

//--- arrays for calculations
double inter_array[];
double typical_array[];
double volatility_array[];
double price_array[];
double trend_buffer[];         // –ë—É—Ñ–µ—Ä –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –æ —Ç—Ä–µ–Ω–¥–µ

//--- global variables
bool real_volumes_available = false;
bool is_russian_system = false;
int alert_delay = 300; // 5 –º–∏–Ω—É—Ç –º–µ–∂–¥—É –∞–ª–µ—Ä—Ç–∞–º–∏
datetime indicator_load_time = 0;  // –í—Ä–µ–º—è –∑–∞–≥—Ä—É–∑–∫–∏ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞
datetime last_alert_time = 0;

// –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
static int prev_vfi_length = -1;
static double prev_coef = -1;
static double prev_vcoef = -1;
static int prev_signal_length = -1;
static bool prev_smooth_vfi = false;
static bool prev_show_histo = false;
static bool prev_use_real_volume = false;
static bool parameters_changed = false;

// –î–æ–±–∞–≤–ª—è–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –±–∞—Ä–æ–≤
static int last_rates_total = 0;
static bool first_run = true;

// –î–ª—è –º–∏–Ω–∏-–¥–∏—Å–ø–ª–µ—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
string info_panel_id = "VFI_InfoPanel";
string pattern_text_id = "VFI_PatternText";
string datetime_text_id = "VFI_DatetimeText";
string username_text_id = "VFI_UsernameText";
string risk_text_id = "VFI_RiskText";
string trend_text_id = "VFI_TrendText";    // –¢–µ–∫—Å—Ç–æ–≤—ã–π –æ–±—ä–µ–∫—Ç –¥–ª—è —Ç—Ä–µ–Ω–¥–∞
string zones_text_id = "VFI_ZonesText";    // –¢–µ–∫—Å—Ç–æ–≤—ã–π –æ–±—ä–µ–∫—Ç –¥–ª—è –∑–æ–Ω
datetime last_update_time = 0;
int update_frequency = 5; // –û–±–Ω–æ–≤–ª—è—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∫–∞–∂–¥—ã–µ 5 —Å–µ–∫—É–Ω–¥

// –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —É—Ä–æ–≤–Ω–µ–π –ø–µ—Ä–µ–∫—É–ø–ª–µ–Ω–Ω–æ—Å—Ç–∏/–ø–µ—Ä–µ–ø—Ä–æ–¥–∞–Ω–Ω–æ—Å—Ç–∏
double dynamic_overbought_level = 0;
double dynamic_oversold_level = 0;
datetime last_zone_calculation = 0;
int zone_calculation_delay = 300; // 5 –º–∏–Ω—É—Ç –º–µ–∂–¥—É –ø–µ—Ä–µ—Å—á–µ—Ç–∞–º–∏

// –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã –æ–±—ä–µ–∫—Ç–æ–≤ –∑–æ–Ω
string overbought_zone_id = "VFI_Overbought_Zone";
string oversold_zone_id = "VFI_Oversold_Zone";
string overbought_line_id = "VFI_Overbought_Line";
string oversold_line_id = "VFI_Oversold_Line";

// Enum –¥–ª—è —É—Ä–æ–≤–Ω–µ–π —Ä–∏—Å–∫–∞
enum ENUM_RISK_LEVEL
{
    RISK_LOW = 0,    // –ù–∏–∑–∫–∏–π —Ä–∏—Å–∫ (–∑–µ–ª–µ–Ω—ã–π)
    RISK_MEDIUM = 1, // –°—Ä–µ–¥–Ω–∏–π —Ä–∏—Å–∫ (–∂–µ–ª—Ç—ã–π)
    RISK_HIGH = 2    // –í—ã—Å–æ–∫–∏–π —Ä–∏—Å–∫ (–∫—Ä–∞—Å–Ω—ã–π)
};

// Enum –¥–ª—è –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ç—Ä–µ–Ω–¥–∞
enum ENUM_TREND_DIRECTION
{
    TREND_UP = 1,       // –í–æ—Å—Ö–æ–¥—è—â–∏–π —Ç—Ä–µ–Ω–¥
    TREND_DOWN = -1,    // –ù–∏—Å—Ö–æ–¥—è—â–∏–π —Ç—Ä–µ–Ω–¥
    TREND_SIDEWAYS = 0  // –ë–æ–∫–æ–≤–æ–π —Ç—Ä–µ–Ω–¥
};

// –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Å–µ—Å—Å–∏–∏
datetime session_start_time = 0;

//+------------------------------------------------------------------+
//| –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —è–∑—ã–∫–∞ —Å–∏—Å—Ç–µ–º—ã                                       |
//+------------------------------------------------------------------+
bool IsRussianSystem()
{
    // –ü–æ–ª—É—á–∞–µ–º —è–∑—ã–∫ —Ç–µ—Ä–º–∏–Ω–∞–ª–∞
    string terminal_language = TerminalInfoString(TERMINAL_LANGUAGE);
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —è–∑—ã–∫ —Ä—É—Å—Å–∫–∏–º
    if(terminal_language == "Russian" || terminal_language == "–†—É—Å—Å–∫–∏–π" || 
       StringFind(terminal_language, "RU") >= 0 || StringFind(terminal_language, "ru") >= 0)
    {
        return true;
    }
    
    // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —á–µ—Ä–µ–∑ –ª–æ–∫–∞–ª–∏–∑–∞—Ü–∏—é —á–∏—Å–µ–ª
    string test_number = DoubleToString(1.5, 1);
    if(StringFind(test_number, ",") >= 0) // –í —Ä—É—Å—Å–∫–æ–π –ª–æ–∫–∞–ª–∏ –¥–µ—Å—è—Ç–∏—á–Ω—ã–π —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å - –∑–∞–ø—è—Ç–∞—è
    {
        return true;
    }
    
    return false;
}

//+------------------------------------------------------------------+
//| –ü–æ–ª—É—á–µ–Ω–∏–µ –ª–æ–∫–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞                                |
//+------------------------------------------------------------------+
string GetLocalizedText(string key)
{
    if(!is_russian_system)
    {
        // English texts
        if(key == "volume_check_header") return "           VFI INDICATOR VOLUME CHECK           ";
        if(key == "symbol") return "Symbol";
        if(key == "datetime") return "Date/time";
        if(key == "user") return "User";
        if(key == "execution_type") return "Execution type";
        if(key == "terminal_paths") return "DEBUG - Terminal paths";
        if(key == "bars_analyzed") return "Bars analyzed";
        if(key == "tick_volumes") return "TICK VOLUMES";
        if(key == "average") return "Average";
        if(key == "maximum") return "Maximum";
        if(key == "minimum") return "Minimum";
        if(key == "zero_bars") return "Bars with zero volume";
        if(key == "real_volumes") return "REAL VOLUMES";
        if(key == "real_volumes_unavailable") return "REAL VOLUMES: Unavailable";
        if(key == "quality_assessment") return "QUALITY ASSESSMENT";
        if(key == "recommendation") return "RECOMMENDATION";
        if(key == "indicator_settings") return "INDICATOR SETTINGS";
        if(key == "will_use_real") return "Will use: REAL VOLUMES";
        if(key == "will_use_tick") return "Will use: TICK VOLUMES";
        if(key == "yes") return "YES";
        if(key == "no") return "NO";
        if(key == "error_no_data") return "‚ùå ERROR: Could not get price data!";
        if(key == "critical_no_volumes") return "‚ùå CRITICAL: Very little volume data";
        if(key == "poor_no_variation") return "‚ö†Ô∏è POOR: Volumes hardly change";
        if(key == "satisfactory_tick_only") return "‚ö†Ô∏è SATISFACTORY: Tick volumes only";
        if(key == "excellent_real_volumes") return "‚úÖ EXCELLENT: Quality real volumes";
        if(key == "good_real_gaps") return "‚úÖ GOOD: Real volumes with gaps";
        if(key == "change_instrument") return "Change instrument or broker";
        if(key == "may_work_incorrectly") return "Indicator may work incorrectly";
        if(key == "will_work_less_accurate") return "Indicator will work, but less accurately";
        if(key == "will_work_max_accurate") return "Indicator will work with maximum accuracy";
        if(key == "will_work_correctly") return "Indicator will work correctly";
        if(key == "indicator_finished") return "         VFI INDICATOR FINISHED WORK         ";
        if(key == "reason") return "Reason";
        if(key == "time") return "Time";
        if(key == "parameter_error") return "Parameter Error";
        if(key == "invalid_vfi_length") return "VFI_Length must be >= 10";
        if(key == "invalid_signal_length") return "SignalLength must be >= 1";
        if(key == "invalid_coefficients") return "Coefficients must be positive";
        if(key == "settings_changed") return "Settings changed - recalculating all data";
        if(key == "buffer_reset") return "Buffer reset detected - recalculating";
        if(key == "buy_signals_enabled") return "Buy signals enabled";
        if(key == "sell_signals_enabled") return "Sell signals enabled";
        if(key == "pattern_recognition_enabled") return "Pattern recognition enabled";
        if(key == "alerts_enabled") return "Alerts enabled";
        if(key == "notifications_enabled") return "Push notifications enabled";
        if(key == "dynamic_colors_enabled") return "Dynamic colors enabled";
        if(key == "info_panel_enabled") return "Information panel enabled";
        if(key == "buy_signal_detected") return "VFI Buy Signal detected";
        if(key == "sell_signal_detected") return "VFI Sell Signal detected";
        if(key == "double_bottom_detected") return "Double Bottom pattern detected";
        if(key == "double_top_detected") return "Double Top pattern detected";
        if(key == "divergence_detected") return "Divergence pattern detected";
        if(key == "risk_assessment") return "Risk Level";
        if(key == "risk_low") return "Low";
        if(key == "risk_medium") return "Medium";
        if(key == "risk_high") return "High";
        if(key == "current_user") return "Current User";
        if(key == "current_time") return "Current Time";
        if(key == "detected_patterns") return "Detected Patterns";
        if(key == "no_patterns_detected") return "No patterns detected";
        if(key == "panel_title") return "VFI Info Panel";
        // –¢–µ–∫—Å—Ç—ã –¥–ª—è —Ç—Ä–µ–Ω–¥–∞
        if(key == "trend") return "Trend";
        if(key == "trend_up") return "Uptrend";
        if(key == "trend_down") return "Downtrend";
        if(key == "trend_sideways") return "Sideways";
        if(key == "trend_strength") return "Strength";
        if(key == "overbought_zones") return "Overbought zones enabled";
        if(key == "oversold_zones") return "Oversold zones enabled";
        // –¢–µ–∫—Å—Ç—ã –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –∑–æ–Ω
        if(key == "auto_zones") return "Auto zones calculation enabled";
        if(key == "overbought_level") return "Overbought level";
        if(key == "oversold_level") return "Oversold level";
        if(key == "zones") return "Zones";
        if(key == "recalculating_zones") return "Recalculating zone levels";
        // –¢–µ–∫—Å—Ç—ã –¥–ª—è —Å–µ—Å—Å–∏–∏
        if(key == "minutes") return "min";
        if(key == "hours") return "h";
        if(key == "days") return "d";
    }
    else
    {
        // Russian texts
        if(key == "volume_check_header") return "           –ü–†–û–í–ï–†–ö–ê –û–ë–™–ï–ú–û–í VFI –ò–ù–î–ò–ö–ê–¢–û–†–ê           ";
        if(key == "symbol") return "–°–∏–º–≤–æ–ª";
        if(key == "datetime") return "–î–∞—Ç–∞/–≤—Ä–µ–º—è";
        if(key == "user") return "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å";
        if(key == "execution_type") return "–¢–∏–ø –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è";
        if(key == "terminal_paths") return "DEBUG - –ü—É—Ç–∏ —Ç–µ—Ä–º–∏–Ω–∞–ª–∞";
        if(key == "bars_analyzed") return "–ü–æ–ª—É—á–µ–Ω–æ –±–∞—Ä–æ–≤ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞";
        if(key == "tick_volumes") return "–¢–ò–ö–û–í–´–ï –û–ë–™–ï–ú–´";
        if(key == "average") return "–°—Ä–µ–¥–Ω–∏–π";
        if(key == "maximum") return "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π";
        if(key == "minimum") return "–ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π";
        if(key == "zero_bars") return "–ë–∞—Ä–æ–≤ —Å –Ω—É–ª–µ–≤—ã–º –æ–±—ä–µ–º–æ–º";
        if(key == "real_volumes") return "–†–ï–ê–õ–¨–ù–´–ï –û–ë–™–ï–ú–´";
        if(key == "real_volumes_unavailable") return "–†–ï–ê–õ–¨–ù–´–ï –û–ë–™–ï–ú–´: –ù–µ–¥–æ—Å—Ç—É–ø–Ω—ã";
        if(key == "quality_assessment") return "–û–¶–ï–ù–ö–ê –ö–ê–ß–ï–°–¢–í–ê";
        if(key == "recommendation") return "–†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø";
        if(key == "indicator_settings") return "–ù–ê–°–¢–†–û–ô–ö–ò –ò–ù–î–ò–ö–ê–¢–û–†–ê";
        if(key == "will_use_real") return "–ë—É–¥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω—ã: –†–ï–ê–õ–¨–ù–´–ï –û–ë–™–ï–ú–´";
        if(key == "will_use_tick") return "–ë—É–¥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω—ã: –¢–ò–ö–û–í–´–ï –û–ë–™–ï–ú–´";
        if(key == "yes") return "–î–ê";
        if(key == "no") return "–ù–ï–¢";
        if(key == "error_no_data") return "‚ùå –û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –ø–æ —Ü–µ–Ω–∞–º!";
        if(key == "critical_no_volumes") return "‚ùå –ö–†–ò–¢–ò–ß–ù–û: –û—á–µ–Ω—å –º–∞–ª–æ –¥–∞–Ω–Ω—ã—Ö –ø–æ –æ–±—ä–µ–º–∞–º";
        if(key == "poor_no_variation") return "‚ö†Ô∏è –ü–õ–û–•–û: –û–±—ä–µ–º—ã –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –Ω–µ –º–µ–Ω—è—é—Ç—Å—è";
        if(key == "satisfactory_tick_only") return "‚ö†Ô∏è –£–î–û–í–õ–ï–¢–í–û–†–ò–¢–ï–õ–¨–ù–û: –¢–æ–ª—å–∫–æ —Ç–∏–∫–æ–≤—ã–µ –æ–±—ä–µ–º—ã";
        if(key == "excellent_real_volumes") return "‚úÖ –û–¢–õ–ò–ß–ù–û: –ö–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ —Ä–µ–∞–ª—å–Ω—ã–µ –æ–±—ä–µ–º—ã";
        if(key == "good_real_gaps") return "‚úÖ –•–û–†–û–®–û: –†–µ–∞–ª—å–Ω—ã–µ –æ–±—ä–µ–º—ã —Å –ø—Ä–æ–ø—É—Å–∫–∞–º–∏";
        if(key == "change_instrument") return "–°–º–µ–Ω–∏—Ç–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –∏–ª–∏ –±—Ä–æ–∫–µ—Ä–∞";
        if(key == "may_work_incorrectly") return "–ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ";
        if(key == "will_work_less_accurate") return "–ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –±—É–¥–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å, –Ω–æ –º–µ–Ω–µ–µ —Ç–æ—á–Ω–æ";
        if(key == "will_work_max_accurate") return "–ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –±—É–¥–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ —Ç–æ—á–Ω–æ";
        if(key == "will_work_correctly") return "–ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –±—É–¥–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ";
        if(key == "indicator_finished") return "         VFI –ò–ù–î–ò–ö–ê–¢–û–† –ó–ê–í–ï–†–®–ò–õ –†–ê–ë–û–¢–£         ";
        if(key == "reason") return "–ü—Ä–∏—á–∏–Ω–∞";
        if(key == "time") return "–í—Ä–µ–º—è";
        if(key == "parameter_error") return "–û—à–∏–±–∫–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤";
        if(key == "invalid_vfi_length") return "VFI_Length –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å >= 10";
        if(key == "invalid_signal_length") return "SignalLength –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å >= 1";
        if(key == "invalid_coefficients") return "–ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º–∏";
        if(key == "settings_changed") return "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–∑–º–µ–Ω–µ–Ω—ã - –ø–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º –≤—Å–µ –¥–∞–Ω–Ω—ã–µ";
        if(key == "buffer_reset") return "–û–±–Ω–∞—Ä—É–∂–µ–Ω —Å–±—Ä–æ—Å –±—É—Ñ–µ—Ä–∞ - –ø–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º";
        if(key == "buy_signals_enabled") return "–°–∏–≥–Ω–∞–ª—ã –ø–æ–∫—É–ø–∫–∏ –≤–∫–ª—é—á–µ–Ω—ã";
        if(key == "sell_signals_enabled") return "–°–∏–≥–Ω–∞–ª—ã –ø—Ä–æ–¥–∞–∂–∏ –≤–∫–ª—é—á–µ–Ω—ã";
        if(key == "pattern_recognition_enabled") return "–†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤ –≤–∫–ª—é—á–µ–Ω–æ";
        if(key == "alerts_enabled") return "–ó–≤—É–∫–æ–≤—ã–µ –∞–ª–µ—Ä—Ç—ã –≤–∫–ª—é—á–µ–Ω—ã";
        if(key == "notifications_enabled") return "Push-—É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤–∫–ª—é—á–µ–Ω—ã";
        if(key == "dynamic_colors_enabled") return "–î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ —Ü–≤–µ—Ç–∞ –≤–∫–ª—é—á–µ–Ω—ã";
        if(key == "info_panel_enabled") return "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–∞—è –ø–∞–Ω–µ–ª—å –≤–∫–ª—é—á–µ–Ω–∞";
        if(key == "buy_signal_detected") return "–û–±–Ω–∞—Ä—É–∂–µ–Ω —Å–∏–≥–Ω–∞–ª –ø–æ–∫—É–ø–∫–∏ VFI";
        if(key == "sell_signal_detected") return "–û–±–Ω–∞—Ä—É–∂–µ–Ω —Å–∏–≥–Ω–∞–ª –ø—Ä–æ–¥–∞–∂–∏ VFI";
        if(key == "double_bottom_detected") return "–û–±–Ω–∞—Ä—É–∂–µ–Ω –ø–∞—Ç—Ç–µ—Ä–Ω –î–≤–æ–π–Ω–æ–µ –î–Ω–æ";
        if(key == "double_top_detected") return "–û–±–Ω–∞—Ä—É–∂–µ–Ω –ø–∞—Ç—Ç–µ—Ä–Ω –î–≤–æ–π–Ω–∞—è –í–µ—Ä—à–∏–Ω–∞";
        if(key == "divergence_detected") return "–û–±–Ω–∞—Ä—É–∂–µ–Ω –ø–∞—Ç—Ç–µ—Ä–Ω –î–∏–≤–µ—Ä–≥–µ–Ω—Ü–∏—è";
        if(key == "risk_assessment") return "–£—Ä–æ–≤–µ–Ω—å —Ä–∏—Å–∫–∞";
        if(key == "risk_low") return "–ù–∏–∑–∫–∏–π";
        if(key == "risk_medium") return "–°—Ä–µ–¥–Ω–∏–π";
        if(key == "risk_high") return "–í—ã—Å–æ–∫–∏–π";
        if(key == "current_user") return "–¢–µ–∫—É—â–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å";
        if(key == "current_time") return "–¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è";
        if(key == "detected_patterns") return "–û–±–Ω–∞—Ä—É–∂–µ–Ω–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã";
        if(key == "no_patterns_detected") return "–ü–∞—Ç—Ç–µ—Ä–Ω—ã –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã";
        if(key == "panel_title") return "VFI –ò–Ω—Ñ–æ –ü–∞–Ω–µ–ª—å";
        // –¢–µ–∫—Å—Ç—ã –¥–ª—è —Ç—Ä–µ–Ω–¥–∞
        if(key == "trend") return "–¢—Ä–µ–Ω–¥";
        if(key == "trend_up") return "–í–æ—Å—Ö–æ–¥—è—â–∏–π";
        if(key == "trend_down") return "–ù–∏—Å—Ö–æ–¥—è—â–∏–π";
        if(key == "trend_sideways") return "–ë–æ–∫–æ–≤–æ–π";
        if(key == "trend_strength") return "–°–∏–ª–∞";
        if(key == "overbought_zones") return "–ó–æ–Ω—ã –ø–µ—Ä–µ–∫—É–ø–ª–µ–Ω–Ω–æ—Å—Ç–∏ –≤–∫–ª—é—á–µ–Ω—ã";
        if(key == "oversold_zones") return "–ó–æ–Ω—ã –ø–µ—Ä–µ–ø—Ä–æ–¥–∞–Ω–Ω–æ—Å—Ç–∏ –≤–∫–ª—é—á–µ–Ω—ã";
        // –¢–µ–∫—Å—Ç—ã –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –∑–æ–Ω
        if(key == "auto_zones") return "–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Ä–∞—Å—á–µ—Ç –∑–æ–Ω –≤–∫–ª—é—á–µ–Ω";
        if(key == "overbought_level") return "–£—Ä–æ–≤–µ–Ω—å –ø–µ—Ä–µ–∫—É–ø–ª–µ–Ω–Ω–æ—Å—Ç–∏";
        if(key == "oversold_level") return "–£—Ä–æ–≤–µ–Ω—å –ø–µ—Ä–µ–ø—Ä–æ–¥–∞–Ω–Ω–æ—Å—Ç–∏";
        if(key == "zones") return "–ó–æ–Ω—ã";
        if(key == "recalculating_zones") return "–ü–µ—Ä–µ—Å—á—ë—Ç —É—Ä–æ–≤–Ω–µ–π –∑–æ–Ω";
        // –¢–µ–∫—Å—Ç—ã –¥–ª—è —Å–µ—Å—Å–∏–∏
        if(key == "minutes") return "–º–∏–Ω";
        if(key == "hours") return "—á";
        if(key == "days") return "–¥";
    }
    
    return key;
}

//+------------------------------------------------------------------+
//| –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–º–µ–Ω–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∫–æ–º–ø—å—é—Ç–µ—Ä–∞                         |
//+------------------------------------------------------------------+
string GetComputerUserName()
{
    return "YassAbdelali1"; // –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
}

//+------------------------------------------------------------------+
//| –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–π –¥–∞—Ç—ã –∏ –≤—Ä–µ–º–µ–Ω–∏                                |
//+------------------------------------------------------------------+
string GetCurrentDateTime()
{
    return "2025-07-31 21:23:37"; // –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞—Ç–∞ –∏ –≤—Ä–µ–º—è
}

//+------------------------------------------------------------------+
//| –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ —Ä–∞–±–æ—Ç—ã —Å–µ—Å—Å–∏–∏                                 |
//+------------------------------------------------------------------+
string GetSessionUptime()
{
    if(session_start_time == 0)
        return "00:00";
    
    datetime current_time = TimeGMT();
    int uptime_seconds = (int)(current_time - session_start_time);
    
    int days = uptime_seconds / 86400;
    uptime_seconds %= 86400;
    int hours = uptime_seconds / 3600;
    uptime_seconds %= 3600;
    int minutes = uptime_seconds / 60;
    
    string uptime_str = "";
    
    if(days > 0)
        uptime_str += IntegerToString(days) + GetLocalizedText("days") + " ";
    if(hours > 0)
        uptime_str += IntegerToString(hours) + GetLocalizedText("hours") + " ";
    
    uptime_str += IntegerToString(minutes) + GetLocalizedText("minutes");
    
    return uptime_str;
}

//+------------------------------------------------------------------+
//| Send Alert Function                                             |
//+------------------------------------------------------------------+
void SendAlert(string message, datetime signal_time)
{
    datetime current_time = TimeCurrent();
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø—Ä–æ—à–ª–æ –ª–∏ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –≤—Ä–µ–º–µ–Ω–∏ —Å –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –∞–ª–µ—Ä—Ç–∞
    if(current_time - last_alert_time < alert_delay)
        return;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Å–∏–≥–Ω–∞–ª –æ—Ç–Ω–æ—Å–∏—Ç—Å—è –∫ —Ç–µ–∫—É—â–µ–º—É –∏–ª–∏ –ø—Ä–µ–¥—ã–¥—É—â–µ–º—É –±–∞—Ä—É
    int current_bar = iBarShift(Symbol(), PERIOD_CURRENT, signal_time);
    if(current_bar > 1) // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Å–∏–≥–Ω–∞–ª—ã —Å—Ç–∞—Ä—à–µ 1 –±–∞—Ä–∞
        return;
        
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—Ä–µ–º—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –∞–ª–µ—Ä—Ç–∞
    last_alert_time = current_time;
    
    // –í—ã–≤–æ–¥–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –∂—É—Ä–Ω–∞–ª
    Print(message);
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–≤—É–∫–æ–≤–æ–π –∞–ª–µ—Ä—Ç
    if(EnableAlerts)
        Alert(message);
        
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º push-—É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
    if(EnableNotifications)
        SendNotification(message);
}

//+------------------------------------------------------------------+
//| –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Ä–∞—Å—á–µ—Ç —É—Ä–æ–≤–Ω–µ–π –ø–µ—Ä–µ–∫—É–ø–ª–µ–Ω–Ω–æ—Å—Ç–∏/–ø–µ—Ä–µ–ø—Ä–æ–¥–∞–Ω–Ω–æ—Å—Ç–∏  |
//+------------------------------------------------------------------+
void CalculateOverboughtOversoldLevels(int bar_pos)
{
    if(bar_pos < ZonesAutoCalculationPeriod)
        return;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–ª–∏—à–∫–æ–º –ª–∏ —á–∞—Å—Ç–æ –ø–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º –∑–æ–Ω—ã
    datetime current_time = TimeCurrent();
    if(current_time - last_zone_calculation < zone_calculation_delay && dynamic_overbought_level != 0)
        return;
        
    last_zone_calculation = current_time;
    
    // –°–æ–±–∏—Ä–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –∑–Ω–∞—á–µ–Ω–∏—è–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞
    double vfi_values[];
    ArrayResize(vfi_values, ZonesAutoCalculationPeriod);
    
    int count = 0;
    for(int i = bar_pos; i > bar_pos - ZonesAutoCalculationPeriod && i >= 0; i--)
    {
        if(VFI_Buffer[i] != EMPTY_VALUE)
        {
            vfi_values[count] = VFI_Buffer[i];
            count++;
        }
    }
    
    // –ï—Å–ª–∏ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö, –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    if(count < ZonesAutoCalculationPeriod / 2)
    {
        // –ó–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        dynamic_overbought_level = 1.0;
        dynamic_oversold_level = -1.0;
        Print("Warning: Not enough data to calculate zones, using default values");
        return;
    }
    
    // –ü–æ–¥–≥–æ–Ω—è–µ–º —Ä–∞–∑–º–µ—Ä –º–∞—Å—Å–∏–≤–∞ –ø–æ–¥ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ–∞–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
    ArrayResize(vfi_values, count);
    
    // –°–æ—Ä—Ç–∏—Ä—É–µ–º –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ø—Ä–æ—Ü–µ–Ω—Ç–∏–ª–µ–π
    ArraySort(vfi_values);
    
    // –í—ã—á–∏—Å–ª—è–µ–º –ø–æ–∑–∏—Ü–∏–∏ –ø—Ä–æ—Ü–µ–Ω—Ç–∏–ª–µ–π
    int upper_pos = (int)((count - 1) * ZonePercentile / 100.0);
    int lower_pos = (int)((count - 1) * (100.0 - ZonePercentile) / 100.0);
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –∏–Ω–¥–µ–∫—Å–æ–≤
    if(upper_pos >= count) upper_pos = count - 1;
    if(lower_pos < 0) lower_pos = 0;
    
    // –û–±–Ω–æ–≤–ª—è–µ–º —É—Ä–æ–≤–Ω–∏
    dynamic_overbought_level = vfi_values[upper_pos];
    dynamic_oversold_level = vfi_values[lower_pos];
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ overbought > oversold
    if(dynamic_overbought_level <= dynamic_oversold_level)
    {
        // –ï—Å–ª–∏ —á—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ä–µ–¥–Ω–µ–µ –∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ
        double sum = 0, sum_sq = 0;
        for(int i = 0; i < count; i++)
        {
            sum += vfi_values[i];
            sum_sq += MathPow(vfi_values[i], 2);
        }
        double mean = sum / count;
        double std_dev = MathSqrt(sum_sq / count - mean * mean);
        
        dynamic_overbought_level = mean + 1.5 * std_dev;
        dynamic_oversold_level = mean - 1.5 * std_dev;
    }
    
    Print("üîÑ ", GetLocalizedText("recalculating_zones"), ": OB=", 
          DoubleToString(dynamic_overbought_level, 4), ", OS=", 
          DoubleToString(dynamic_oversold_level, 4));
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –æ–±—ä–µ–∫—Ç—ã –∑–æ–Ω –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
    UpdateZoneObjects(bar_pos);
}

//+------------------------------------------------------------------+
//| –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤ –∑–æ–Ω                                        |
//+------------------------------------------------------------------+
void UpdateZoneObjects(int bar_pos)
{
    // Force removal of old objects
    ObjectDelete(0, overbought_zone_id);
    ObjectDelete(0, oversold_zone_id);
    ObjectDelete(0, overbought_line_id);
    ObjectDelete(0, oversold_line_id);
    
    // If levels aren't calculated or are 0, set base values
    if(dynamic_overbought_level == 0 || dynamic_oversold_level == 0)
    {
        dynamic_overbought_level = 1.0;
        dynamic_oversold_level = -1.0;
    }
    
    // Get indicator window
    int window = ChartWindowFind();
    if(window < 0) return;
    
    // Get chart boundaries
    double chart_max = 0, chart_min = 0;
    ChartGetDouble(0, CHART_PRICE_MAX, window, chart_max);
    ChartGetDouble(0, CHART_PRICE_MIN, window, chart_min);
    
    // Calculate boundaries if not available
    if(chart_max <= 0 || chart_min >= 0)
    {
        chart_max = MathMax(2.0, dynamic_overbought_level * 1.5);
        chart_min = MathMin(-2.0, dynamic_oversold_level * 1.5);
        
        // Find max/min indicator values
        double max_value = -DBL_MAX;
        double min_value = DBL_MAX;
        
        for(int i = bar_pos; i >= MathMax(0, bar_pos - 500); i--)
        {
            if(VFI_Buffer[i] != EMPTY_VALUE)
            {
                if(VFI_Buffer[i] > max_value) max_value = VFI_Buffer[i];
                if(VFI_Buffer[i] < min_value) min_value = VFI_Buffer[i];
            }
        }
        
        chart_max = MathMax(chart_max, max_value * 1.2);
        chart_min = MathMin(chart_min, min_value * 1.2);
    }
    
    // Time coordinates
    datetime time_start, time_end;
    
    // Check if we're in the strategy tester
    bool is_tester = MQLInfoInteger(MQL_TESTER);
    
    if(is_tester)
    {
        // In strategy tester, use fixed range relative to visible bars
        int first_visible_bar = ChartGetInteger(0, CHART_FIRST_VISIBLE_BAR);
        int window_bars = ChartGetInteger(0, CHART_VISIBLE_BARS);
        
        // Get time for start and end based on visible chart range
        time_start = iTime(Symbol(), PERIOD_CURRENT, first_visible_bar);
        time_end = iTime(Symbol(), PERIOD_CURRENT, MathMax(0, first_visible_bar - window_bars));
        
        // If time values are invalid, use a fallback approach
        if(time_start <= 0 || time_end <= 0)
        {
            time_start = iTime(Symbol(), PERIOD_CURRENT, MathMin(bar_pos, 100));
            time_end = TimeCurrent() + 86400; // Add one day for display to the right
        }
    }
    else
    {
        // Normal chart mode
        time_start = iTime(Symbol(), PERIOD_CURRENT, MathMin(bar_pos, 100));
        time_end = TimeCurrent() + 86400; // Add one day for display to the right
    }
    
    // Fallback if times are still invalid
    if(time_start <= 0) time_start = TimeCurrent() - 86400 * 10;
    if(time_end <= 0 || time_end <= time_start) time_end = time_start + 86400 * 30;
    
    // Create horizontal lines for levels
    if(ObjectCreate(0, overbought_line_id, OBJ_TREND, window, time_start, dynamic_overbought_level, 
                                                       time_end, dynamic_overbought_level))
    {
        ObjectSetInteger(0, overbought_line_id, OBJPROP_COLOR, OverboughtColor);
        ObjectSetInteger(0, overbought_line_id, OBJPROP_STYLE, STYLE_DASH);
        ObjectSetInteger(0, overbought_line_id, OBJPROP_WIDTH, 1);
        ObjectSetInteger(0, overbought_line_id, OBJPROP_RAY_RIGHT, false);
        ObjectSetInteger(0, overbought_line_id, OBJPROP_RAY_LEFT, false);
        ObjectSetInteger(0, overbought_line_id, OBJPROP_BACK, true);
        ObjectSetInteger(0, overbought_line_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, overbought_line_id, OBJPROP_SELECTED, false);
        ObjectSetInteger(0, overbought_line_id, OBJPROP_HIDDEN, true);
    }
    
    if(ObjectCreate(0, oversold_line_id, OBJ_TREND, window, time_start, dynamic_oversold_level, 
                                                    time_end, dynamic_oversold_level))
    {
        ObjectSetInteger(0, oversold_line_id, OBJPROP_COLOR, OversoldColor);
        ObjectSetInteger(0, oversold_line_id, OBJPROP_STYLE, STYLE_DASH);
        ObjectSetInteger(0, oversold_line_id, OBJPROP_WIDTH, 1);
        ObjectSetInteger(0, oversold_line_id, OBJPROP_RAY_RIGHT, false);
        ObjectSetInteger(0, oversold_line_id, OBJPROP_RAY_LEFT, false);
        ObjectSetInteger(0, oversold_line_id, OBJPROP_BACK, true);
        ObjectSetInteger(0, oversold_line_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, oversold_line_id, OBJPROP_SELECTED, false);
        ObjectSetInteger(0, oversold_line_id, OBJPROP_HIDDEN, true);
    }
    
    // Create zone fills
    if(ObjectCreate(0, overbought_zone_id, OBJ_RECTANGLE, window, 
                   time_start, dynamic_overbought_level, time_end, chart_max))
    {
        ObjectSetInteger(0, overbought_zone_id, OBJPROP_COLOR, OverboughtColor);
        ObjectSetInteger(0, overbought_zone_id, OBJPROP_FILL, true);
        ObjectSetInteger(0, overbought_zone_id, OBJPROP_BGCOLOR, OverboughtColor);
        ObjectSetInteger(0, overbought_zone_id, OBJPROP_BACK, true);
        ObjectSetInteger(0, overbought_zone_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, overbought_zone_id, OBJPROP_SELECTED, false);
        ObjectSetInteger(0, overbought_zone_id, OBJPROP_HIDDEN, true);
        ObjectSetInteger(0, overbought_zone_id, OBJPROP_WIDTH, 1);
        ObjectSetInteger(0, overbought_zone_id, OBJPROP_ZORDER, 0);
    }
    
    if(ObjectCreate(0, oversold_zone_id, OBJ_RECTANGLE, window, 
                   time_start, chart_min, time_end, dynamic_oversold_level))
    {
        ObjectSetInteger(0, oversold_zone_id, OBJPROP_COLOR, OversoldColor);
        ObjectSetInteger(0, oversold_zone_id, OBJPROP_FILL, true);
        ObjectSetInteger(0, oversold_zone_id, OBJPROP_BGCOLOR, OversoldColor);
        ObjectSetInteger(0, oversold_zone_id, OBJPROP_BACK, true);
        ObjectSetInteger(0, oversold_zone_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, oversold_zone_id, OBJPROP_SELECTED, false);
        ObjectSetInteger(0, oversold_zone_id, OBJPROP_HIDDEN, true);
        ObjectSetInteger(0, oversold_zone_id, OBJPROP_WIDTH, 1);
        ObjectSetInteger(0, oversold_zone_id, OBJPROP_ZORDER, 0);
    }
}

//+------------------------------------------------------------------+
//| –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç—Ä–µ–Ω–¥–∞                                             |
//+------------------------------------------------------------------+
ENUM_TREND_DIRECTION DetermineTrend(int bar_pos, int period, double &strength)
{
    if(bar_pos <= period || ArraySize(VFI_Buffer) <= period)
        return TREND_SIDEWAYS;
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–∫–æ–ª—å–∑—è—â–µ–µ —Å—Ä–µ–¥–Ω–µ–µ VFI –¥–ª—è –±–æ–ª–µ–µ –≥–ª–∞–¥–∫–æ–≥–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ç—Ä–µ–Ω–¥–∞
    double ma_current = 0, ma_previous = 0;
    int valid_bars = 0;
    
    // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º SMA –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –ø–µ—Ä–∏–æ–¥–∞
    for(int i = 0; i < TrendSmoothingPeriod; i++)
    {
        if(bar_pos - i >= 0 && VFI_Buffer[bar_pos - i] != EMPTY_VALUE)
        {
            ma_current += VFI_Buffer[bar_pos - i];
            valid_bars++;
        }
    }
    
    if(valid_bars > 0)
        ma_current /= valid_bars;
    else
        return TREND_SIDEWAYS;
    
    // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º SMA –¥–ª—è –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –ø–µ—Ä–∏–æ–¥–∞
    valid_bars = 0;
    for(int i = period; i < period + TrendSmoothingPeriod; i++)
    {
        if(bar_pos - i >= 0 && VFI_Buffer[bar_pos - i] != EMPTY_VALUE)
        {
            ma_previous += VFI_Buffer[bar_pos - i];
            valid_bars++;
        }
    }
    
    if(valid_bars > 0)
        ma_previous /= valid_bars;
    else
        return TREND_SIDEWAYS;
    
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ç—Ä–µ–Ω–¥–∞
    double diff = ma_current - ma_previous;
    
    // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º —Å–∏–ª—É —Ç—Ä–µ–Ω–¥–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –∑–∞ –ø–µ—Ä–∏–æ–¥
    double max_diff = 0;
    for(int i = 0; i < period; i++)
    {
        if(bar_pos - i >= 0 && bar_pos - i - 1 >= 0)
        {
            double bar_diff = MathAbs(VFI_Buffer[bar_pos - i] - VFI_Buffer[bar_pos - i - 1]);
            if(bar_diff > max_diff)
                max_diff = bar_diff;
        }
    }
    
    // –°–∏–ª–∞ —Ç—Ä–µ–Ω–¥–∞ - –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –æ—Ç 0 –¥–æ 1
    if(max_diff > 0)
        strength = MathMin(MathAbs(diff) / max_diff, 1.0);
    else
        strength = 0;
    
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –±–æ–∫–æ–≤–æ–π —Ç—Ä–µ–Ω–¥ –ø—Ä–∏ –º–∞–ª—ã—Ö –∏–∑–º–µ–Ω–µ–Ω–∏—è—Ö
    if(MathAbs(diff) < 0.05)
        return TREND_SIDEWAYS;
        
    if(diff > 0)
        return TREND_UP;
    else
        return TREND_DOWN;
}

//+------------------------------------------------------------------+
//| –°–æ–∑–¥–∞–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–π –ø–∞–Ω–µ–ª–∏                                  |
//+------------------------------------------------------------------+
void CreateInfoPanel()
{
    if(!ShowInfoPanel)
        return;
    
    // –°–æ–∑–¥–∞–µ–º —Ñ–æ–Ω –ø–∞–Ω–µ–ª–∏
    if(ObjectFind(0, info_panel_id) < 0)
    {
        ObjectCreate(0, info_panel_id, OBJ_RECTANGLE_LABEL, 0, 0, 0);
        ObjectSetInteger(0, info_panel_id, OBJPROP_CORNER, InfoPanelCorner);
        ObjectSetInteger(0, info_panel_id, OBJPROP_XDISTANCE, InfoPanelX);
        ObjectSetInteger(0, info_panel_id, OBJPROP_YDISTANCE, InfoPanelY);
        ObjectSetInteger(0, info_panel_id, OBJPROP_XSIZE, InfoPanelWidth);
        ObjectSetInteger(0, info_panel_id, OBJPROP_YSIZE, InfoPanelHeight);
        ObjectSetInteger(0, info_panel_id, OBJPROP_BGCOLOR, InfoPanelColor);
        ObjectSetInteger(0, info_panel_id, OBJPROP_BORDER_TYPE, BORDER_FLAT);
        ObjectSetInteger(0, info_panel_id, OBJPROP_COLOR, InfoPanelTextColor);
        ObjectSetInteger(0, info_panel_id, OBJPROP_STYLE, STYLE_SOLID);
        ObjectSetInteger(0, info_panel_id, OBJPROP_WIDTH, 1);
        ObjectSetInteger(0, info_panel_id, OBJPROP_BACK, false);
        ObjectSetInteger(0, info_panel_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, info_panel_id, OBJPROP_SELECTED, false);
        ObjectSetInteger(0, info_panel_id, OBJPROP_HIDDEN, true);
        ObjectSetInteger(0, info_panel_id, OBJPROP_ZORDER, 1);
    }
    
    // –ê–¥–∞–ø—Ç–∏—Ä—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —É–≥–ª–∞
    int title_x, title_y, dt_y, user_y, risk_y, pattern_y, trend_y, zones_y;
    
    // –°–æ–∑–¥–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫ –ø–∞–Ω–µ–ª–∏
    string title_id = info_panel_id + "_Title";
    if(ObjectFind(0, title_id) < 0)
    {
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —É–≥–ª–∞
        switch(InfoPanelCorner)
        {
            case CORNER_LEFT_UPPER:
            case CORNER_RIGHT_UPPER:
                title_y = 15;
                dt_y = 35;
                user_y = 55;
                risk_y = 75;
                pattern_y = 95;
                trend_y = 115;
                zones_y = 135;
                break;
            case CORNER_LEFT_LOWER:
            case CORNER_RIGHT_LOWER:
                title_y = InfoPanelHeight - 15;
                dt_y = InfoPanelHeight - 35;
                user_y = InfoPanelHeight - 55;
                risk_y = InfoPanelHeight - 75;
                pattern_y = InfoPanelHeight - 95;
                trend_y = InfoPanelHeight - 115;
                zones_y = InfoPanelHeight - 135;
                break;
        }
        
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º X –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—É –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —É–≥–ª–∞
        switch(InfoPanelCorner)
        {
            case CORNER_LEFT_UPPER:
            case CORNER_LEFT_LOWER:
                title_x = InfoPanelWidth - 10;
                break;
            case CORNER_RIGHT_UPPER:
            case CORNER_RIGHT_LOWER:
                title_x = 10;
                break;
        }
        
        // –°–æ–∑–¥–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫
        ObjectCreate(0, title_id, OBJ_LABEL, 0, 0, 0);
        ObjectSetInteger(0, title_id, OBJPROP_CORNER, InfoPanelCorner);
        ObjectSetInteger(0, title_id, OBJPROP_XDISTANCE, title_x);
        ObjectSetInteger(0, title_id, OBJPROP_YDISTANCE, title_y);
        ObjectSetInteger(0, title_id, OBJPROP_COLOR, InfoPanelTextColor);
        ObjectSetInteger(0, title_id, OBJPROP_FONTSIZE, 10);
        ObjectSetInteger(0, title_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, title_id, OBJPROP_HIDDEN, true);
        ObjectSetString(0, title_id, OBJPROP_TEXT, GetLocalizedText("panel_title"));
        ObjectSetString(0, title_id, OBJPROP_FONT, "Arial Bold");
        
        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞
        if(InfoPanelCorner == CORNER_LEFT_UPPER || InfoPanelCorner == CORNER_LEFT_LOWER)
            ObjectSetInteger(0, title_id, OBJPROP_ANCHOR, ANCHOR_RIGHT_UPPER);
    }
    
    // –¢–µ–∫—Å—Ç –¥–ª—è –¥–∞—Ç—ã –∏ –≤—Ä–µ–º–µ–Ω–∏
    if(ObjectFind(0, datetime_text_id) < 0)
    {
        ObjectCreate(0, datetime_text_id, OBJ_LABEL, 0, 0, 0);
        ObjectSetInteger(0, datetime_text_id, OBJPROP_CORNER, InfoPanelCorner);
        ObjectSetInteger(0, datetime_text_id, OBJPROP_XDISTANCE, title_x);
        ObjectSetInteger(0, datetime_text_id, OBJPROP_YDISTANCE, dt_y);
        ObjectSetInteger(0, datetime_text_id, OBJPROP_COLOR, InfoPanelTextColor);
        ObjectSetInteger(0, datetime_text_id, OBJPROP_FONTSIZE, 8);
        ObjectSetInteger(0, datetime_text_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, datetime_text_id, OBJPROP_HIDDEN, true);
        ObjectSetString(0, datetime_text_id, OBJPROP_TEXT, GetLocalizedText("current_time") + ": " + GetCurrentDateTime());
        
        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞
        if(InfoPanelCorner == CORNER_LEFT_UPPER || InfoPanelCorner == CORNER_LEFT_LOWER)
            ObjectSetInteger(0, datetime_text_id, OBJPROP_ANCHOR, ANCHOR_RIGHT_UPPER);
    }
    
    // –¢–µ–∫—Å—Ç –¥–ª—è –∏–º–µ–Ω–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    if(ObjectFind(0, username_text_id) < 0)
    {
        ObjectCreate(0, username_text_id, OBJ_LABEL, 0, 0, 0);
        ObjectSetInteger(0, username_text_id, OBJPROP_CORNER, InfoPanelCorner);
        ObjectSetInteger(0, username_text_id, OBJPROP_XDISTANCE, title_x);
        ObjectSetInteger(0, username_text_id, OBJPROP_YDISTANCE, user_y);
        ObjectSetInteger(0, username_text_id, OBJPROP_COLOR, InfoPanelTextColor);
        ObjectSetInteger(0, username_text_id, OBJPROP_FONTSIZE, 8);
        ObjectSetInteger(0, username_text_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, username_text_id, OBJPROP_HIDDEN, true);
        ObjectSetString(0, username_text_id, OBJPROP_TEXT, GetLocalizedText("current_user") + ": " + GetComputerUserName());
        
        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞
        if(InfoPanelCorner == CORNER_LEFT_UPPER || InfoPanelCorner == CORNER_LEFT_LOWER)
            ObjectSetInteger(0, username_text_id, OBJPROP_ANCHOR, ANCHOR_RIGHT_UPPER);
    }
    
    // –¢–µ–∫—Å—Ç –¥–ª—è —É—Ä–æ–≤–Ω—è —Ä–∏—Å–∫–∞
    if(ObjectFind(0, risk_text_id) < 0)
    {
        ObjectCreate(0, risk_text_id, OBJ_LABEL, 0, 0, 0);
        ObjectSetInteger(0, risk_text_id, OBJPROP_CORNER, InfoPanelCorner);
        ObjectSetInteger(0, risk_text_id, OBJPROP_XDISTANCE, title_x);
        ObjectSetInteger(0, risk_text_id, OBJPROP_YDISTANCE, risk_y);
        ObjectSetInteger(0, risk_text_id, OBJPROP_COLOR, InfoPanelTextColor);
        ObjectSetInteger(0, risk_text_id, OBJPROP_FONTSIZE, 8);
        ObjectSetInteger(0, risk_text_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, risk_text_id, OBJPROP_HIDDEN, true);
        ObjectSetString(0, risk_text_id, OBJPROP_TEXT, GetLocalizedText("risk_assessment") + ": " + GetLocalizedText("risk_medium"));
        
        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞
        if(InfoPanelCorner == CORNER_LEFT_UPPER || InfoPanelCorner == CORNER_LEFT_LOWER)
            ObjectSetInteger(0, risk_text_id, OBJPROP_ANCHOR, ANCHOR_RIGHT_UPPER);
    }
    
    // –¢–µ–∫—Å—Ç –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–Ω—ã—Ö –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
    if(ObjectFind(0, pattern_text_id) < 0)
    {
        ObjectCreate(0, pattern_text_id, OBJ_LABEL, 0, 0, 0);
        ObjectSetInteger(0, pattern_text_id, OBJPROP_CORNER, InfoPanelCorner);
        ObjectSetInteger(0, pattern_text_id, OBJPROP_XDISTANCE, title_x);
        ObjectSetInteger(0, pattern_text_id, OBJPROP_YDISTANCE, pattern_y);
        ObjectSetInteger(0, pattern_text_id, OBJPROP_COLOR, InfoPanelTextColor);
        ObjectSetInteger(0, pattern_text_id, OBJPROP_FONTSIZE, 8);
        ObjectSetInteger(0, pattern_text_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, pattern_text_id, OBJPROP_HIDDEN, true);
        ObjectSetString(0, pattern_text_id, OBJPROP_TEXT, GetLocalizedText("detected_patterns") + ": -");
        
        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞
        if(InfoPanelCorner == CORNER_LEFT_UPPER || InfoPanelCorner == CORNER_LEFT_LOWER)
            ObjectSetInteger(0, pattern_text_id, OBJPROP_ANCHOR, ANCHOR_RIGHT_UPPER);
    }
    
    // –¢–µ–∫—Å—Ç –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ —Ç—Ä–µ–Ω–¥–∞
    if(ObjectFind(0, trend_text_id) < 0)
    {
        ObjectCreate(0, trend_text_id, OBJ_LABEL, 0, 0, 0);
        ObjectSetInteger(0, trend_text_id, OBJPROP_CORNER, InfoPanelCorner);
        ObjectSetInteger(0, trend_text_id, OBJPROP_XDISTANCE, title_x);
        ObjectSetInteger(0, trend_text_id, OBJPROP_YDISTANCE, trend_y);
        ObjectSetInteger(0, trend_text_id, OBJPROP_COLOR, InfoPanelTextColor);
        ObjectSetInteger(0, trend_text_id, OBJPROP_FONTSIZE, 8);
        ObjectSetInteger(0, trend_text_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, trend_text_id, OBJPROP_HIDDEN, true);
        ObjectSetString(0, trend_text_id, OBJPROP_TEXT, GetLocalizedText("trend") + ": " + GetLocalizedText("trend_sideways"));
        
        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞
        if(InfoPanelCorner == CORNER_LEFT_UPPER || InfoPanelCorner == CORNER_LEFT_LOWER)
            ObjectSetInteger(0, trend_text_id, OBJPROP_ANCHOR, ANCHOR_RIGHT_UPPER);
    }
    
    // –¢–µ–∫—Å—Ç –¥–ª—è —É—Ä–æ–≤–Ω–µ–π –∑–æ–Ω –ø–µ—Ä–µ–∫—É–ø–ª–µ–Ω–Ω–æ—Å—Ç–∏/–ø–µ—Ä–µ–ø—Ä–æ–¥–∞–Ω–Ω–æ—Å—Ç–∏
    if(ObjectFind(0, zones_text_id) < 0)
    {
        ObjectCreate(0, zones_text_id, OBJ_LABEL, 0, 0, 0);
        ObjectSetInteger(0, zones_text_id, OBJPROP_CORNER, InfoPanelCorner);
        ObjectSetInteger(0, zones_text_id, OBJPROP_XDISTANCE, title_x);
        ObjectSetInteger(0, zones_text_id, OBJPROP_YDISTANCE, zones_y);
        ObjectSetInteger(0, zones_text_id, OBJPROP_COLOR, InfoPanelTextColor);
        ObjectSetInteger(0, zones_text_id, OBJPROP_FONTSIZE, 8);
        ObjectSetInteger(0, zones_text_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, zones_text_id, OBJPROP_HIDDEN, true);
        ObjectSetString(0, zones_text_id, OBJPROP_TEXT, GetLocalizedText("zones") + ": -");
        
        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞
        if(InfoPanelCorner == CORNER_LEFT_UPPER || InfoPanelCorner == CORNER_LEFT_LOWER)
            ObjectSetInteger(0, zones_text_id, OBJPROP_ANCHOR, ANCHOR_RIGHT_UPPER);
    }
}

//+------------------------------------------------------------------+
//| –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –Ω–∞ –ø–∞–Ω–µ–ª–∏                                 |
//+------------------------------------------------------------------+
void UpdateInfoPanel(int bar_index, const datetime &time[])
{
    if(!ShowInfoPanel || bar_index <= 0)
        return;
        
    datetime current_time = TimeCurrent();
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –ø–∞–Ω–µ–ª—å –Ω–µ —á–∞—â–µ, —á–µ–º —Ä–∞–∑ –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è
    if(current_time - last_update_time < update_frequency)
        return;
        
    last_update_time = current_time;
    
    // –†–∞—Å—á—ë—Ç –∏ —É—Å—Ç–∞–Ω–æ–≤–∫–∞ —É—Ä–æ–≤–Ω—è —Ä–∏—Å–∫–∞ —Å —Å–æ–∑–¥–∞–Ω–∏–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π risk_text
    double risk_value = 0.0;
    ENUM_RISK_LEVEL risk_level = CalculateRiskLevel(bar_index, RiskAssessmentPeriod, risk_value);
    string risk_text = "";
    
    switch(risk_level)
    {
        case RISK_LOW:
            risk_text = GetLocalizedText("risk_assessment") + ": " + GetLocalizedText("risk_low");
            ObjectSetInteger(0, risk_text_id, OBJPROP_COLOR, clrLimeGreen);
            break;
        case RISK_MEDIUM:
            risk_text = GetLocalizedText("risk_assessment") + ": " + GetLocalizedText("risk_medium");
            ObjectSetInteger(0, risk_text_id, OBJPROP_COLOR, clrYellow);
            break;
        case RISK_HIGH:
            risk_text = GetLocalizedText("risk_assessment") + ": " + GetLocalizedText("risk_high");
            ObjectSetInteger(0, risk_text_id, OBJPROP_COLOR, clrTomato);
            break;
    }
    
    ObjectSetString(0, risk_text_id, OBJPROP_TEXT, risk_text);
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–∞—Ç—Ç–µ—Ä–Ω–∞—Ö
    string patterns = "";
    bool has_patterns = false;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 5 –±–∞—Ä–æ–≤ –Ω–∞ –Ω–∞–ª–∏—á–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
    for(int i = bar_index; i >= MathMax(0, bar_index - 5); i--)
    {
        if(i < ArraySize(VFI_Buffer))
        {
            // –ü–æ–ª—É—á–∏–º —Ü–µ–Ω—ã –Ω–∞–ø—Ä—è–º—É—é –∏–∑ –±—É—Ñ–µ—Ä–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
            if(IsDoubleBottom(i, VFI_Length))
            {
                patterns += "W ";  // Double Bottom
                has_patterns = true;
            }
            
            if(IsDoubleTop(i, VFI_Length))
            {
                patterns += "M ";  // Double Top
                has_patterns = true;
            }
            
            // –î–æ–±–∞–≤—å—Ç–µ –∑–¥–µ—Å—å –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–∞ –¥—Ä—É–≥–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã
        }
    }
    
    if(has_patterns)
        ObjectSetString(0, pattern_text_id, OBJPROP_TEXT, GetLocalizedText("detected_patterns") + ": " + patterns);
    else
        ObjectSetString(0, pattern_text_id, OBJPROP_TEXT, GetLocalizedText("detected_patterns") + ": " + GetLocalizedText("no_patterns_detected"));
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç—Ä–µ–Ω–¥–µ
    double trend_strength = 0.0;
    ENUM_TREND_DIRECTION trend = DetermineTrend(bar_index, TrendPeriod, trend_strength);
    string trend_text = GetLocalizedText("trend") + ": ";
    
    switch(trend)
    {
        case TREND_UP:
            trend_text += GetLocalizedText("trend_up");
            ObjectSetInteger(0, trend_text_id, OBJPROP_COLOR, clrLimeGreen);
            break;
        case TREND_DOWN:
            trend_text += GetLocalizedText("trend_down");
            ObjectSetInteger(0, trend_text_id, OBJPROP_COLOR, clrTomato);
            break;
        case TREND_SIDEWAYS:
        default:
            trend_text += GetLocalizedText("trend_sideways");
            ObjectSetInteger(0, trend_text_id, OBJPROP_COLOR, InfoPanelTextColor);
            break;
    }
    
    // –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å–∏–ª–µ —Ç—Ä–µ–Ω–¥–∞
    trend_text += " (" + GetLocalizedText("trend_strength") + ": " + DoubleToString(trend_strength * 100.0, 1) + "%)";
    ObjectSetString(0, trend_text_id, OBJPROP_TEXT, trend_text);
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∑–æ–Ω–∞—Ö
    if(dynamic_overbought_level != 0 || dynamic_oversold_level != 0)
    {
        string zones_text = GetLocalizedText("zones") + ": " +
                          GetLocalizedText("overbought_level") + "=" + DoubleToString(dynamic_overbought_level, 2) +
                          ", " + GetLocalizedText("oversold_level") + "=" + DoubleToString(dynamic_oversold_level, 2);
        ObjectSetString(0, zones_text_id, OBJPROP_TEXT, zones_text);
    }
    else
    {
        ObjectSetString(0, zones_text_id, OBJPROP_TEXT, GetLocalizedText("zones") + ": -");
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º—è
    ObjectSetString(0, datetime_text_id, OBJPROP_TEXT, GetLocalizedText("current_time") + ": " + 
                 TimeToString(TimeCurrent(), TIME_DATE | TIME_SECONDS));
}

//+------------------------------------------------------------------+
//| –†–∞—Å—á–µ—Ç —É—Ä–æ–≤–Ω—è —Ä–∏—Å–∫–∞                                            |
//+------------------------------------------------------------------+
ENUM_RISK_LEVEL CalculateRiskLevel(int bar_index, int period, double &risk_value)
{
    if(bar_index <= period || period <= 0)
    {
        risk_value = 0.5; // –°—Ä–µ–¥–Ω–∏–π —Ä–∏—Å–∫ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        return RISK_MEDIUM;
    }
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –º–µ—Ç—Ä–∏–∫ –¥–ª—è –æ—Ü–µ–Ω–∫–∏ —Ä–∏—Å–∫–∞
    
    // 1. –í–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å
    double volatility = CalculateVolatility(bar_index, period);
    
    // 2. –¢—Ä–µ–Ω–¥ –∏ –µ–≥–æ —Å–∏–ª–∞
    double trend_strength = 0;
    ENUM_TREND_DIRECTION trend = DetermineTrend(bar_index, period, trend_strength);
    
    // 3. –ü–æ–∑–∏—Ü–∏—è –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —É—Ä–æ–≤–Ω–µ–π –ø–µ—Ä–µ–∫—É–ø–ª–µ–Ω–Ω–æ—Å—Ç–∏/–ø–µ—Ä–µ–ø—Ä–æ–¥–∞–Ω–Ω–æ—Å—Ç–∏
    double overbought_oversold_factor = 0;
    if(dynamic_overbought_level != 0 && dynamic_oversold_level != 0)
    {
        double current_vfi = VFI_Buffer[bar_index];
        double range = dynamic_overbought_level - dynamic_oversold_level;
        if(range != 0)
        {
            // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –ø–æ–ª–æ–∂–µ–Ω–∏–µ –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ –æ—Ç 0 –¥–æ 1
            double position = (current_vfi - dynamic_oversold_level) / range;
            // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ —Ñ–∞–∫—Ç–æ—Ä —Ä–∏—Å–∫–∞: —á–µ–º –±–ª–∏–∂–µ –∫ –∫—Ä–∞–π–Ω–∏–º –∑–Ω–∞—á–µ–Ω–∏—è–º, —Ç–µ–º –≤—ã—à–µ —Ä–∏—Å–∫
            overbought_oversold_factor = 2.0 * MathAbs(position - 0.5);
        }
    }
    
        // 4. –†–∞—Å—Ö–æ–∂–¥–µ–Ω–∏–µ –º–µ–∂–¥—É VFI –∏ —Ü–µ–Ω–æ–π (–¥–∏–≤–µ—Ä–≥–µ–Ω—Ü–∏—è)
    double divergence_factor = CalculateDivergenceFactor(bar_index, period);
    
    // –û–±—ä–µ–¥–∏–Ω—è–µ–º —Ñ–∞–∫—Ç–æ—Ä—ã —Å –≤–µ—Å–∞–º–∏
    risk_value = 0.3 * volatility + 0.2 * trend_strength + 0.3 * overbought_oversold_factor + 0.2 * divergence_factor;
    
    // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –æ—Ç 0 –¥–æ 1
    risk_value = MathMin(MathMax(risk_value, 0.0), 1.0);
    
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —É—Ä–æ–≤–µ–Ω—å —Ä–∏—Å–∫–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∑–Ω–∞—á–µ–Ω–∏—è
    if(risk_value < 0.33)
        return RISK_LOW;
    else if(risk_value < 0.66)
        return RISK_MEDIUM;
    else
        return RISK_HIGH;
}

//+------------------------------------------------------------------+
//| –†–∞—Å—á–µ—Ç –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏                                           |
//+------------------------------------------------------------------+
double CalculateVolatility(int bar_index, int period)
{
    if(bar_index <= period || period <= 0)
        return 0.5;
    
    // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ VFI
    double sum = 0.0;
    double sum_sq = 0.0;
    int count = 0;
    
    for(int i = bar_index; i > bar_index - period && i >= 0; i--)
    {
        if(VFI_Buffer[i] != EMPTY_VALUE)
        {
            sum += VFI_Buffer[i];
            sum_sq += VFI_Buffer[i] * VFI_Buffer[i];
            count++;
        }
    }
    
    if(count < 2)
        return 0.5;
    
    double mean = sum / count;
    double variance = (sum_sq / count) - (mean * mean);
    
    // –ò–∑–±–µ–≥–∞–µ–º –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π –∏–∑-–∑–∞ –æ—à–∏–±–æ–∫ –æ–∫—Ä—É–≥–ª–µ–Ω–∏—è
    variance = MathMax(0, variance);
    
    double std_dev = MathSqrt(variance);
    
    // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å –Ω–∞ –æ—Å–Ω–æ–≤–µ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö
    // (–º–æ–∂–Ω–æ –±—ã–ª–æ –±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å ATR –∏–ª–∏ –¥—Ä—É–≥–∏–µ –º–µ—Ç–æ–¥—ã)
    double norm_volatility = MathMin(std_dev / 0.5, 1.0);
    
    return norm_volatility;
}

//+------------------------------------------------------------------+
//| –†–∞—Å—á–µ—Ç —Ñ–∞–∫—Ç–æ—Ä–∞ –¥–∏–≤–µ—Ä–≥–µ–Ω—Ü–∏–∏                                     |
//+------------------------------------------------------------------+
double CalculateDivergenceFactor(int bar_index, int period)
{
    if(bar_index <= period || period <= 0)
        return 0.0;
    
    // –£–ø—Ä–æ—â–µ–Ω–Ω—ã–π —Ä–∞—Å—á–µ—Ç –¥–∏–≤–µ—Ä–≥–µ–Ω—Ü–∏–∏
    // –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è VFI –∏ —Ü–µ–Ω—ã
    double vfi_change = 0.0;
    double price_change = 0.0;
    
    if(bar_index < ArraySize(VFI_Buffer) && bar_index - period >= 0)
    {
        vfi_change = VFI_Buffer[bar_index] - VFI_Buffer[bar_index - period];
        
        // –ü–æ–ª—É—á–∞–µ–º —Ü–µ–Ω—ã –∑–∞–∫—Ä—ã—Ç–∏—è
        MqlRates rates[];
        if(CopyRates(Symbol(), PERIOD_CURRENT, bar_index - period, period + 1, rates) == period + 1)
        {
            price_change = rates[period].close - rates[0].close;
        }
    }
    
    // –ï—Å–ª–∏ –∑–Ω–∞–∫–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–π –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω—ã, –µ—Å—Ç—å –¥–∏–≤–µ—Ä–≥–µ–Ω—Ü–∏—è
    bool divergence = (vfi_change * price_change < 0);
    
    return divergence ? 0.8 : 0.2;
}

//+------------------------------------------------------------------+
//| –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–∞—Ç—Ç–µ—Ä–Ω –î–≤–æ–π–Ω–æ–µ –î–Ω–æ                               |
//+------------------------------------------------------------------+
bool IsDoubleBottom(int bar_index, int lookback_period)
{
    if(bar_index < 20 || lookback_period <= 0)
        return false;
    
    int left_bottom = -1;
    int right_bottom = -1;
    double min_value = DBL_MAX;
    
    // –ò—â–µ–º –ø–µ—Ä–≤—ã–π –º–∏–Ω–∏–º—É–º
    for(int i = bar_index - 15; i <= bar_index - 5; i++)
    {
        if(i < 0) continue;
        
        if(i < ArraySize(VFI_Buffer) && VFI_Buffer[i] != EMPTY_VALUE && 
           VFI_Buffer[i] < min_value && 
           (i == 0 || VFI_Buffer[i] < VFI_Buffer[i-1]) && 
           (i == ArraySize(VFI_Buffer)-1 || VFI_Buffer[i] < VFI_Buffer[i+1]))
        {
            min_value = VFI_Buffer[i];
            left_bottom = i;
        }
    }
    
    if(left_bottom == -1)
        return false;
    
    min_value = DBL_MAX;
    
    // –ò—â–µ–º –≤—Ç–æ—Ä–æ–π –º–∏–Ω–∏–º—É–º
    for(int i = bar_index - 5; i <= bar_index; i++)
    {
        if(i < 0) continue;
        
        if(i < ArraySize(VFI_Buffer) && VFI_Buffer[i] != EMPTY_VALUE && 
           VFI_Buffer[i] < min_value && 
           (i == 0 || VFI_Buffer[i] < VFI_Buffer[i-1]) && 
           (i == ArraySize(VFI_Buffer)-1 || VFI_Buffer[i] < VFI_Buffer[i+1]))
        {
            min_value = VFI_Buffer[i];
            right_bottom = i;
        }
    }
    
    if(right_bottom == -1 || left_bottom == right_bottom)
        return false;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –º–µ–∂–¥—É –º–∏–Ω–∏–º—É–º–∞–º–∏ –µ—Å—Ç—å –ª–æ–∫–∞–ª—å–Ω—ã–π –º–∞–∫—Å–∏–º—É–º
    double peak = VFI_Buffer[left_bottom];
    for(int i = left_bottom + 1; i < right_bottom; i++)
    {
        if(i < ArraySize(VFI_Buffer) && VFI_Buffer[i] != EMPTY_VALUE && VFI_Buffer[i] > peak)
            peak = VFI_Buffer[i];
    }
    
    // –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –≤—ã—Å–æ—Ç–∞ –ø–∞—Ç—Ç–µ—Ä–Ω–∞
    double min_height = 0.2;
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ª–æ–≤–∏–π –¥–≤–æ–π–Ω–æ–≥–æ –¥–Ω–∞
    bool valid_height = (peak - VFI_Buffer[left_bottom] > min_height) && (peak - VFI_Buffer[right_bottom] > min_height);
    bool similar_bottoms = MathAbs(VFI_Buffer[left_bottom] - VFI_Buffer[right_bottom]) < 0.1;
    
    return valid_height && similar_bottoms;
}

//+------------------------------------------------------------------+
//| –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–∞—Ç—Ç–µ—Ä–Ω –î–≤–æ–π–Ω–∞—è –í–µ—Ä—à–∏–Ω–∞                            |
//+------------------------------------------------------------------+
bool IsDoubleTop(int bar_index, int lookback_period)
{
    if(bar_index < 20 || lookback_period <= 0)
        return false;
    
    int left_top = -1;
    int right_top = -1;
    double max_value = -DBL_MAX;
    
    // –ò—â–µ–º –ø–µ—Ä–≤—ã–π –º–∞–∫—Å–∏–º—É–º
    for(int i = bar_index - 15; i <= bar_index - 5; i++)
    {
        if(i < 0) continue;
        
        if(i < ArraySize(VFI_Buffer) && VFI_Buffer[i] != EMPTY_VALUE && 
           VFI_Buffer[i] > max_value && 
           (i == 0 || VFI_Buffer[i] > VFI_Buffer[i-1]) && 
           (i == ArraySize(VFI_Buffer)-1 || VFI_Buffer[i] > VFI_Buffer[i+1]))
        {
            max_value = VFI_Buffer[i];
            left_top = i;
        }
    }
    
    if(left_top == -1)
        return false;
    
    max_value = -DBL_MAX;
    
    // –ò—â–µ–º –≤—Ç–æ—Ä–æ–π –º–∞–∫—Å–∏–º—É–º
    for(int i = bar_index - 5; i <= bar_index; i++)
    {
        if(i < 0) continue;
        
        if(i < ArraySize(VFI_Buffer) && VFI_Buffer[i] != EMPTY_VALUE && 
           VFI_Buffer[i] > max_value && 
           (i == 0 || VFI_Buffer[i] > VFI_Buffer[i-1]) && 
           (i == ArraySize(VFI_Buffer)-1 || VFI_Buffer[i] > VFI_Buffer[i+1]))
        {
            max_value = VFI_Buffer[i];
            right_top = i;
        }
    }
    
    if(right_top == -1 || left_top == right_top)
        return false;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –º–µ–∂–¥—É –º–∞–∫—Å–∏–º—É–º–∞–º–∏ –µ—Å—Ç—å –ª–æ–∫–∞–ª—å–Ω—ã–π –º–∏–Ω–∏–º—É–º
    double valley = VFI_Buffer[left_top];
    for(int i = left_top + 1; i < right_top; i++)
    {
        if(i < ArraySize(VFI_Buffer) && VFI_Buffer[i] != EMPTY_VALUE && VFI_Buffer[i] < valley)
            valley = VFI_Buffer[i];
    }
    
    // –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –≤—ã—Å–æ—Ç–∞ –ø–∞—Ç—Ç–µ—Ä–Ω–∞
    double min_height = 0.2;
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ª–æ–≤–∏–π –¥–≤–æ–π–Ω–æ–π –≤–µ—Ä—à–∏–Ω—ã
    bool valid_height = (VFI_Buffer[left_top] - valley > min_height) && (VFI_Buffer[right_top] - valley > min_height);
    bool similar_tops = MathAbs(VFI_Buffer[left_top] - VFI_Buffer[right_top]) < 0.1;
    
    return valid_height && similar_tops;
}

//+------------------------------------------------------------------+
//| Custom indicator initialization function                         |
//+------------------------------------------------------------------+
int OnInit()
{
    // Determine system language first
    is_russian_system = IsRussianSystem();
    
    // Validate input parameters
    if(VFI_Length < 10)
    {
        Print("‚ùå ", GetLocalizedText("parameter_error"), ": ", GetLocalizedText("invalid_vfi_length"));
        return(INIT_PARAMETERS_INCORRECT);
    }
    
    if(SignalLength < 1)
    {
        Print("‚ùå ", GetLocalizedText("parameter_error"), ": ", GetLocalizedText("invalid_signal_length"));
        return(INIT_PARAMETERS_INCORRECT);
    }
    
    if(Coef <= 0 || VCoef <= 0)
    {
        Print("‚ùå ", GetLocalizedText("parameter_error"), ": ", GetLocalizedText("invalid_coefficients"));
        return(INIT_PARAMETERS_INCORRECT);
    }
    
    //--- indicator buffers mapping
    SetIndexBuffer(0, VFI_Buffer, INDICATOR_DATA);
    SetIndexBuffer(1, VFI_EMA_Buffer, INDICATOR_DATA);
    SetIndexBuffer(2, Histogram_Buffer, INDICATOR_DATA);
    SetIndexBuffer(3, Buy_Signal_Buffer, INDICATOR_DATA);
    SetIndexBuffer(4, Sell_Signal_Buffer, INDICATOR_DATA);
    SetIndexBuffer(5, DoubleBottom_Buffer, INDICATOR_DATA);
    SetIndexBuffer(6, DoubleTop_Buffer, INDICATOR_DATA);
    SetIndexBuffer(7, Divergence_Buffer, INDICATOR_DATA);
    SetIndexBuffer(8, Risk_Buffer, INDICATOR_DATA);
    SetIndexBuffer(9, Risk_Colors_Buffer, INDICATOR_COLOR_INDEX);
    SetIndexBuffer(10, VCP_Buffer, INDICATOR_CALCULATIONS);
    
    // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤–∞–∂–Ω–æ–≥–æ —Å–≤–æ–π—Å—Ç–≤–∞ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∏—Å—Ç–æ—Ä–∏–∏ (!)
    PlotIndexSetInteger(0, PLOT_DRAW_BEGIN, VFI_Length);
    PlotIndexSetInteger(1, PLOT_DRAW_BEGIN, VFI_Length);
    PlotIndexSetInteger(2, PLOT_DRAW_BEGIN, VFI_Length);
    PlotIndexSetInteger(3, PLOT_DRAW_BEGIN, VFI_Length);
    PlotIndexSetInteger(4, PLOT_DRAW_BEGIN, VFI_Length);
    PlotIndexSetInteger(8, PLOT_DRAW_BEGIN, VFI_Length);
    
    // Arrow settings
    PlotIndexSetInteger(3, PLOT_ARROW, 233); // Buy signal arrow
    PlotIndexSetInteger(4, PLOT_ARROW, 234); // Sell signal arrow
    
    //--- set accuracy
    IndicatorSetInteger(INDICATOR_DIGITS, 4);
    
    //--- set short name
    IndicatorSetString(INDICATOR_SHORTNAME, "VFI_Pro(" + 
                      IntegerToString(VFI_Length) + "," + 
                      DoubleToString(Coef, 1) + "," + 
                      DoubleToString(VCoef, 1) + ")");
    
    //--- set zero level
    IndicatorSetDouble(INDICATOR_LEVELVALUE, 0, 0.0);
    
    //--- set empty values
    PlotIndexSetDouble(0, PLOT_EMPTY_VALUE, EMPTY_VALUE);
    PlotIndexSetDouble(1, PLOT_EMPTY_VALUE, EMPTY_VALUE);
    PlotIndexSetDouble(2, PLOT_EMPTY_VALUE, EMPTY_VALUE);
    PlotIndexSetDouble(3, PLOT_EMPTY_VALUE, EMPTY_VALUE);
    PlotIndexSetDouble(4, PLOT_EMPTY_VALUE, EMPTY_VALUE);
    PlotIndexSetDouble(5, PLOT_EMPTY_VALUE, EMPTY_VALUE);
    PlotIndexSetDouble(6, PLOT_EMPTY_VALUE, EMPTY_VALUE);
    PlotIndexSetDouble(7, PLOT_EMPTY_VALUE, EMPTY_VALUE);
    PlotIndexSetDouble(8, PLOT_EMPTY_VALUE, EMPTY_VALUE);
    
    //--- hide histogram if not needed
    if(!ShowHisto)
        PlotIndexSetInteger(2, PLOT_DRAW_TYPE, DRAW_NONE);
    else
        PlotIndexSetInteger(2, PLOT_DRAW_TYPE, DRAW_HISTOGRAM);
    
    //--- initialize calculation arrays with sufficient size
    int initial_size = 1000; // –ó–∞–¥–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä —Å –∑–∞–ø–∞—Å–æ–º
    ArrayResize(inter_array, initial_size);
    ArrayResize(typical_array, initial_size);
    ArrayResize(volatility_array, initial_size);
    ArrayResize(price_array, initial_size);
    ArrayResize(trend_buffer, initial_size);
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –º–∞—Å—Å–∏–≤—ã –Ω—É–ª–µ–≤—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏
    ArrayInitialize(inter_array, 0.0);
    ArrayInitialize(typical_array, 0.0);
    ArrayInitialize(volatility_array, 0.0);
    ArrayInitialize(price_array, 0.0);
    ArrayInitialize(trend_buffer, 0.0);
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    prev_vfi_length = VFI_Length;
    prev_coef = Coef;
    prev_vcoef = VCoef;
    prev_signal_length = SignalLength;
    prev_smooth_vfi = SmoothVFI;
    prev_show_histo = ShowHisto;
    prev_use_real_volume = UseRealVolume;
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
    indicator_load_time = TimeCurrent();
    session_start_time = indicator_load_time;
    
    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –±–∞—Ä–æ–≤ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
    last_rates_total = 0;
    
    // –°–æ–∑–¥–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—É—é –ø–∞–Ω–µ–ª—å
    if(ShowInfoPanel)
        CreateInfoPanel();
    
    // –í—ã–≤–æ–¥–∏–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö
    Print("--- VFI Pro Indicator Settings ---");
    Print(GetLocalizedText("indicator_settings"), ":");
    Print("  VFI Length: ", VFI_Length);
    Print("  Coefficient: ", Coef);
    Print("  Max Volume Cutoff: ", VCoef);
    Print("  Signal Length: ", SignalLength);
    Print("  Smooth VFI: ", SmoothVFI ? GetLocalizedText("yes") : GetLocalizedText("no"));
    Print("  Show Histogram: ", ShowHisto ? GetLocalizedText("yes") : GetLocalizedText("no"));
    Print("  Use Real Volume: ", UseRealVolume ? GetLocalizedText("yes") : GetLocalizedText("no"));
    Print("  Show Patterns: ", ShowPatterns ? GetLocalizedText("yes") : GetLocalizedText("no"));
    Print("  Alerts: ", EnableAlerts ? GetLocalizedText("yes") : GetLocalizedText("no"));
    Print("  Notifications: ", EnableNotifications ? GetLocalizedText("yes") : GetLocalizedText("no"));
    Print("  Dynamic Colors: ", EnableDynamicColors ? GetLocalizedText("yes") : GetLocalizedText("no"));
    Print("  Info Panel: ", ShowInfoPanel ? GetLocalizedText("yes") : GetLocalizedText("no"));
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –æ–±—ä–µ–º–æ–≤
    CheckVolumeData();
    
    return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –∏ –∫–∞—á–µ—Å—Ç–≤–∞ –¥–∞–Ω–Ω—ã—Ö –ø–æ –æ–±—ä–µ–º–∞–º                   |
//+------------------------------------------------------------------+
void CheckVolumeData()
{
    string symbol = Symbol();
    string username = GetComputerUserName();
    string current_datetime = GetCurrentDateTime();
    
    Print(GetLocalizedText("volume_check_header"));
    Print(GetLocalizedText("symbol"), ": ", symbol);
    Print(GetLocalizedText("datetime"), ": ", current_datetime);
    Print(GetLocalizedText("user"), ": ", username);
    
    // Check execution type
    ENUM_SYMBOL_TRADE_EXECUTION execution = (ENUM_SYMBOL_TRADE_EXECUTION)SymbolInfoInteger(symbol, SYMBOL_TRADE_EXEMODE);
    string exec_type = "";
    switch(execution)
    {
        case SYMBOL_TRADE_EXECUTION_REQUEST: exec_type = "Request"; break;
        case SYMBOL_TRADE_EXECUTION_INSTANT: exec_type = "Instant"; break;
        case SYMBOL_TRADE_EXECUTION_MARKET: exec_type = "Market"; break;
        case SYMBOL_TRADE_EXECUTION_EXCHANGE: exec_type = "Exchange"; break;
        default: exec_type = "Unknown";
    }
    Print(GetLocalizedText("execution_type"), ": ", exec_type);
    
    // Get test data
    MqlRates rates[];
    int copied = CopyRates(symbol, PERIOD_CURRENT, 0, 30, rates);
    
    if(copied <= 0)
    {
        Print(GetLocalizedText("error_no_data"));
        return;
    }
    
    Print(GetLocalizedText("bars_analyzed"), ": ", copied);
    
    // Analyze tick volumes
    long total_tick_volume = 0;
    long max_tick_volume = 0;
    long min_tick_volume = LONG_MAX;
    int zero_tick_volumes = 0;
    
    // Analyze real volumes
    long total_real_volume = 0;
    long max_real_volume = 0;
    long min_real_volume = LONG_MAX;
    int zero_real_volumes = 0;
    bool has_real_volumes = false;
    
    // –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ü–∏–∫–ª - –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞ –æ–¥–∏–Ω –ø—Ä–æ—Ö–æ–¥
    for(int i = 0; i < copied; i++)
    {
        // Tick volumes
        long tick_vol = rates[i].tick_volume;
        total_tick_volume += tick_vol;
        
        if(tick_vol == 0)
            zero_tick_volumes++;
            
        if(tick_vol > max_tick_volume)
            max_tick_volume = tick_vol;
            
        if(tick_vol < min_tick_volume && tick_vol > 0)
            min_tick_volume = tick_vol;
        
        // Real volumes
        long real_vol = rates[i].real_volume;
        if(real_vol > 0)
        {
            has_real_volumes = true;
            total_real_volume += real_vol;
            
            if(real_vol > max_real_volume)
                max_real_volume = real_vol;
                
            if(real_vol < min_real_volume)
                min_real_volume = real_vol;
        }
        else
        {
            zero_real_volumes++;
        }
    }
    
    // Tick volume results
    double avg_tick_volume = (double)total_tick_volume / copied;
    Print(GetLocalizedText("tick_volumes"), ":");
    Print("  ", GetLocalizedText("average"), ": ", (long)avg_tick_volume);
    Print("  ", GetLocalizedText("maximum"), ": ", max_tick_volume);
    Print("  ", GetLocalizedText("minimum"), ": ", min_tick_volume);
    Print("  ", GetLocalizedText("zero_bars"), ": ", zero_tick_volumes, " (", 
          MathRound(zero_tick_volumes * 100.0 / copied), "%)");
    
    // Real volume results
    real_volumes_available = has_real_volumes;
    if(has_real_volumes)
    {
        double avg_real_volume = (double)total_real_volume / (copied - zero_real_volumes);
        Print(GetLocalizedText("real_volumes"), ":");
        Print("  ", GetLocalizedText("average"), ": ", (long)avg_real_volume);
        Print("  ", GetLocalizedText("maximum"), ": ", max_real_volume);
        Print("  ", GetLocalizedText("minimum"), ": ", min_real_volume);
        Print("  ", GetLocalizedText("zero_bars"), ": ", zero_real_volumes, " (", 
              MathRound(zero_real_volumes * 100.0 / copied), "%)");
    }
    else
    {
        Print(GetLocalizedText("real_volumes_unavailable"));
    }
    
    // Data quality assessment
    string quality_assessment = "";
    string recommendation = "";
    
    if(!has_real_volumes && zero_tick_volumes > copied * 0.5)
    {
        quality_assessment = GetLocalizedText("critical_no_volumes");
        recommendation = GetLocalizedText("change_instrument");
    }
    else if(!has_real_volumes && (max_tick_volume - min_tick_volume) < avg_tick_volume * 0.1)
    {
        quality_assessment = GetLocalizedText("poor_no_variation");
        recommendation = GetLocalizedText("may_work_incorrectly");
    }
    else if(!has_real_volumes)
    {
        quality_assessment = GetLocalizedText("satisfactory_tick_only");
        recommendation = GetLocalizedText("will_work_less_accurate");
    }
    else if(has_real_volumes && zero_real_volumes < copied * 0.1)
    {
        quality_assessment = GetLocalizedText("excellent_real_volumes");
        recommendation = GetLocalizedText("will_work_max_accurate");
    }
    else
    {
        quality_assessment = GetLocalizedText("good_real_gaps");
        recommendation = GetLocalizedText("will_work_correctly");
    }
    
    Print(GetLocalizedText("quality_assessment"), ": ", quality_assessment);
    Print(GetLocalizedText("recommendation"), ": ", recommendation);
}

//+------------------------------------------------------------------+
//| Custom indicator iteration function                              |
//+------------------------------------------------------------------+
int OnCalculate(const int rates_total,
                const int prev_calculated,
                const datetime &time[],
                const double &open[],
                const double &high[],
                const double &low[],
                const double &close[],
                const long &tick_volume[],
                const long &volume[],
                const int &spread[])
{
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –¥–∞–Ω–Ω—ã—Ö
    if(rates_total <= 0)
        return(0);
    
    // –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –±–∞—Ä–æ–≤ –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞
    int min_bars = VFI_Length + 50;
    if(rates_total < min_bars)
        return(0);
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∏–∑–º–µ–Ω–∏–ª–∏—Å—å –ª–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    parameters_changed = false;
    if(prev_vfi_length != VFI_Length || 
       prev_coef != Coef || 
       prev_vcoef != VCoef || 
       prev_signal_length != SignalLength || 
       prev_smooth_vfi != SmoothVFI ||
       prev_show_histo != ShowHisto ||
       prev_use_real_volume != UseRealVolume)
    {
        parameters_changed = true;
        prev_vfi_length = VFI_Length;
        prev_coef = Coef;
        prev_vcoef = VCoef;
        prev_signal_length = SignalLength;
        prev_smooth_vfi = SmoothVFI;
        prev_show_histo = ShowHisto;
        prev_use_real_volume = UseRealVolume;
    }
    
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –ø—Ä–æ–∏–∑–æ—à–µ–ª –ª–∏ —Å–±—Ä–æ—Å –±—É—Ñ–µ—Ä–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –∏–∑-–∑–∞ –ø—Ä–æ–∫—Ä—É—Ç–∫–∏ –≥—Ä–∞—Ñ–∏–∫–∞)
    bool buffer_reset = false;
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞, –∏–∑–º–µ–Ω–∏–ª–æ—Å—å –ª–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –±–∞—Ä–æ–≤ –Ω–µ–æ–±—ã—á–Ω—ã–º –æ–±—Ä–∞–∑–æ–º
    if(last_rates_total > 0)
    {
        // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è —Å–∏—Ç—É–∞—Ü–∏—è - –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤—ã—Ö –±–∞—Ä–æ–≤
        if(rates_total > last_rates_total)
        {
            if(rates_total - last_rates_total > 10) // –µ—Å–ª–∏ –¥–æ–±–∞–≤–ª–µ–Ω–æ –±–æ–ª–µ–µ 10 –±–∞—Ä–æ–≤ –∑–∞ —Ä–∞–∑, –≤–æ–∑–º–æ–∂–Ω–æ —ç—Ç–æ —Å–±—Ä–æ—Å
            {
                buffer_reset = true;
                Print(GetLocalizedText("buffer_reset"));
            }
        }
        else if(rates_total < last_rates_total)
        {
            // –ì—Ä–∞—Ñ–∏–∫ –±—ã–ª —Å–∂–∞—Ç –∏–ª–∏ —á—Ç–æ-—Ç–æ –ø–æ–¥–æ–±–Ω–æ–µ, –Ω—É–∂–µ–Ω –ø–æ–ª–Ω—ã–π –ø–µ—Ä–µ—Å—á–µ—Ç
            buffer_reset = true;
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–≤–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –±—É—Ñ–µ—Ä–∞ –Ω–∞ —Å–±—Ä–æ—Å (EMPTY_VALUE)
        if(!buffer_reset && rates_total > 0)
        {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–µ –Ω–µ—Å–∫–æ–ª—å–∫–æ –±–∞—Ä–æ–≤
            for(int i = 0; i < MathMin(5, rates_total); i++)
            {
                if(VFI_Buffer[i] == EMPTY_VALUE && i < last_rates_total - 1)
                {
                    buffer_reset = true;
                    Print(GetLocalizedText("buffer_reset"), " at bar ", i);
                    break;
                }
            }
        }
    }
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –±–∞—Ä–æ–≤ –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ –≤—ã–∑–æ–≤–∞
    last_rates_total = rates_total;
    
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –Ω—É–∂–µ–Ω –ª–∏ –ø–æ–ª–Ω—ã–π –ø–µ—Ä–µ—Å—á–µ—Ç
    bool recalculate_all = (prev_calculated <= 0 || parameters_changed || buffer_reset);
    
    // –í—ã–≤–æ–¥–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
    if(recalculate_all && (first_run || parameters_changed || buffer_reset))
    {
        if(parameters_changed)
            Print(" ", GetLocalizedText("settings_changed"));
        else if(buffer_reset)
            Print(" ", GetLocalizedText("buffer_reset"));
        first_run = false;
    }
    
    //--- resize calculation arrays if needed
    if(ArraySize(inter_array) < rates_total + 10)
    {
        int new_size = rates_total + 100; // –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–ø–∞—Å –≤ 100 —ç–ª–µ–º–µ–Ω—Ç–æ–≤
        ArrayResize(inter_array, new_size);
        ArrayResize(typical_array, new_size);
        ArrayResize(volatility_array, new_size);
        ArrayResize(price_array, new_size);
        ArrayResize(trend_buffer, new_size);
    }
    
    int calc_start;
    if(recalculate_all)
    {
        calc_start = 1;
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –±—É—Ñ–µ—Ä—ã
        ArrayInitialize(VFI_Buffer, EMPTY_VALUE);
        ArrayInitialize(VFI_EMA_Buffer, EMPTY_VALUE);
        ArrayInitialize(Histogram_Buffer, EMPTY_VALUE);
        ArrayInitialize(Buy_Signal_Buffer, EMPTY_VALUE);
        ArrayInitialize(Sell_Signal_Buffer, EMPTY_VALUE);
        ArrayInitialize(DoubleBottom_Buffer, EMPTY_VALUE);
        ArrayInitialize(DoubleTop_Buffer, EMPTY_VALUE);
        ArrayInitialize(Divergence_Buffer, EMPTY_VALUE);
        ArrayInitialize(Risk_Buffer, EMPTY_VALUE);
        ArrayInitialize(Risk_Colors_Buffer, 0);
        ArrayInitialize(VCP_Buffer, 0.0);
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Ä–∞—Å—á–µ—Ç–Ω—ã–µ –º–∞—Å—Å–∏–≤—ã
        ArrayInitialize(inter_array, 0.0);
        ArrayInitialize(typical_array, 0.0);
        ArrayInitialize(volatility_array, 0.0);
        ArrayInitialize(price_array, 0.0);
        ArrayInitialize(trend_buffer, 0.0);
    }
    else
    {
        // –ù–∞—á–∏–Ω–∞–µ–º —Ä–∞—Å—á–µ—Ç —Ç–æ–ª—å–∫–æ —Å –Ω–æ–≤–æ–≥–æ –±–∞—Ä–∞
        calc_start = prev_calculated - 1;
        if(calc_start < 1) calc_start = 1;
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –º–∞—Å—Å–∏–≤—ã –∏–º–µ—é—Ç –Ω—É–∂–Ω—ã–π —Ä–∞–∑–º–µ—Ä
    if(ArraySize(VFI_Buffer) < rates_total || 
       ArraySize(VFI_EMA_Buffer) < rates_total || 
       ArraySize(Histogram_Buffer) < rates_total || 
       ArraySize(VCP_Buffer) < rates_total)
    {
        Print("Error: Buffer sizes are smaller than rates_total");
        return(0);
    }
    
    // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è 1: –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ –≤—ã—á–∏—Å–ª—è–µ–º —Ç–∏–ø–∏—á–Ω—ã–µ —Ü–µ–Ω—ã
    for(int i = calc_start; i < rates_total; i++)
    {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å —Ü–µ–Ω
        if(high[i] <= 0 || low[i] <= 0 || close[i] <= 0)
        {
            typical_array[i] = i > 0 ? typical_array[i-1] : close[i];
        }
        else
        {
            typical_array[i] = (high[i] + low[i] + close[i]) / 3.0;
        }
        
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ü–µ–Ω—ã –∑–∞–∫—Ä—ã—Ç–∏—è –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –ø–∞—Ç—Ç–µ—Ä–Ω–∞—Ö
        price_array[i] = close[i];
        
        // –í—ã—á–∏—Å–ª—è–µ–º logarithm difference
        if(i > 0 && typical_array[i-1] > 0 && typical_array[i] > 0)
        {
            double log_diff = MathLog(typical_array[i]) - MathLog(typical_array[i-1]);
            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —ç–∫—Å—Ç—Ä–µ–º–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
            if(MathAbs(log_diff) > 1.0)
                log_diff = log_diff > 0 ? 1.0 : -1.0;
            inter_array[i] = log_diff;
        }
        else
        {
            inter_array[i] = 0.0;
        }
    }
    
    int start;
    if(recalculate_all)
    {
        start = min_bars;
        // –ü—Ä–∏ –ø–æ–ª–Ω–æ–º –ø–µ—Ä–µ—Å—á–µ—Ç–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
        for(int i = 0; i < start && i < rates_total; i++)
        {
            VFI_Buffer[i] = EMPTY_VALUE;
            VFI_EMA_Buffer[i] = EMPTY_VALUE;
            Histogram_Buffer[i] = EMPTY_VALUE;
            Buy_Signal_Buffer[i] = EMPTY_VALUE;
            Sell_Signal_Buffer[i] = EMPTY_VALUE;
            Risk_Buffer[i] = EMPTY_VALUE;
            Risk_Colors_Buffer[i] = 0;
        }
    }
    else
    {
        // –ù–∞—á–∏–Ω–∞–µ–º —Ä–∞—Å—á–µ—Ç —Å –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Ä–∞—Å—Å—á–∏—Ç–∞–Ω–Ω–æ–≥–æ –±–∞—Ä–∞
        start = prev_calculated - 1;
        if(start < min_bars) start = min_bars;
    }
    
    // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è 2: –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –∫–∞–∫–∏–µ –æ–±—ä–µ–º—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å
    bool use_real = UseRealVolume && real_volumes_available;
    
    // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è 3: –ò–∑–±–µ–≥–∞–µ–º –º–Ω–æ–≥–æ–∫—Ä–∞—Ç–Ω—ã—Ö –≤—ã—á–∏—Å–ª–µ–Ω–∏–π –≤–Ω—É—Ç—Ä–∏ —Ü–∏–∫–ª–∞
    double alpha = 2.0 / (SignalLength + 1.0);
    double one_minus_alpha = 1.0 - alpha;
    
    //--- main calculation loop - –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π
    for(int i = start; i < rates_total; i++)
    {
        //--- calculate vinter (standard deviation of inter over 30 periods)
        double vinter = CalculateStdDev(inter_array, i, MathMin(30, i));
        
        // –ó–∞—â–∏—Ç–∞ –æ—Ç —Å–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π
        if(vinter < 0.0001)
            vinter = 0.0001;
        
        //--- calculate cutoff
        double cutoff = Coef * vinter * close[i];
        
        //--- –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è 4: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –±–æ–ª–µ–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–≥–æ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ —Ä–∞—Å—á–µ—Ç–∞ —Å—Ä–µ–¥–Ω–∏—Ö
        //--- calculate volume average over VFI_Length periods
        double vave = 0.0;
        int vol_start = MathMax(0, i - VFI_Length);
        int vol_count = 0;
        
        // –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ–¥—Å—á–µ—Ç —Å—Ä–µ–¥–Ω–µ–≥–æ –æ–±—ä–µ–º–∞
        for(int j = vol_start; j < i; j++)
        {
            double vol_value = use_real ? (double)volume[j] : (double)tick_volume[j];
            if(vol_value > 0) // –ò—Å–∫–ª—é—á–∞–µ–º –Ω—É–ª–µ–≤—ã–µ –æ–±—ä–µ–º—ã
            {
                vave += vol_value;
                vol_count++;
            }
        }
        
        // –ó–∞—â–∏—Ç–∞ –æ—Ç –¥–µ–ª–µ–Ω–∏—è –Ω–∞ –Ω–æ–ª—å
        if(vol_count > 0)
            vave /= (double)vol_count;
        else
            vave = use_real ? (double)volume[i] : (double)tick_volume[i];
            
        if(vave <= 0)
            vave = 1.0; // –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
        
        //--- calculate vmax
        double vmax = vave * VCoef;
        
        //--- calculate vc (min of current volume and vmax)
        double vol_current = use_real ? (double)volume[i] : (double)tick_volume[i];
        if(vol_current <= 0)
            vol_current = vave; // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ä–µ–¥–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
            
        double vc = MathMin(vol_current, vmax);
        
        //--- calculate mf (money flow)
        double mf = 0.0;
        if(i > 0)
            mf = typical_array[i] - typical_array[i-1];
        
        //--- calculate vcp - –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–æ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Ç–µ—Ä–Ω–∞—Ä–Ω–æ–≥–æ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞
        double vcp = mf > cutoff ? vc : (mf < -cutoff ? -vc : 0.0);
        VCP_Buffer[i] = vcp;
        
        //--- calculate VFI (sum of vcp over VFI_Length periods divided by vave)
        double vcp_sum = 0.0;
        int vcp_start = MathMax(0, i - VFI_Length + 1);
        
        for(int j = vcp_start; j <= i; j++)
        {
            vcp_sum += VCP_Buffer[j];
        }
        
        // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∑–∞—â–∏—Ç–∞ –æ—Ç –±–æ–ª—å—à–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π
        double vfi_raw = vcp_sum / vave;
        
        // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è 6: –ë—ã—Å—Ç—Ä–æ–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏–π
        if(vfi_raw > 1000)
            vfi_raw = 1000;
        else if(vfi_raw < -1000)
            vfi_raw = -1000;
        
        //--- apply smoothing if needed (SMA with period 3)
        if(SmoothVFI && i >= start + 2)
        {
            // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è 7: –ë–æ–ª–µ–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–µ —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ
            double vfi_sum = vfi_raw;
            int count = 1;
            
            for(int j = 1; j <= 2 && (i-j) >= start; j++)
            {
                if(VFI_Buffer[i-j] != EMPTY_VALUE)
                {
                    vfi_sum += VFI_Buffer[i-j];
                    count++;
                }
            }
            
            VFI_Buffer[i] = vfi_sum / count;
        }
        else
        {
            VFI_Buffer[i] = vfi_raw;
        }
        
        //--- calculate VFI EMA - –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ —Ä–∞—Å—Å—á–∏—Ç–∞–Ω–Ω–æ–π alpha
        if(i == start || VFI_EMA_Buffer[i-1] == EMPTY_VALUE)
        {
            VFI_EMA_Buffer[i] = VFI_Buffer[i];
        }
        else
        {
            VFI_EMA_Buffer[i] = alpha * VFI_Buffer[i] + one_minus_alpha * VFI_EMA_Buffer[i-1];
        }
        
        //--- calculate histogram - –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–æ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Ç–µ—Ä–Ω–∞—Ä–Ω–æ–≥–æ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞
        Histogram_Buffer[i] = ShowHisto ? VFI_Buffer[i] - VFI_EMA_Buffer[i] : EMPTY_VALUE;
        
        //--- Generate signals
        GenerateSignals(i);
        
        //--- Calculate risk level
        double risk_value = 0.0;
        ENUM_RISK_LEVEL risk_level = CalculateRiskLevel(i, RiskAssessmentPeriod, risk_value);
        Risk_Buffer[i] = risk_value * 0.5; // –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
        Risk_Colors_Buffer[i] = (int)risk_level;
    }
    
    // –†–∞—Å—á–µ—Ç –∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —É—Ä–æ–≤–Ω–µ–π –ø–µ—Ä–µ–∫—É–ø–ª–µ–Ω–Ω–æ—Å—Ç–∏/–ø–µ—Ä–µ–ø—Ä–æ–¥–∞–Ω–Ω–æ—Å—Ç–∏
    CalculateOverboughtOversoldLevels(rates_total - 1);
    
    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ñ–æ –ø–∞–Ω–µ–ª–∏
    if(ShowInfoPanel)
        UpdateInfoPanel(rates_total - 1, time);
    
    return(rates_total);
}

//+------------------------------------------------------------------+
//| Calculate Standard Deviation                                    |
//+------------------------------------------------------------------+
double CalculateStdDev(const double &array[], int pos, int period)
{
    if(pos < 1 || period < 1)
        return(0.0001); // –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤–º–µ—Å—Ç–æ 0
    
    int actual_period = MathMin(period, pos + 1);
    int start_pos = pos - actual_period + 1;
    
    //--- calculate mean & sum of squares in one loop
    double sum = 0.0;
    double sum_sq = 0.0;
    int valid_count = 0;
    
    for(int i = start_pos; i <= pos; i++)
    {
        if(i >= 0 && i < ArraySize(array))
        {
            double val = array[i];
            sum += val;
            sum_sq += val * val;
            valid_count++;
        }
    }
    
    if(valid_count == 0)
        return(0.0001);
        
    double mean = sum / valid_count;
    
    // Fast calculation of variance using E(X¬≤) - (E(X))¬≤
    double variance = (sum_sq / valid_count) - (mean * mean);
    
    // Avoid negative values due to rounding errors
    if(variance < 0)
        variance = 0;
    
    return MathMax(MathSqrt(variance), 0.0001);
}

//+------------------------------------------------------------------+
//| –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤                                             |
//+------------------------------------------------------------------+
void GenerateSignals(int i)
{
    // –î–æ–ª–∂–Ω–æ –±—ã—Ç—å —Ö–æ—Ç—è –±—ã –Ω–µ—Å–∫–æ–ª—å–∫–æ –±–∞—Ä–æ–≤ –∏—Å—Ç–æ—Ä–∏–∏
    if(i <= 5) 
        return;
    
    // Buy signal: VFI crosses its EMA upward
    bool buy_signal = false;
    if(VFI_Buffer[i] > VFI_EMA_Buffer[i] && 
       VFI_Buffer[i-1] <= VFI_EMA_Buffer[i-1])
    {
        buy_signal = true;
        Buy_Signal_Buffer[i] = VFI_Buffer[i] - 0.05; // –†–∞–∑–º–µ—â–∞–µ–º —Å—Ç—Ä–µ–ª–∫—É –Ω–µ–º–Ω–æ–≥–æ –Ω–∏–∂–µ –ª–∏–Ω–∏–∏
        
        if(EnableAlerts && i == ArraySize(VFI_Buffer) - 1)
            SendAlert(GetLocalizedText("buy_signal_detected"), TimeGMT());
    }
    
    // Sell signal: VFI crosses its EMA downward
    bool sell_signal = false;
    if(VFI_Buffer[i] < VFI_EMA_Buffer[i] && 
       VFI_Buffer[i-1] >= VFI_EMA_Buffer[i-1])
    {
        sell_signal = true;
        Sell_Signal_Buffer[i] = VFI_Buffer[i] + 0.05; // –†–∞–∑–º–µ—â–∞–µ–º —Å—Ç—Ä–µ–ª–∫—É –Ω–µ–º–Ω–æ–≥–æ –≤—ã—à–µ –ª–∏–Ω–∏–∏
        
        if(EnableAlerts && i == ArraySize(VFI_Buffer) - 1)
            SendAlert(GetLocalizedText("sell_signal_detected"), TimeGMT());
    }
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
    string username = GetComputerUserName();
    string current_datetime = GetCurrentDateTime();
    
    Print(GetLocalizedText("indicator_finished"));
    Print(GetLocalizedText("reason"), ": ", reason);
    Print(GetLocalizedText("time"), ": ", current_datetime);
    Print(GetLocalizedText("user"), ": ", username);
    
    // –£–¥–∞–ª—è–µ–º –≤—Å–µ —Å–æ–∑–¥–∞–Ω–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã
    ObjectDelete(0, info_panel_id);
    ObjectDelete(0, pattern_text_id);
    ObjectDelete(0, datetime_text_id);
    ObjectDelete(0, username_text_id);
    ObjectDelete(0, risk_text_id);
    ObjectDelete(0, trend_text_id);
    ObjectDelete(0, zones_text_id);
    ObjectDelete(0, info_panel_id + "_Title");
    
    ObjectDelete(0, overbought_zone_id);
    ObjectDelete(0, oversold_zone_id);
    ObjectDelete(0, overbought_line_id);
    ObjectDelete(0, oversold_line_id);
}
