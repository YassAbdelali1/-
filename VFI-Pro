#property copyright "Copyright 2025, Dubravaspb"
#property link      "https://www.mql5.com"
#property version   "1.01"
#property description "Advanced implementation of Dubravaspb's Volume Flow Indicator with comprehensive analysis tools featuring buy/sell signals with customizable parameters, pattern recognition, real-time risk assessment, dynamic zones, trend analysis, multilingual interface, and customizable alerts - perfect for incorporating volume analysis into any trading strategy with powerful confirmation tools."
#property indicator_separate_window
#property indicator_buffers 11
#property indicator_plots   9

//--- plot VFI
#property indicator_label1  "VFI"
#property indicator_type1   DRAW_LINE
#property indicator_color1  clrGreen
#property indicator_style1  STYLE_SOLID
#property indicator_width1  2

//--- plot VFI EMA
#property indicator_label2  "EMA of VFI"
#property indicator_type2   DRAW_LINE
#property indicator_color2  clrOrange
#property indicator_style2  STYLE_SOLID
#property indicator_width2  1

//--- plot Histogram
#property indicator_label3  "Histogram"
#property indicator_type3   DRAW_HISTOGRAM
#property indicator_color3  clrGray
#property indicator_style3  STYLE_SOLID
#property indicator_width3  3

//--- plot Buy Signal
#property indicator_label4  "Buy Signal"
#property indicator_type4   DRAW_ARROW
#property indicator_color4  clrLime
#property indicator_style4  STYLE_SOLID
#property indicator_width4  2

//--- plot Sell Signal
#property indicator_label5  "Sell Signal"
#property indicator_type5   DRAW_ARROW
#property indicator_color5  clrRed
#property indicator_style5  STYLE_SOLID
#property indicator_width5  2

//--- plot Risk Level
#property indicator_label9  "Risk Level"
#property indicator_type9   DRAW_COLOR_HISTOGRAM
#property indicator_color9  clrGreen, clrYellow, clrRed
#property indicator_style9  STYLE_SOLID
#property indicator_width9  2

//--- input parameters
input int      VFI_Length = 130;        // VFI length
input double   Coef = 0.2;              // Coefficient
input double   VCoef = 2.5;             // Max. vol. cutoff
input int      SignalLength = 5;        // Signal length
input bool     SmoothVFI = false;       // Smooth VFI
input bool     ShowHisto = false;       // Show Histogram
input bool     UseRealVolume = false;   // Use Real Volume (if available)
input bool     ShowPatterns = true;     // Enable Pattern Detection (now for display only)
input bool     EnableAlerts = true;     // Enable Sound Alerts
input bool     EnableNotifications = false; // Enable Push Notifications
input bool     EnableDynamicColors = true;  // Enable Dynamic Colors

// Настройки тренда и зон перекупленности/перепроданности
input int      TrendPeriod = 20;        // The period for determining the trend
input int      TrendSmoothingPeriod = 5; // Smoothing period to determine the trend
input int      ZonesAutoCalculationPeriod = 200; // The period for automatic zone calculation
input double   ZonePercentile = 80.0;   // Percentile for zones (80% = upper/lower 20%)
input color    OverboughtColor = clrRed; // The color of the overbought zone
input color    OversoldColor = clrGreen; // Oversold zone color
input int      ZoneTransparency = 80;   // Transparency of zones (0-255, where 0=transparent, 255=opaque)

// Настройки информационной панели
input bool     ShowInfoPanel = true;    // Show Information Panel
input ENUM_BASE_CORNER InfoPanelCorner = CORNER_LEFT_UPPER; // Info Panel Corner
input int      InfoPanelX = 10;         // Info Panel X Distance
input int      InfoPanelY = 10;         // Info Panel Y Distance
input int      InfoPanelWidth = 200;    // Info Panel Width
input int      InfoPanelHeight = 140;   // Info Panel Height (увеличена для тренда)
input color    InfoPanelColor = clrDarkBlue; // Info Panel Background Color
input color    InfoPanelTextColor = clrWhite; // Info Panel Text Color

input int      RiskAssessmentPeriod = 14;   // Risk Assessment Period

//--- indicator buffers
double VFI_Buffer[];
double VFI_EMA_Buffer[];
double Histogram_Buffer[];
double VCP_Buffer[];
double Buy_Signal_Buffer[];
double Sell_Signal_Buffer[];
double DoubleBottom_Buffer[];
double DoubleTop_Buffer[];
double Divergence_Buffer[];
double Risk_Buffer[];
double Risk_Colors_Buffer[];

//--- arrays for calculations
double inter_array[];
double typical_array[];
double volatility_array[];
double price_array[];
double trend_buffer[];         // Буфер для хранения данных о тренде

//--- global variables
bool real_volumes_available = false;
bool is_russian_system = false;
int last_calculated = 0; // Добавляем для отслеживания пересчета
datetime last_alert_time = 0;
int alert_delay = 300; // 5 минут между алертами
datetime indicator_load_time = 0;  // Время загрузки индикатора - ДОБАВЛЕНО

// Для мини-дисплея информации
string info_panel_id = "VFI_InfoPanel";
string pattern_text_id = "VFI_PatternText";
string datetime_text_id = "VFI_DatetimeText";
string username_text_id = "VFI_UsernameText";
string risk_text_id = "VFI_RiskText";
string trend_text_id = "VFI_TrendText";    // Текстовый объект для тренда
string zones_text_id = "VFI_ZonesText";    // Текстовый объект для зон
datetime last_update_time = 0;
int update_frequency = 5; // Обновлять информацию каждые 5 секунд

// Глобальные переменные для уровней перекупленности/перепроданности
double dynamic_overbought_level = 0;
double dynamic_oversold_level = 0;
datetime last_zone_calculation = 0;
int zone_calculation_delay = 300; // 5 минут между пересчетами

// Идентификаторы объектов зон
string overbought_zone_id = "VFI_Overbought_Zone";
string oversold_zone_id = "VFI_Oversold_Zone";
string overbought_line_id = "VFI_Overbought_Line";
string oversold_line_id = "VFI_Oversold_Line";

// Enum для уровней риска
enum ENUM_RISK_LEVEL
{
    RISK_LOW = 0,    // Низкий риск (зеленый)
    RISK_MEDIUM = 1, // Средний риск (желтый)
    RISK_HIGH = 2    // Высокий риск (красный)
};

// Enum для направления тренда
enum ENUM_TREND_DIRECTION
{
    TREND_UP = 1,       // Восходящий тренд
    TREND_DOWN = -1,    // Нисходящий тренд
    TREND_SIDEWAYS = 0  // Боковой тренд
};

// Переменные для отслеживания сессии
datetime session_start_time = 0;

//+------------------------------------------------------------------+
//| Определение языка системы                                       |
//+------------------------------------------------------------------+
bool IsRussianSystem()
{
    // Получаем язык терминала
    string terminal_language = TerminalInfoString(TERMINAL_LANGUAGE);
    
    // Проверяем, является ли язык русским
    if(terminal_language == "Russian" || terminal_language == "Русский" || 
       StringFind(terminal_language, "RU") >= 0 || StringFind(terminal_language, "ru") >= 0)
    {
        return true;
    }
    
    // Дополнительная проверка через локализацию чисел
    string test_number = DoubleToString(1.5, 1);
    if(StringFind(test_number, ",") >= 0) // В русской локали десятичный разделитель - запятая
    {
        return true;
    }
    
    return false;
}

//+------------------------------------------------------------------+
//| Получение локализованного текста                                |
//+------------------------------------------------------------------+
string GetLocalizedText(string key)
{
    if(!is_russian_system)
    {
        // English texts
        if(key == "volume_check_header") return "           VFI INDICATOR VOLUME CHECK           ";
        if(key == "symbol") return "Symbol";
        if(key == "datetime") return "Date/time";
        if(key == "user") return "User";
        if(key == "execution_type") return "Execution type";
        if(key == "terminal_paths") return "DEBUG - Terminal paths";
        if(key == "bars_analyzed") return "Bars analyzed";
        if(key == "tick_volumes") return "TICK VOLUMES";
        if(key == "average") return "Average";
        if(key == "maximum") return "Maximum";
        if(key == "minimum") return "Minimum";
        if(key == "zero_bars") return "Bars with zero volume";
        if(key == "real_volumes") return "REAL VOLUMES";
        if(key == "real_volumes_unavailable") return "REAL VOLUMES: Unavailable";
        if(key == "quality_assessment") return "QUALITY ASSESSMENT";
        if(key == "recommendation") return "RECOMMENDATION";
        if(key == "indicator_settings") return "INDICATOR SETTINGS";
        if(key == "will_use_real") return "Will use: REAL VOLUMES";
        if(key == "will_use_tick") return "Will use: TICK VOLUMES";
        if(key == "yes") return "YES";
        if(key == "no") return "NO";
        if(key == "error_no_data") return "❌ ERROR: Could not get price data!";
        if(key == "critical_no_volumes") return "❌ CRITICAL: Very little volume data";
        if(key == "poor_no_variation") return "⚠️ POOR: Volumes hardly change";
        if(key == "satisfactory_tick_only") return "⚠️ SATISFACTORY: Tick volumes only";
        if(key == "excellent_real_volumes") return " EXCELLENT: Quality real volumes";
        if(key == "good_real_gaps") return " GOOD: Real volumes with gaps";
        if(key == "change_instrument") return "Change instrument or broker";
        if(key == "may_work_incorrectly") return "Indicator may work incorrectly";
        if(key == "will_work_less_accurate") return "Indicator will work, but less accurately";
        if(key == "will_work_max_accurate") return "Indicator will work with maximum accuracy";
        if(key == "will_work_correctly") return "Indicator will work correctly";
        if(key == "indicator_finished") return "         VFI INDICATOR FINISHED WORK         ";
        if(key == "reason") return "Reason";
        if(key == "time") return "Time";
        if(key == "parameter_error") return "Parameter Error";
        if(key == "invalid_vfi_length") return "VFI_Length must be >= 10";
        if(key == "invalid_signal_length") return "SignalLength must be >= 1";
        if(key == "invalid_coefficients") return "Coefficients must be positive";
        if(key == "settings_changed") return "Settings changed - recalculating all data";
        if(key == "buy_signals_enabled") return "Buy signals enabled";
        if(key == "sell_signals_enabled") return "Sell signals enabled";
        if(key == "pattern_recognition_enabled") return "Pattern recognition enabled";
        if(key == "alerts_enabled") return "Alerts enabled";
        if(key == "notifications_enabled") return "Push notifications enabled";
        if(key == "dynamic_colors_enabled") return "Dynamic colors enabled";
        if(key == "info_panel_enabled") return "Information panel enabled";
        if(key == "buy_signal_detected") return "VFI Buy Signal detected";
        if(key == "sell_signal_detected") return "VFI Sell Signal detected";
        if(key == "double_bottom_detected") return "Double Bottom pattern detected";
        if(key == "double_top_detected") return "Double Top pattern detected";
        if(key == "divergence_detected") return "Divergence pattern detected";
        if(key == "risk_assessment") return "Risk Level";
        if(key == "risk_low") return "Low";
        if(key == "risk_medium") return "Medium";
        if(key == "risk_high") return "High";
        if(key == "current_user") return "Current User";
        if(key == "current_time") return "Current Time";
        if(key == "detected_patterns") return "Detected Patterns";
        if(key == "no_patterns_detected") return "No patterns detected";
        if(key == "panel_title") return "VFI Info Panel";
        // Тексты для тренда
        if(key == "trend") return "Trend";
        if(key == "trend_up") return "Uptrend";
        if(key == "trend_down") return "Downtrend";
        if(key == "trend_sideways") return "Sideways";
        if(key == "trend_strength") return "Strength";
        if(key == "overbought_zones") return "Overbought zones enabled";
        if(key == "oversold_zones") return "Oversold zones enabled";
        // Тексты для автоматических зон
        if(key == "auto_zones") return "Auto zones calculation enabled";
        if(key == "overbought_level") return "Overbought level";
        if(key == "oversold_level") return "Oversold level";
        if(key == "zones") return "Zones";
        if(key == "recalculating_zones") return "Recalculating zone levels";
        // Тексты для сессии
        if(key == "minutes") return "min";
        if(key == "hours") return "h";
        if(key == "days") return "d";
    }
    else
    {
        // Russian texts
        if(key == "volume_check_header") return "           ПРОВЕРКА ОБЪЕМОВ VFI ИНДИКАТОРА           ";
        if(key == "symbol") return "Символ";
        if(key == "datetime") return "Дата/время";
        if(key == "user") return "Пользователь";
        if(key == "execution_type") return "Тип исполнения";
        if(key == "terminal_paths") return "DEBUG - Пути терминала";
        if(key == "bars_analyzed") return "Получено баров для анализа";
        if(key == "tick_volumes") return "ТИКОВЫЕ ОБЪЕМЫ";
        if(key == "average") return "Средний";
        if(key == "maximum") return "Максимальный";
        if(key == "minimum") return "Минимальный";
        if(key == "zero_bars") return "Баров с нулевым объемом";
        if(key == "real_volumes") return "РЕАЛЬНЫЕ ОБЪЕМЫ";
        if(key == "real_volumes_unavailable") return "РЕАЛЬНЫЕ ОБЪЕМЫ: Недоступны";
        if(key == "quality_assessment") return "ОЦЕНКА КАЧЕСТВА";
        if(key == "recommendation") return "РЕКОМЕНДАЦИЯ";
        if(key == "indicator_settings") return "НАСТРОЙКИ ИНДИКАТОРА";
        if(key == "will_use_real") return "Будут использованы: РЕАЛЬНЫЕ ОБЪЕМЫ";
        if(key == "will_use_tick") return "Будут использованы: ТИКОВЫЕ ОБЪЕМЫ";
        if(key == "yes") return "ДА";
        if(key == "no") return "НЕТ";
        if(key == "error_no_data") return "❌ ОШИБКА: Не удалось получить данные по ценам!";
        if(key == "critical_no_volumes") return "❌ КРИТИЧНО: Очень мало данных по объемам";
        if(key == "poor_no_variation") return "⚠️ ПЛОХО: Объемы практически не меняются";
        if(key == "satisfactory_tick_only") return "⚠️ УДОВЛЕТВОРИТЕЛЬНО: Только тиковые объемы";
        if(key == "excellent_real_volumes") return " ОТЛИЧНО: Качественные реальные объемы";
        if(key == "good_real_gaps") return " ХОРОШО: Реальные объемы с пропусками";
        if(key == "change_instrument") return "Смените инструмент или брокера";
        if(key == "may_work_incorrectly") return "Индикатор может работать некорректно";
        if(key == "will_work_less_accurate") return "Индикатор будет работать, но менее точно";
        if(key == "will_work_max_accurate") return "Индикатор будет работать максимально точно";
        if(key == "will_work_correctly") return "Индикатор будет работать корректно";
        if(key == "indicator_finished") return "         VFI ИНДИКАТОР ЗАВЕРШИЛ РАБОТУ         ";
        if(key == "reason") return "Причина";
        if(key == "time") return "Время";
        if(key == "parameter_error") return "Ошибка параметров";
        if(key == "invalid_vfi_length") return "VFI_Length должно быть >= 10";
        if(key == "invalid_signal_length") return "SignalLength должно быть >= 1";
        if(key == "invalid_coefficients") return "Коэффициенты должны быть положительными";
        if(key == "settings_changed") return "Настройки изменены - пересчитываем все данные";
        if(key == "buy_signals_enabled") return "Сигналы покупки включены";
        if(key == "sell_signals_enabled") return "Сигналы продажи включены";
        if(key == "pattern_recognition_enabled") return "Распознавание паттернов включено";
        if(key == "alerts_enabled") return "Звуковые алерты включены";
        if(key == "notifications_enabled") return "Push-уведомления включены";
        if(key == "dynamic_colors_enabled") return "Динамические цвета включены";
        if(key == "info_panel_enabled") return "Информационная панель включена";
        if(key == "buy_signal_detected") return "Обнаружен сигнал покупки VFI";
        if(key == "sell_signal_detected") return "Обнаружен сигнал продажи VFI";
        if(key == "double_bottom_detected") return "Обнаружен паттерн Двойное Дно";
        if(key == "double_top_detected") return "Обнаружен паттерн Двойная Вершина";
        if(key == "divergence_detected") return "Обнаружен паттерн Дивергенция";
        if(key == "risk_assessment") return "Уровень риска";
        if(key == "risk_low") return "Низкий";
        if(key == "risk_medium") return "Средний";
        if(key == "risk_high") return "Высокий";
        if(key == "current_user") return "Текущий пользователь";
        if(key == "current_time") return "Текущее время";
        if(key == "detected_patterns") return "Обнаруженные паттерны";
        if(key == "no_patterns_detected") return "Паттерны не обнаружены";
        if(key == "panel_title") return "VFI Инфо Панель";
        // Тексты для тренда
        if(key == "trend") return "Тренд";
        if(key == "trend_up") return "Восходящий";
        if(key == "trend_down") return "Нисходящий";
        if(key == "trend_sideways") return "Боковой";
        if(key == "trend_strength") return "Сила";
        if(key == "overbought_zones") return "Зоны перекупленности включены";
        if(key == "oversold_zones") return "Зоны перепроданности включены";
        // Тексты для автоматических зон
        if(key == "auto_zones") return "Автоматический расчет зон включен";
        if(key == "overbought_level") return "Уровень перекупленности";
        if(key == "oversold_level") return "Уровень перепроданности";
        if(key == "zones") return "Зоны";
        if(key == "recalculating_zones") return "Пересчёт уровней зон";
        // Тексты для сессии
        if(key == "minutes") return "мин";
        if(key == "hours") return "ч";
        if(key == "days") return "д";
    }
    
    return key;
}

//+------------------------------------------------------------------+
//| Получение имени пользователя компьютера                         |
//+------------------------------------------------------------------+
string GetComputerUserName()
{
    string username = "YassAbdelali1"; // Значение по умолчанию
    
    // Получаем путь к данным терминала
    string data_path = TerminalInfoString(TERMINAL_DATA_PATH);
    
    if(StringLen(data_path) > 0)
    {
        int pos = StringFind(data_path, "Users\\");
        if(pos >= 0)
        {
            int start = pos + 6; // длина "Users\"
            int end = StringFind(data_path, "\\", start);
            if(end > start)
            {
                string extracted = StringSubstr(data_path, start, end - start);
                if(StringLen(extracted) > 0 && extracted != "AppData" && 
                   extracted != "Roaming" && extracted != "MetaQuotes")
                {
                    username = extracted;
                }
            }
        }
    }
    
    // Очистка имени пользователя
    StringReplace(username, " ", "_");
    if(StringLen(username) > 20)
        username = StringSubstr(username, 0, 20);
    
    return username;
}

//+------------------------------------------------------------------+
//| Получение текущей даты и времени                                |
//+------------------------------------------------------------------+
string GetCurrentDateTime()
{
    // Получаем текущее время из терминала
    datetime current_time = TimeGMT(); // Используем GMT время
    
    MqlDateTime dt;
    TimeToStruct(current_time, dt);
    
    return StringFormat("%04d-%02d-%02d %02d:%02d:%02d", 
                      dt.year, dt.mon, dt.day, dt.hour, dt.min, dt.sec);
}

//+------------------------------------------------------------------+
//| Получение времени работы сессии                                 |
//+------------------------------------------------------------------+
string GetSessionUptime()
{
    if(session_start_time == 0)
        return "00:00";
    
    datetime current_time = TimeGMT();
    int uptime_seconds = (int)(current_time - session_start_time);
    
    int days = uptime_seconds / 86400;
    uptime_seconds %= 86400;
    int hours = uptime_seconds / 3600;
    uptime_seconds %= 3600;
    int minutes = uptime_seconds / 60;
    
    string uptime_str = "";
    
    if(days > 0)
        uptime_str += IntegerToString(days) + GetLocalizedText("days") + " ";
    if(hours > 0)
        uptime_str += IntegerToString(hours) + GetLocalizedText("hours") + " ";
    
    uptime_str += IntegerToString(minutes) + GetLocalizedText("minutes");
    
    return uptime_str;
}

//+------------------------------------------------------------------+
//| Send Alert Function - ИСПРАВЛЕНО                                |
//+------------------------------------------------------------------+
void SendAlert(string message, datetime signal_time)
{
    datetime current_time = TimeCurrent();
    
    // Проверяем, прошло ли достаточно времени с предыдущего алерта
    if(current_time - last_alert_time < alert_delay)
        return;
    
    // Пропускаем алерты для исторических баров (до загрузки индикатора)
    if(signal_time < indicator_load_time)
        return;
        
    // Сохраняем время отправки алерта
    last_alert_time = current_time;
    
    // Выводим сообщение в журнал
    Print(message);
    
    // Отправляем звуковой алерт
    if(EnableAlerts)
        Alert(message);
        
    // Отправляем push-уведомление
    if(EnableNotifications)
        SendNotification(message);
}

//+------------------------------------------------------------------+
//| Автоматический расчет уровней перекупленности/перепроданности  |
//+------------------------------------------------------------------+
void CalculateOverboughtOversoldLevels(int bar_pos)
{
    if(bar_pos < ZonesAutoCalculationPeriod)
        return;
    
    // Проверяем, не слишком ли часто пересчитываем зоны
    datetime current_time = TimeCurrent();
    if(current_time - last_zone_calculation < zone_calculation_delay && dynamic_overbought_level != 0)
        return;
        
    last_zone_calculation = current_time;
    
    // Собираем статистику по значениям индикатора
    double vfi_values[];
    ArrayResize(vfi_values, ZonesAutoCalculationPeriod);
    
    int count = 0;
    for(int i = bar_pos; i > bar_pos - ZonesAutoCalculationPeriod && i >= 0; i--)
    {
        if(VFI_Buffer[i] != EMPTY_VALUE)
        {
            vfi_values[count] = VFI_Buffer[i];
            count++;
        }
    }
    
    // Если недостаточно данных, используем значения по умолчанию
    if(count < ZonesAutoCalculationPeriod / 2)
    {
        // Значения по умолчанию
        dynamic_overbought_level = 1.0;
        dynamic_oversold_level = -1.0;
        Print("Warning: Not enough data to calculate zones, using default values");
        return;
    }
    
    // Подгоняем размер массива под количество реальных элементов
    ArrayResize(vfi_values, count);
    
    // Сортируем для определения процентилей
    ArraySort(vfi_values);
    
    // Вычисляем позиции процентилей
    int upper_pos = (int)((count - 1) * ZonePercentile / 100.0);
    int lower_pos = (int)((count - 1) * (100.0 - ZonePercentile) / 100.0);
    
    // Проверяем корректность индексов
    if(upper_pos >= count) upper_pos = count - 1;
    if(lower_pos < 0) lower_pos = 0;
    
    // Обновляем уровни
    dynamic_overbought_level = vfi_values[upper_pos];
    dynamic_oversold_level = vfi_values[lower_pos];
    
    // Проверяем, что overbought > oversold
    if(dynamic_overbought_level <= dynamic_oversold_level)
    {
        // Если что-то пошло не так, используем среднее и стандартное отклонение
        double sum = 0, sum_sq = 0;
        for(int i = 0; i < count; i++)
        {
            sum += vfi_values[i];
            sum_sq += MathPow(vfi_values[i], 2);
        }
        double mean = sum / count;
        double std_dev = MathSqrt(sum_sq / count - mean * mean);
        
        dynamic_overbought_level = mean + 1.5 * std_dev;
        dynamic_oversold_level = mean - 1.5 * std_dev;
    }
    
    Print("🔄 ", GetLocalizedText("recalculating_zones"), ": OB=", 
          DoubleToString(dynamic_overbought_level, 4), ", OS=", 
          DoubleToString(dynamic_oversold_level, 4));
    
    // Обновляем объекты зон для визуализации
    UpdateZoneObjects(bar_pos);
}

//+------------------------------------------------------------------+
//| Обновление объектов зон - ИСПРАВЛЕНО                           |
//+------------------------------------------------------------------+
void UpdateZoneObjects(int bar_pos)
{
    // Удаляем старые объекты зон
    ObjectDelete(0, overbought_zone_id);
    ObjectDelete(0, oversold_zone_id);
    ObjectDelete(0, overbought_line_id);
    ObjectDelete(0, oversold_line_id);
    
    // Если уровни не рассчитаны или равны 0, установим базовые значения
    if(dynamic_overbought_level == 0 || dynamic_oversold_level == 0)
    {
        dynamic_overbought_level = 1.0;  // Значение по умолчанию для уровня перекупленности
        dynamic_oversold_level = -1.0;   // Значение по умолчанию для уровня перепроданности
    }
    
    // Получаем окно индикатора
    int window = ChartWindowFind();
    if(window < 0) return;
    
    // Определяем верхнюю и нижнюю границы графика для зон
    double chart_max = 0, chart_min = 0;
    ChartGetDouble(0, CHART_PRICE_MAX, window, chart_max);
    ChartGetDouble(0, CHART_PRICE_MIN, window, chart_min);
    
    // Если значения недоступны или неправильные, вычисляем примерные границы
    if(chart_max <= 0 || chart_min >= 0)
    {
        chart_max = MathMax(2.0, dynamic_overbought_level * 1.5);
        chart_min = MathMin(-2.0, dynamic_oversold_level * 1.5);
        
        // Ищем максимальные и минимальные значения индикатора
        double max_value = -DBL_MAX;
        double min_value = DBL_MAX;
        
        for(int i = bar_pos; i >= MathMax(0, bar_pos - 500); i--)
        {
            if(VFI_Buffer[i] != EMPTY_VALUE)
            {
                if(VFI_Buffer[i] > max_value) max_value = VFI_Buffer[i];
                if(VFI_Buffer[i] < min_value) min_value = VFI_Buffer[i];
            }
        }
        
        // Добавляем запас для границ
        chart_max = MathMax(chart_max, max_value * 1.2);
        chart_min = MathMin(chart_min, min_value * 1.2);
    }
    
    // Получаем время для временных координат объектов
    datetime time_start = iTime(Symbol(), PERIOD_CURRENT, MathMin(bar_pos, 100));
    datetime time_end = TimeCurrent() + 86400; // Добавляем сутки для отображения вправо
    
    // Если время недоступно, используем текущее время
    if(time_start <= 0) time_start = TimeCurrent() - 86400 * 10; // Минус 10 суток
    if(time_end <= 0) time_end = TimeCurrent() + 86400; // Плюс сутки
    
    Print("Creating zones at bar pos: ", bar_pos, ", times: ", time_start, " - ", time_end);
    Print("Chart bounds: min=", chart_min, ", max=", chart_max);
    Print("Zone levels: OB=", dynamic_overbought_level, ", OS=", dynamic_oversold_level);
    
    // Создаем горизонтальные линии для уровней (для более четкого обозначения уровней)
    if(ObjectCreate(0, overbought_line_id, OBJ_TREND, window, time_start, dynamic_overbought_level, 
                                                         time_end, dynamic_overbought_level))
    {
        ObjectSetInteger(0, overbought_line_id, OBJPROP_COLOR, OverboughtColor);
        ObjectSetInteger(0, overbought_line_id, OBJPROP_STYLE, STYLE_DASH);
        ObjectSetInteger(0, overbought_line_id, OBJPROP_WIDTH, 1);
        ObjectSetInteger(0, overbought_line_id, OBJPROP_RAY_RIGHT, false);
        ObjectSetInteger(0, overbought_line_id, OBJPROP_RAY_LEFT, false);
        ObjectSetInteger(0, overbought_line_id, OBJPROP_BACK, true);
        ObjectSetInteger(0, overbought_line_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, overbought_line_id, OBJPROP_SELECTED, false);
        ObjectSetInteger(0, overbought_line_id, OBJPROP_HIDDEN, true);
    }
    
    if(ObjectCreate(0, oversold_line_id, OBJ_TREND, window, time_start, dynamic_oversold_level, 
                                                      time_end, dynamic_oversold_level))
    {
        ObjectSetInteger(0, oversold_line_id, OBJPROP_COLOR, OversoldColor);
        ObjectSetInteger(0, oversold_line_id, OBJPROP_STYLE, STYLE_DASH);
        ObjectSetInteger(0, oversold_line_id, OBJPROP_WIDTH, 1);
        ObjectSetInteger(0, oversold_line_id, OBJPROP_RAY_RIGHT, false);
        ObjectSetInteger(0, oversold_line_id, OBJPROP_RAY_LEFT, false);
        ObjectSetInteger(0, oversold_line_id, OBJPROP_BACK, true);
        ObjectSetInteger(0, oversold_line_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, oversold_line_id, OBJPROP_SELECTED, false);
        ObjectSetInteger(0, oversold_line_id, OBJPROP_HIDDEN, true);
    }
    
    // Создаем заливку зон с использованием OBJ_RECTANGLE
    // Зона перекупленности (верхняя заливка)
    if(ObjectCreate(0, overbought_zone_id, OBJ_RECTANGLE, window, 
                   time_start, dynamic_overbought_level, time_end, chart_max))
    {
        // Настраиваем цвет с учетом прозрачности
        ObjectSetInteger(0, overbought_zone_id, OBJPROP_COLOR, OverboughtColor);
        
        // Настраиваем заливку
        ObjectSetInteger(0, overbought_zone_id, OBJPROP_FILL, true);
        ObjectSetInteger(0, overbought_zone_id, OBJPROP_BGCOLOR, OverboughtColor);
        
        // Настраиваем другие свойства
        ObjectSetInteger(0, overbought_zone_id, OBJPROP_BACK, true);
        ObjectSetInteger(0, overbought_zone_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, overbought_zone_id, OBJPROP_SELECTED, false);
        ObjectSetInteger(0, overbought_zone_id, OBJPROP_HIDDEN, true);
        ObjectSetInteger(0, overbought_zone_id, OBJPROP_WIDTH, 1);
        ObjectSetInteger(0, overbought_zone_id, OBJPROP_ZORDER, 0); // На задний план
    }
    
    // Зона перепроданности (нижняя заливка)
    if(ObjectCreate(0, oversold_zone_id, OBJ_RECTANGLE, window, 
                   time_start, chart_min, time_end, dynamic_oversold_level))
    {
        // Настраиваем цвет с учетом прозрачности
        ObjectSetInteger(0, oversold_zone_id, OBJPROP_COLOR, OversoldColor);
        
        // Настраиваем заливку
        ObjectSetInteger(0, oversold_zone_id, OBJPROP_FILL, true);
        ObjectSetInteger(0, oversold_zone_id, OBJPROP_BGCOLOR, OversoldColor);
        
        // Настраиваем другие свойства
        ObjectSetInteger(0, oversold_zone_id, OBJPROP_BACK, true);
        ObjectSetInteger(0, oversold_zone_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, oversold_zone_id, OBJPROP_SELECTED, false);
        ObjectSetInteger(0, oversold_zone_id, OBJPROP_HIDDEN, true);
        ObjectSetInteger(0, oversold_zone_id, OBJPROP_WIDTH, 1);
        ObjectSetInteger(0, oversold_zone_id, OBJPROP_ZORDER, 0); // На задний план
    }
}

//+------------------------------------------------------------------+
//| Определение тренда                                             |
//+------------------------------------------------------------------+
ENUM_TREND_DIRECTION DetermineTrend(int bar_pos, int period, double &strength)
{
    if(bar_pos <= period || ArraySize(VFI_Buffer) <= period)
        return TREND_SIDEWAYS;
    
    // Используем скользящее среднее VFI для более гладкого определения тренда
    double ma_current = 0, ma_previous = 0;
    int valid_bars = 0;
    
    // Рассчитываем SMA для текущего периода
    for(int i = 0; i < TrendSmoothingPeriod; i++)
    {
        if(bar_pos - i >= 0 && VFI_Buffer[bar_pos - i] != EMPTY_VALUE)
        {
            ma_current += VFI_Buffer[bar_pos - i];
            valid_bars++;
        }
    }
    
    if(valid_bars > 0)
        ma_current /= valid_bars;
    else
        return TREND_SIDEWAYS;
    
    // Рассчитываем SMA для предыдущего периода
    valid_bars = 0;
    for(int i = period; i < period + TrendSmoothingPeriod; i++)
    {
        if(bar_pos - i >= 0 && VFI_Buffer[bar_pos - i] != EMPTY_VALUE)
        {
            ma_previous += VFI_Buffer[bar_pos - i];
            valid_bars++;
        }
    }
    
    if(valid_bars > 0)
        ma_previous /= valid_bars;
    else
        return TREND_SIDEWAYS;
    
    // Определяем направление тренда
    double diff = ma_current - ma_previous;
    
    // Нормализуем силу тренда на основе изменения за период
    double max_diff = 0;
    for(int i = 0; i < period; i++)
    {
        if(bar_pos - i >= 0 && bar_pos - i - 1 >= 0)
        {
            double bar_diff = MathAbs(VFI_Buffer[bar_pos - i] - VFI_Buffer[bar_pos - i - 1]);
            if(bar_diff > max_diff)
                max_diff = bar_diff;
        }
    }
    
    // Сила тренда - нормализованное значение от 0 до 1
    if(max_diff > 0)
        strength = MathMin(MathAbs(diff) / max_diff, 1.0);
    else
        strength = 0;
    
    // Определяем боковой тренд при малых изменениях
    if(MathAbs(diff) < 0.05)
        return TREND_SIDEWAYS;
        
    if(diff > 0)
        return TREND_UP;
    else
        return TREND_DOWN;
}

//+------------------------------------------------------------------+
//| Создание информационной панели                                  |
//+------------------------------------------------------------------+
void CreateInfoPanel()
{
    if(!ShowInfoPanel)
        return;
    
    // Создаем фон панели
    if(ObjectFind(0, info_panel_id) < 0)
    {
        ObjectCreate(0, info_panel_id, OBJ_RECTANGLE_LABEL, 0, 0, 0);
        ObjectSetInteger(0, info_panel_id, OBJPROP_CORNER, InfoPanelCorner);
        ObjectSetInteger(0, info_panel_id, OBJPROP_XDISTANCE, InfoPanelX);
        ObjectSetInteger(0, info_panel_id, OBJPROP_YDISTANCE, InfoPanelY);
        ObjectSetInteger(0, info_panel_id, OBJPROP_XSIZE, InfoPanelWidth);
        ObjectSetInteger(0, info_panel_id, OBJPROP_YSIZE, InfoPanelHeight);
        ObjectSetInteger(0, info_panel_id, OBJPROP_BGCOLOR, InfoPanelColor);
        ObjectSetInteger(0, info_panel_id, OBJPROP_BORDER_TYPE, BORDER_FLAT);
        ObjectSetInteger(0, info_panel_id, OBJPROP_COLOR, InfoPanelTextColor);
        ObjectSetInteger(0, info_panel_id, OBJPROP_STYLE, STYLE_SOLID);
        ObjectSetInteger(0, info_panel_id, OBJPROP_WIDTH, 1);
        ObjectSetInteger(0, info_panel_id, OBJPROP_BACK, false);
        ObjectSetInteger(0, info_panel_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, info_panel_id, OBJPROP_SELECTED, false);
        ObjectSetInteger(0, info_panel_id, OBJPROP_HIDDEN, true);
        ObjectSetInteger(0, info_panel_id, OBJPROP_ZORDER, 1);
    }
    
    // Адаптируем координаты в зависимости от угла
    int title_x, title_y, dt_y, user_y, risk_y, pattern_y, trend_y, zones_y;
    
    // Создаем заголовок панели
    string title_id = info_panel_id + "_Title";
    if(ObjectFind(0, title_id) < 0)
    {
        // Определяем координаты в зависимости от угла
        switch(InfoPanelCorner)
        {
            case CORNER_LEFT_UPPER:
            case CORNER_RIGHT_UPPER:
                title_y = 15;
                dt_y = 35;
                user_y = 55;
                risk_y = 75;
                pattern_y = 95;
                trend_y = 115;
                zones_y = 135;
                break;
            case CORNER_LEFT_LOWER:
            case CORNER_RIGHT_LOWER:
                title_y = InfoPanelHeight - 15;
                dt_y = InfoPanelHeight - 35;
                user_y = InfoPanelHeight - 55;
                risk_y = InfoPanelHeight - 75;
                pattern_y = InfoPanelHeight - 95;
                trend_y = InfoPanelHeight - 115;
                zones_y = InfoPanelHeight - 135;
                break;
        }
        
        // Определяем X координату в зависимости от угла
        switch(InfoPanelCorner)
        {
            case CORNER_LEFT_UPPER:
            case CORNER_LEFT_LOWER:
                title_x = InfoPanelWidth - 10;
                break;
            case CORNER_RIGHT_UPPER:
            case CORNER_RIGHT_LOWER:
                title_x = 10;
                break;
        }
        
        // Создаем заголовок
        ObjectCreate(0, title_id, OBJ_LABEL, 0, 0, 0);
        ObjectSetInteger(0, title_id, OBJPROP_CORNER, InfoPanelCorner);
        ObjectSetInteger(0, title_id, OBJPROP_XDISTANCE, title_x);
        ObjectSetInteger(0, title_id, OBJPROP_YDISTANCE, title_y);
        ObjectSetInteger(0, title_id, OBJPROP_COLOR, InfoPanelTextColor);
        ObjectSetInteger(0, title_id, OBJPROP_FONTSIZE, 10);
        ObjectSetInteger(0, title_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, title_id, OBJPROP_HIDDEN, true);
        ObjectSetString(0, title_id, OBJPROP_TEXT, GetLocalizedText("panel_title"));
        ObjectSetString(0, title_id, OBJPROP_FONT, "Arial Bold");
        
        // Устанавливаем выравнивание текста
        if(InfoPanelCorner == CORNER_LEFT_UPPER || InfoPanelCorner == CORNER_LEFT_LOWER)
            ObjectSetInteger(0, title_id, OBJPROP_ANCHOR, ANCHOR_RIGHT_UPPER);
    }
    
    // Текст для даты и времени
    if(ObjectFind(0, datetime_text_id) < 0)
    {
        ObjectCreate(0, datetime_text_id, OBJ_LABEL, 0, 0, 0);
        ObjectSetInteger(0, datetime_text_id, OBJPROP_CORNER, InfoPanelCorner);
        ObjectSetInteger(0, datetime_text_id, OBJPROP_XDISTANCE, title_x);
        ObjectSetInteger(0, datetime_text_id, OBJPROP_YDISTANCE, dt_y);
        ObjectSetInteger(0, datetime_text_id, OBJPROP_COLOR, InfoPanelTextColor);
        ObjectSetInteger(0, datetime_text_id, OBJPROP_FONTSIZE, 8);
        ObjectSetInteger(0, datetime_text_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, datetime_text_id, OBJPROP_HIDDEN, true);
        ObjectSetString(0, datetime_text_id, OBJPROP_TEXT, GetLocalizedText("current_time") + ": " + GetCurrentDateTime());
        
        // Устанавливаем выравнивание текста
        if(InfoPanelCorner == CORNER_LEFT_UPPER || InfoPanelCorner == CORNER_LEFT_LOWER)
            ObjectSetInteger(0, datetime_text_id, OBJPROP_ANCHOR, ANCHOR_RIGHT_UPPER);
    }
    
    // Текст для имени пользователя
    if(ObjectFind(0, username_text_id) < 0)
    {
        ObjectCreate(0, username_text_id, OBJ_LABEL, 0, 0, 0);
        ObjectSetInteger(0, username_text_id, OBJPROP_CORNER, InfoPanelCorner);
        ObjectSetInteger(0, username_text_id, OBJPROP_XDISTANCE, title_x);
        ObjectSetInteger(0, username_text_id, OBJPROP_YDISTANCE, user_y);
        ObjectSetInteger(0, username_text_id, OBJPROP_COLOR, InfoPanelTextColor);
        ObjectSetInteger(0, username_text_id, OBJPROP_FONTSIZE, 8);
        ObjectSetInteger(0, username_text_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, username_text_id, OBJPROP_HIDDEN, true);
        ObjectSetString(0, username_text_id, OBJPROP_TEXT, GetLocalizedText("current_user") + ": " + GetComputerUserName());
        
        // Устанавливаем выравнивание текста
        if(InfoPanelCorner == CORNER_LEFT_UPPER || InfoPanelCorner == CORNER_LEFT_LOWER)
            ObjectSetInteger(0, username_text_id, OBJPROP_ANCHOR, ANCHOR_RIGHT_UPPER);
    }
    
    // Текст для уровня риска
    if(ObjectFind(0, risk_text_id) < 0)
    {
        ObjectCreate(0, risk_text_id, OBJ_LABEL, 0, 0, 0);
        ObjectSetInteger(0, risk_text_id, OBJPROP_CORNER, InfoPanelCorner);
        ObjectSetInteger(0, risk_text_id, OBJPROP_XDISTANCE, title_x);
        ObjectSetInteger(0, risk_text_id, OBJPROP_YDISTANCE, risk_y);
        ObjectSetInteger(0, risk_text_id, OBJPROP_COLOR, InfoPanelTextColor);
        ObjectSetInteger(0, risk_text_id, OBJPROP_FONTSIZE, 8);
        ObjectSetInteger(0, risk_text_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, risk_text_id, OBJPROP_HIDDEN, true);
        ObjectSetString(0, risk_text_id, OBJPROP_TEXT, GetLocalizedText("risk_assessment") + ": " + GetLocalizedText("risk_medium"));
        
        // Устанавливаем выравнивание текста
        if(InfoPanelCorner == CORNER_LEFT_UPPER || InfoPanelCorner == CORNER_LEFT_LOWER)
            ObjectSetInteger(0, risk_text_id, OBJPROP_ANCHOR, ANCHOR_RIGHT_UPPER);
    }
    
    // Текст для обнаруженных паттернов
    if(ObjectFind(0, pattern_text_id) < 0)
    {
        ObjectCreate(0, pattern_text_id, OBJ_LABEL, 0, 0, 0);
        ObjectSetInteger(0, pattern_text_id, OBJPROP_CORNER, InfoPanelCorner);
        ObjectSetInteger(0, pattern_text_id, OBJPROP_XDISTANCE, title_x);
        ObjectSetInteger(0, pattern_text_id, OBJPROP_YDISTANCE, pattern_y);
        ObjectSetInteger(0, pattern_text_id, OBJPROP_COLOR, InfoPanelTextColor);
        ObjectSetInteger(0, pattern_text_id, OBJPROP_FONTSIZE, 8);
        ObjectSetInteger(0, pattern_text_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, pattern_text_id, OBJPROP_HIDDEN, true);
        ObjectSetString(0, pattern_text_id, OBJPROP_TEXT, GetLocalizedText("detected_patterns") + ": -");
        
        // Устанавливаем выравнивание текста
        if(InfoPanelCorner == CORNER_LEFT_UPPER || InfoPanelCorner == CORNER_LEFT_LOWER)
            ObjectSetInteger(0, pattern_text_id, OBJPROP_ANCHOR, ANCHOR_RIGHT_UPPER);
    }
    
    // Текст для текущего тренда
    if(ObjectFind(0, trend_text_id) < 0)
    {
        ObjectCreate(0, trend_text_id, OBJ_LABEL, 0, 0, 0);
        ObjectSetInteger(0, trend_text_id, OBJPROP_CORNER, InfoPanelCorner);
        ObjectSetInteger(0, trend_text_id, OBJPROP_XDISTANCE, title_x);
        ObjectSetInteger(0, trend_text_id, OBJPROP_YDISTANCE, trend_y);
        ObjectSetInteger(0, trend_text_id, OBJPROP_COLOR, InfoPanelTextColor);
        ObjectSetInteger(0, trend_text_id, OBJPROP_FONTSIZE, 8);
        ObjectSetInteger(0, trend_text_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, trend_text_id, OBJPROP_HIDDEN, true);
        ObjectSetString(0, trend_text_id, OBJPROP_TEXT, GetLocalizedText("trend") + ": " + GetLocalizedText("trend_sideways"));
        
        // Устанавливаем выравнивание текста
        if(InfoPanelCorner == CORNER_LEFT_UPPER || InfoPanelCorner == CORNER_LEFT_LOWER)
            ObjectSetInteger(0, trend_text_id, OBJPROP_ANCHOR, ANCHOR_RIGHT_UPPER);
    }
    
    // Текст для уровней зон перекупленности/перепроданности
    if(ObjectFind(0, zones_text_id) < 0)
    {
        ObjectCreate(0, zones_text_id, OBJ_LABEL, 0, 0, 0);
        ObjectSetInteger(0, zones_text_id, OBJPROP_CORNER, InfoPanelCorner);
        ObjectSetInteger(0, zones_text_id, OBJPROP_XDISTANCE, title_x);
        ObjectSetInteger(0, zones_text_id, OBJPROP_YDISTANCE, zones_y);
        ObjectSetInteger(0, zones_text_id, OBJPROP_COLOR, InfoPanelTextColor);
        ObjectSetInteger(0, zones_text_id, OBJPROP_FONTSIZE, 8);
        ObjectSetInteger(0, zones_text_id, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, zones_text_id, OBJPROP_HIDDEN, true);
        ObjectSetString(0, zones_text_id, OBJPROP_TEXT, GetLocalizedText("zones") + ": -");
        
        // Устанавливаем выравнивание текста
        if(InfoPanelCorner == CORNER_LEFT_UPPER || InfoPanelCorner == CORNER_LEFT_LOWER)
            ObjectSetInteger(0, zones_text_id, OBJPROP_ANCHOR, ANCHOR_RIGHT_UPPER);
    }
}

//+------------------------------------------------------------------+
//| Обновление информации на панели                                 |
//+------------------------------------------------------------------+
void UpdateInfoPanel(int bar_index, const datetime &time[])
{
    if(!ShowInfoPanel || bar_index <= 0)
        return;
        
    datetime current_time = TimeCurrent();
    
    // Обновляем панель не чаще, чем раз в указанное время
    if(current_time - last_update_time < update_frequency)
        return;
        
    last_update_time = current_time;
    
    // Обновляем уровень риска
    double risk_value = 0;
    ENUM_RISK_LEVEL risk_level = CalculateRiskLevel(bar_index, RiskAssessmentPeriod, risk_value);
    string risk_text = "";
    
    switch(risk_level)
    {
        case RISK_LOW:
            risk_text = GetLocalizedText("risk_assessment") + ": " + GetLocalizedText("risk_low");
            ObjectSetInteger(0, risk_text_id, OBJPROP_COLOR, clrLimeGreen);
            break;
        case RISK_MEDIUM:
            risk_text = GetLocalizedText("risk_assessment") + ": " + GetLocalizedText("risk_medium");
            ObjectSetInteger(0, risk_text_id, OBJPROP_COLOR, clrYellow);
            break;
        case RISK_HIGH:
            risk_text = GetLocalizedText("risk_assessment") + ": " + GetLocalizedText("risk_high");
            ObjectSetInteger(0, risk_text_id, OBJPROP_COLOR, clrTomato);
            break;
    }
    
    ObjectSetString(0, risk_text_id, OBJPROP_TEXT, risk_text);
    
    // Обновляем информацию о паттернах
    string patterns = "";
    bool has_patterns = false;
    
    // Проверяем последние 5 баров на наличие паттернов
    for(int i = bar_index; i >= MathMax(0, bar_index - 5); i--)
    {
        // Получим цены напрямую из буфера
        double close[];
        int copied = CopyClose(Symbol(), PERIOD_CURRENT, i - VFI_Length, VFI_Length + 1, close);

        if(copied > 0)
        {
            if(IsDoubleBottom(i, VFI_Length))
            {
                patterns += "W ";  // Double Bottom
                has_patterns = true;
            }
            
            if(IsDoubleTop(i, VFI_Length))
            {
                patterns += "M ";  // Double Top
                has_patterns = true;
            }
            
            if(IsDivergence(i, VFI_Length, close))
            {
                patterns += "D ";  // Divergence
                has_patterns = true;
            }
        }
    }
    
    if(has_patterns)
        ObjectSetString(0, pattern_text_id, OBJPROP_TEXT, GetLocalizedText("detected_patterns") + ": " + patterns);
    else
        ObjectSetString(0, pattern_text_id, OBJPROP_TEXT, GetLocalizedText("detected_patterns") + ": " + GetLocalizedText("no_patterns_detected"));
        
    // Обновляем информацию о времени
    ObjectSetString(0, datetime_text_id, OBJPROP_TEXT, GetLocalizedText("current_time") + ": " + GetCurrentDateTime());
    
    // Обновляем информацию о пользователе
    ObjectSetString(0, username_text_id, OBJPROP_TEXT, GetLocalizedText("current_user") + ": " + GetComputerUserName());
    
    // Обновляем информацию о тренде
    double trend_strength = 0;
    ENUM_TREND_DIRECTION trend_direction = DetermineTrend(bar_index, TrendPeriod, trend_strength);
    string trend_text = "";
    color trend_color;
    
    switch(trend_direction)
    {
        case TREND_UP:
            trend_text = GetLocalizedText("trend") + ": " + GetLocalizedText("trend_up") + " (" + 
                         GetLocalizedText("trend_strength") + ": " + DoubleToString(trend_strength * 100, 0) + "%)";
            trend_color = clrLimeGreen;
            break;
        case TREND_DOWN:
            trend_text = GetLocalizedText("trend") + ": " + GetLocalizedText("trend_down") + " (" + 
                         GetLocalizedText("trend_strength") + ": " + DoubleToString(trend_strength * 100, 0) + "%)";
            trend_color = clrTomato;
            break;
        default:
            trend_text = GetLocalizedText("trend") + ": " + GetLocalizedText("trend_sideways");
            trend_color = clrGray;
            break;
    }
    
    ObjectSetString(0, trend_text_id, OBJPROP_TEXT, trend_text);
    ObjectSetInteger(0, trend_text_id, OBJPROP_COLOR, trend_color);
    
    // Обновляем информацию о зонах перекупленности/перепроданности
    string zones_text = GetLocalizedText("zones") + ": " + 
                      GetLocalizedText("overbought_level") + "=" + DoubleToString(dynamic_overbought_level, 2) +
                      ", " + GetLocalizedText("oversold_level") + "=" + DoubleToString(dynamic_oversold_level, 2);
    
    ObjectSetString(0, zones_text_id, OBJPROP_TEXT, zones_text);
}

//+------------------------------------------------------------------+
//| Удаление информационной панели                                  |
//+------------------------------------------------------------------+
void DeleteInfoPanel()
{
    ObjectDelete(0, info_panel_id);
    ObjectDelete(0, info_panel_id + "_Title");
    ObjectDelete(0, pattern_text_id);
    ObjectDelete(0, datetime_text_id);
    ObjectDelete(0, username_text_id);
    ObjectDelete(0, risk_text_id);
    ObjectDelete(0, trend_text_id);
    ObjectDelete(0, zones_text_id);
}

//+------------------------------------------------------------------+
//| Расчет уровня риска для сигнала                                 |
//+------------------------------------------------------------------+
ENUM_RISK_LEVEL CalculateRiskLevel(int bar_pos, int period, double &risk_value)
{
    if(bar_pos < period)
    {
        risk_value = 0.0;
        return RISK_MEDIUM;
    }
    
    // Вычисляем волатильность VFI
    double vfi_sum = 0.0;
    double vfi_sum_sq = 0.0;
    double max_vfi = -DBL_MAX;
    double min_vfi = DBL_MAX;
    int valid_count = 0;
    
    for(int i = bar_pos; i > bar_pos - period && i >= 0; i--)
    {
        if(VFI_Buffer[i] != EMPTY_VALUE)
        {
            vfi_sum += VFI_Buffer[i];
            vfi_sum_sq += MathPow(VFI_Buffer[i], 2);
            if(VFI_Buffer[i] > max_vfi) max_vfi = VFI_Buffer[i];
            if(VFI_Buffer[i] < min_vfi) min_vfi = VFI_Buffer[i];
            valid_count++;
        }
    }
    
    if(valid_count < period / 2)
    {
        risk_value = 0.0;
        return RISK_MEDIUM;
    }
    
    double vfi_avg = vfi_sum / valid_count;
    double vfi_std = MathSqrt(vfi_sum_sq / valid_count - MathPow(vfi_avg, 2));
    
    // Вычисляем расстояние между текущим значением и средним
    double current_distance = MathAbs(VFI_Buffer[bar_pos] - vfi_avg);
    
    // Нормализованное значение риска от 0 до 1
    double risk_normalized = 0.0;
    
    // Расстояние выхода за границы диапазона (% от макс-мин)
    if(vfi_std > 0)
    {
        risk_normalized = current_distance / (vfi_std * 3); // 3 сигмы
        risk_normalized = MathMin(risk_normalized, 1.0); // Ограничиваем максимум
    }
    
    // Дополнительное влияние близости к экстремумам
    double range_total = max_vfi - min_vfi;
    if(range_total > 0)
    {
        double extreme_factor = 0.0;
        
        if(VFI_Buffer[bar_pos] > vfi_avg) // Выше среднего
            extreme_factor = (VFI_Buffer[bar_pos] - vfi_avg) / (max_vfi - vfi_avg);
        else // Ниже среднего
            extreme_factor = (vfi_avg - VFI_Buffer[bar_pos]) / (vfi_avg - min_vfi);
            
        risk_normalized = risk_normalized * 0.7 + extreme_factor * 0.3; // 70/30 весовой коэффициент
    }
    
    risk_value = risk_normalized;
    
    // Определяем уровень риска
    if(risk_normalized < 0.33)
        return RISK_LOW;
    else if(risk_normalized < 0.66)
        return RISK_MEDIUM;
    else
        return RISK_HIGH;
}

//+------------------------------------------------------------------+
//| Динамическая настройка цветов индикатора                       |
//+------------------------------------------------------------------+
void UpdateDynamicColors(int bar_pos)
{
    if(!EnableDynamicColors || bar_pos <= 0)
        return;
    
    // Вычисляем относительное положение индикатора
    double vfi_current = VFI_Buffer[bar_pos];
    double vfi_prev = VFI_Buffer[bar_pos - 1];
    
    // Определяем цвета в зависимости от положения и направления движения
    color vfi_color, ema_color;
    
    if(vfi_current > 0)
    {
        // Положительное значение VFI
        if(vfi_current > vfi_prev)
            vfi_color = clrLimeGreen;  // Рост над нулём - ярко-зелёный
        else
            vfi_color = clrGreen;      // Падение над нулём - обычный зелёный
    }
    else
    {
        // Отрицательное значение VFI
        if(vfi_current < vfi_prev)
            vfi_color = clrCrimson;    // Падение под нулём - ярко-красный
        else
            vfi_color = clrRed;        // Рост под нулём - обычный красный
    }
    
    // Цвет EMA линии меняем в зависимости от пересечения с VFI
    if(vfi_current > VFI_EMA_Buffer[bar_pos])
        ema_color = clrOrange;         // VFI выше EMA - оранжевый
    else
        ema_color = clrDarkOrange;     // VFI ниже EMA - темно-оранжевый
    
    // Применяем цвета динамически
    PlotIndexSetInteger(0, PLOT_LINE_COLOR, vfi_color);
    PlotIndexSetInteger(1, PLOT_LINE_COLOR, ema_color);
}

//+------------------------------------------------------------------+
//| Custom indicator initialization function                         |
//+------------------------------------------------------------------+
int OnInit()
{
    // Инициализация значений пользователя и времени
    session_start_time = TimeGMT();
    indicator_load_time = TimeCurrent();  // Устанавливаем время загрузки индикатора
    Print("Indicator loaded at: ", TimeToString(indicator_load_time));
    
    // Validate input parameters
    if(VFI_Length < 10)
    {
        Print("❌ ", GetLocalizedText("parameter_error"), ": ", GetLocalizedText("invalid_vfi_length"));
        return(INIT_PARAMETERS_INCORRECT);
    }
    
    if(SignalLength < 1)
    {
        Print("❌ ", GetLocalizedText("parameter_error"), ": ", GetLocalizedText("invalid_signal_length"));
        return(INIT_PARAMETERS_INCORRECT);
    }
    
    if(Coef <= 0 || VCoef <= 0)
    {
        Print("❌ ", GetLocalizedText("parameter_error"), ": ", GetLocalizedText("invalid_coefficients"));
        return(INIT_PARAMETERS_INCORRECT);
    }
    
    // Проверка параметров зон
    if(ZonesAutoCalculationPeriod < 20)
    {
        Print("❌ ", GetLocalizedText("parameter_error"), ": ", "ZonesAutoCalculationPeriod must be >= 20");
        return(INIT_PARAMETERS_INCORRECT);
    }
    
    if(ZonePercentile <= 0 || ZonePercentile >= 100)
    {
        Print("❌ ", GetLocalizedText("parameter_error"), ": ", "ZonePercentile must be between 0 and 100");
        return(INIT_PARAMETERS_INCORRECT);
    }
    
    // Determine system language
    is_russian_system = IsRussianSystem();
    
    // ВАЖНО: Сбрасываем счетчик при смене настроек
    last_calculated = 0;
    
    //--- indicator buffers mapping
    SetIndexBuffer(0, VFI_Buffer, INDICATOR_DATA);
    SetIndexBuffer(1, VFI_EMA_Buffer, INDICATOR_DATA);
    SetIndexBuffer(2, Histogram_Buffer, INDICATOR_DATA);
    SetIndexBuffer(3, Buy_Signal_Buffer, INDICATOR_DATA);
    SetIndexBuffer(4, Sell_Signal_Buffer, INDICATOR_DATA);
    SetIndexBuffer(5, DoubleBottom_Buffer, INDICATOR_CALCULATIONS);  // Теперь только для расчетов
    SetIndexBuffer(6, DoubleTop_Buffer, INDICATOR_CALCULATIONS);     // Теперь только для расчетов
    SetIndexBuffer(7, Divergence_Buffer, INDICATOR_CALCULATIONS);    // Теперь только для расчетов
    SetIndexBuffer(8, Risk_Buffer, INDICATOR_DATA);
    SetIndexBuffer(9, Risk_Colors_Buffer, INDICATOR_COLOR_INDEX);
    SetIndexBuffer(10, VCP_Buffer, INDICATOR_CALCULATIONS);
    
    // Инициализация буфера для тренда
    ArrayResize(trend_buffer, 0);
    
    //--- set arrow codes for the signals
    PlotIndexSetInteger(3, PLOT_ARROW, 233); // Up arrow for buy
    PlotIndexSetInteger(4, PLOT_ARROW, 234); // Down arrow for sell
    
    // Скрываем графические элементы для паттернов
    PlotIndexSetInteger(5, PLOT_DRAW_TYPE, DRAW_NONE);  // Double Bottom
    PlotIndexSetInteger(6, PLOT_DRAW_TYPE, DRAW_NONE);  // Double Top
    PlotIndexSetInteger(7, PLOT_DRAW_TYPE, DRAW_NONE);  // Divergence
    
    //--- set accuracy
    IndicatorSetInteger(INDICATOR_DIGITS, 4);
    
    //--- set short name
    IndicatorSetString(INDICATOR_SHORTNAME, "VFI_DubravaSPB(" + 
                      IntegerToString(VFI_Length) + "," + 
                      DoubleToString(Coef, 1) + "," + 
                      DoubleToString(VCoef, 1) + ")");
    
    //--- set zero level
    IndicatorSetDouble(INDICATOR_LEVELVALUE, 0, 0.0);
    
    //--- set empty values
    PlotIndexSetDouble(0, PLOT_EMPTY_VALUE, EMPTY_VALUE);
    PlotIndexSetDouble(1, PLOT_EMPTY_VALUE, EMPTY_VALUE);
    PlotIndexSetDouble(2, PLOT_EMPTY_VALUE, EMPTY_VALUE);
    PlotIndexSetDouble(3, PLOT_EMPTY_VALUE, EMPTY_VALUE);
    PlotIndexSetDouble(4, PLOT_EMPTY_VALUE, EMPTY_VALUE);
    PlotIndexSetDouble(8, PLOT_EMPTY_VALUE, EMPTY_VALUE);
    
    //--- hide histogram if not needed
    if(!ShowHisto)
        PlotIndexSetInteger(2, PLOT_DRAW_TYPE, DRAW_NONE);
    else
        PlotIndexSetInteger(2, PLOT_DRAW_TYPE, DRAW_HISTOGRAM);
    
    //--- initialize calculation arrays
    ArrayResize(inter_array, 0);
    ArrayResize(typical_array, 0);
    ArrayResize(volatility_array, 0);
    ArrayResize(price_array, 0);
    
    // Создаем информационную панель
    if(ShowInfoPanel)
    {
        CreateInfoPanel();
        Print(" ", GetLocalizedText("info_panel_enabled"));
    }
    
    // Log that signals are enabled
    Print(" ", GetLocalizedText("buy_signals_enabled"));
    Print(" ", GetLocalizedText("sell_signals_enabled"));
    
    // Log additional features
    if(ShowPatterns)
        Print(" ", GetLocalizedText("pattern_recognition_enabled"));
    
    if(EnableAlerts)
        Print(" ", GetLocalizedText("alerts_enabled"));
        
    if(EnableNotifications)
        Print(" ", GetLocalizedText("notifications_enabled"));
        
    if(EnableDynamicColors)
        Print(" ", GetLocalizedText("dynamic_colors_enabled"));
    
    // Логируем включение автоматического определения зон
    Print(" ", GetLocalizedText("auto_zones"));
    
    //--- check volume data
    CheckVolumeData();
    
    return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Проверка наличия и качества данных по объемам                   |
//+------------------------------------------------------------------+
void CheckVolumeData()
{
    string symbol = Symbol();
    string username = GetComputerUserName();
    string datetime_str = GetCurrentDateTime();
    
    Print(GetLocalizedText("volume_check_header"));
    Print(" ", GetLocalizedText("symbol"), ": ", symbol);
    Print(" ", GetLocalizedText("datetime"), ": ", datetime_str, " UTC");
    Print(" ", GetLocalizedText("user"), ": ", username);
    
    // Debug terminal paths
    Print(" ", GetLocalizedText("terminal_paths"), ":");
    Print("   TERMINAL_PATH: ", TerminalInfoString(TERMINAL_PATH));
    Print("   TERMINAL_DATA_PATH: ", TerminalInfoString(TERMINAL_DATA_PATH));
    Print("   TERMINAL_COMMONDATA_PATH: ", TerminalInfoString(TERMINAL_COMMONDATA_PATH));
    
    // Check execution type
    ENUM_SYMBOL_TRADE_EXECUTION execution = (ENUM_SYMBOL_TRADE_EXECUTION)SymbolInfoInteger(symbol, SYMBOL_TRADE_EXEMODE);
    string exec_type = "";
    switch(execution)
    {
        case SYMBOL_TRADE_EXECUTION_REQUEST: exec_type = "Request"; break;
        case SYMBOL_TRADE_EXECUTION_INSTANT: exec_type = "Instant"; break;
        case SYMBOL_TRADE_EXECUTION_MARKET: exec_type = "Market"; break;
        case SYMBOL_TRADE_EXECUTION_EXCHANGE: exec_type = "Exchange"; break;
        default: exec_type = "Unknown";
    }
    Print(" ", GetLocalizedText("execution_type"), ": ", exec_type);
    
    // Get test data
    MqlRates rates[];
    int copied = CopyRates(symbol, PERIOD_CURRENT, 0, 100, rates);
    
    if(copied <= 0)
    {
        Print(" ", GetLocalizedText("error_no_data"));
        return;
    }
    
    Print(" ", GetLocalizedText("bars_analyzed"), ": ", copied);
    
    // Analyze tick volumes
    long total_tick_volume = 0;
    long max_tick_volume = 0;
    long min_tick_volume = LONG_MAX;
    int zero_tick_volumes = 0;
    
    // Analyze real volumes
    long total_real_volume = 0;
    long max_real_volume = 0;
    long min_real_volume = LONG_MAX;
    int zero_real_volumes = 0;
    bool has_real_volumes = false;
    
    for(int i = 0; i < copied; i++)
    {
        // Tick volumes
        if(rates[i].tick_volume == 0)
            zero_tick_volumes++;
        
        total_tick_volume += rates[i].tick_volume;
        
        if(rates[i].tick_volume > max_tick_volume)
            max_tick_volume = rates[i].tick_volume;
            
        if(rates[i].tick_volume < min_tick_volume && rates[i].tick_volume > 0)
            min_tick_volume = rates[i].tick_volume;
        
        // Real volumes
        if(rates[i].real_volume > 0)
        {
            has_real_volumes = true;
            total_real_volume += rates[i].real_volume;
            
            if(rates[i].real_volume > max_real_volume)
                max_real_volume = rates[i].real_volume;
                
            if(rates[i].real_volume < min_real_volume)
                min_real_volume = rates[i].real_volume;
        }
        else
        {
            zero_real_volumes++;
        }
    }
    
    // Tick volume results
    double avg_tick_volume = (double)total_tick_volume / copied;
    Print(" ", GetLocalizedText("tick_volumes"), ":");
    Print("   ", GetLocalizedText("average"), ": ", (long)avg_tick_volume);
    Print("   ", GetLocalizedText("maximum"), ": ", max_tick_volume);
    Print("   ", GetLocalizedText("minimum"), ": ", min_tick_volume);
    Print("   ", GetLocalizedText("zero_bars"), ": ", zero_tick_volumes, " (", 
          MathRound(zero_tick_volumes * 100.0 / copied), "%)");
    
    // Real volume results
    real_volumes_available = has_real_volumes;
    if(has_real_volumes)
    {
        double avg_real_volume = (double)total_real_volume / (copied - zero_real_volumes);
        Print(" ", GetLocalizedText("real_volumes"), ":");
        Print("   ", GetLocalizedText("average"), ": ", (long)avg_real_volume);
        Print("   ", GetLocalizedText("maximum"), ": ", max_real_volume);
        Print("   ", GetLocalizedText("minimum"), ": ", min_real_volume);
        Print("   ", GetLocalizedText("zero_bars"), ": ", zero_real_volumes, " (", 
              MathRound(zero_real_volumes * 100.0 / copied), "%)");
    }
    else
    {
        Print(" ", GetLocalizedText("real_volumes_unavailable"));
    }
    
    // Data quality assessment
    string quality_assessment = "";
    string recommendation = "";
    
    if(!has_real_volumes && zero_tick_volumes > copied * 0.5)
    {
        quality_assessment = GetLocalizedText("critical_no_volumes");
        recommendation = GetLocalizedText("change_instrument");
    }
    else if(!has_real_volumes && (max_tick_volume - min_tick_volume) < avg_tick_volume * 0.1)
    {
        quality_assessment = GetLocalizedText("poor_no_variation");
        recommendation = GetLocalizedText("may_work_incorrectly");
    }
    else if(!has_real_volumes)
    {
        quality_assessment = GetLocalizedText("satisfactory_tick_only");
        recommendation = GetLocalizedText("will_work_less_accurate");
    }
    else if(has_real_volumes && zero_real_volumes < copied * 0.1)
    {
        quality_assessment = GetLocalizedText("excellent_real_volumes");
        recommendation = GetLocalizedText("will_work_max_accurate");
    }
    else
    {
        quality_assessment = GetLocalizedText("good_real_gaps");
        recommendation = GetLocalizedText("will_work_correctly");
    }
    
    Print(" ", GetLocalizedText("quality_assessment"), ": ", quality_assessment);
    Print(" ", GetLocalizedText("recommendation"), ": ", recommendation);
    
    // Indicator settings
    Print(" ", GetLocalizedText("indicator_settings"), ":");
    
    if(has_real_volumes && UseRealVolume)
    {
        Print("   ", GetLocalizedText("will_use_real"));
    }
    else
    {
        Print("   ", GetLocalizedText("will_use_tick"));
    }
    
    Print("   VFI Length: ", VFI_Length);
    Print("   Coefficient: ", Coef);
    Print("   Max Volume Cutoff: ", VCoef);
    Print("   Signal Length: ", SignalLength);
    Print("   Trend Period: ", TrendPeriod);
    Print("   Zones Auto Calculation Period: ", ZonesAutoCalculationPeriod);
    Print("   Zone Percentile: ", ZonePercentile);
    Print("   Zone Transparency: ", ZoneTransparency);
    Print("   Smooth VFI: ", SmoothVFI ? GetLocalizedText("yes") : GetLocalizedText("no"));
    Print("   Show Histogram: ", ShowHisto ? GetLocalizedText("yes") : GetLocalizedText("no"));
    Print("   Show Patterns: ", ShowPatterns ? GetLocalizedText("yes") : GetLocalizedText("no"));
    Print("   Enable Alerts: ", EnableAlerts ? GetLocalizedText("yes") : GetLocalizedText("no"));
    Print("   Enable Notifications: ", EnableNotifications ? GetLocalizedText("yes") : GetLocalizedText("no"));
    Print("   Enable Dynamic Colors: ", EnableDynamicColors ? GetLocalizedText("yes") : GetLocalizedText("no"));
    Print("   Show Info Panel: ", ShowInfoPanel ? GetLocalizedText("yes") : GetLocalizedText("no"));
    Print("   Risk Assessment Period: ", RiskAssessmentPeriod);
}

//+------------------------------------------------------------------+
//| Определение двойного дна в индикаторе                          |
//+------------------------------------------------------------------+
bool IsDoubleBottom(int bar_pos, int range)
{
    if(bar_pos < range * 2)
        return false;
        
    // Минимальное расстояние между впадинами
    int min_distance = range / 3;
    if(min_distance < 3) min_distance = 3;
    
    // Ищем две впадины
    double min_value1 = VFI_Buffer[bar_pos];
    int min_pos1 = bar_pos;
    
    // Ищем первую впадину
    for(int i = bar_pos - range; i <= bar_pos; i++)
    {
        if(i >= 0 && VFI_Buffer[i] != EMPTY_VALUE && VFI_Buffer[i] < min_value1)
        {
            min_value1 = VFI_Buffer[i];
            min_pos1 = i;
        }
    }
    
    // Если первая впадина совпадает с текущим баром, значит она не найдена
    if(min_pos1 == bar_pos)
        return false;
        
    // Ищем вторую впадину до первой впадины
    double min_value2 = VFI_Buffer[0];
    int min_pos2 = -1;
    
    for(int i = min_pos1 - min_distance; i >= min_pos1 - range && i >= 0; i--)
    {
        if(VFI_Buffer[i] != EMPTY_VALUE && VFI_Buffer[i] <= min_value1 * 1.05 && 
           VFI_Buffer[i] >= min_value1 * 0.95) // Похожий уровень (±5%)
        {
            min_value2 = VFI_Buffer[i];
            min_pos2 = i;
            break;
        }
    }
    
    // Если вторая впадина не найдена
    if(min_pos2 < 0)
        return false;
        
    // Проверяем, есть ли пик между впадинами
    double max_between = min_value1;
    for(int i = min_pos2; i <= min_pos1; i++)
    {
        if(VFI_Buffer[i] != EMPTY_VALUE && VFI_Buffer[i] > max_between)
        {
            max_between = VFI_Buffer[i];
        }
    }
    
    // Пик между впадинами должен быть выше минимума хотя бы на 20%
    return (max_between > min_value1 * 1.2);
}

//+------------------------------------------------------------------+
//| Определение двойной вершины в индикаторе                       |
//+------------------------------------------------------------------+
bool IsDoubleTop(int bar_pos, int range)
{
    if(bar_pos < range * 2)
        return false;
        
    // Минимальное расстояние между пиками
    int min_distance = range / 3;
    if(min_distance < 3) min_distance = 3;
    
    // Ищем два пика
    double max_value1 = VFI_Buffer[bar_pos];
    int max_pos1 = bar_pos;
    
    // Ищем первый пик
    for(int i = bar_pos - range; i <= bar_pos; i++)
    {
        if(i >= 0 && VFI_Buffer[i] != EMPTY_VALUE && VFI_Buffer[i] > max_value1)
        {
            max_value1 = VFI_Buffer[i];
            max_pos1 = i;
        }
    }
    
    // Если первый пик совпадает с текущим баром, значит он не найден
    if(max_pos1 == bar_pos)
        return false;
        
    // Ищем второй пик до первого пика
    double max_value2 = VFI_Buffer[0];
    int max_pos2 = -1;
    
    for(int i = max_pos1 - min_distance; i >= max_pos1 - range && i >= 0; i--)
    {
        if(VFI_Buffer[i] != EMPTY_VALUE && VFI_Buffer[i] >= max_value1 * 0.95 && 
           VFI_Buffer[i] <= max_value1 * 1.05) // Похожий уровень (±5%)
        {
            max_value2 = VFI_Buffer[i];
            max_pos2 = i;
            break;
        }
    }
    
    // Если второй пик не найден
    if(max_pos2 < 0)
        return false;
        
    // Проверяем, есть ли впадина между пиками
    double min_between = max_value1;
    for(int i = max_pos2; i <= max_pos1; i++)
    {
        if(VFI_Buffer[i] != EMPTY_VALUE && VFI_Buffer[i] < min_between)
        {
            min_between = VFI_Buffer[i];
        }
    }
    
    // Впадина между пиками должна быть ниже максимума хотя бы на 20%
    return (min_between < max_value1 * 0.8);
}

//+------------------------------------------------------------------+
//| Определение дивергенции между ценой и индикатором               |
//+------------------------------------------------------------------+
bool IsDivergence(int bar_pos, int range, const double &close[])
{
    if(bar_pos < range * 2)
        return false;
        
    // Минимальное расстояние между точками
    int min_distance = range / 3;
    if(min_distance < 3) min_distance = 3;
    
    // Находим максимумы/минимумы в цене и индикаторе
    double price_high1 = close[0];
    double price_low1 = close[0];
    double vfi_high1 = VFI_Buffer[bar_pos];
    double vfi_low1 = VFI_Buffer[bar_pos];
    int price_high_pos1 = bar_pos;
    int price_low_pos1 = bar_pos;
    int vfi_high_pos1 = bar_pos;
    int vfi_low_pos1 = bar_pos;
    
    // Проверяем диапазоны
    int start_pos = MathMin(bar_pos, ArraySize(close) - 1);
    
    // Находим первые экстремумы
    for(int i = 0; i < range / 2 && i < start_pos; i++)
    {
        int idx = start_pos - i;
        // Максимумы и минимумы цены
        if(idx >= 0 && idx < ArraySize(close))
        {
            if(close[idx] > price_high1)
            {
                price_high1 = close[idx];
                price_high_pos1 = idx;
            }
            if(close[idx] < price_low1)
            {
                price_low1 = close[idx];
                price_low_pos1 = idx;
            }
        }
        
        // Максимумы и минимумы индикатора
        if(idx >= 0 && idx < ArraySize(VFI_Buffer) && VFI_Buffer[idx] != EMPTY_VALUE)
        {
            if(VFI_Buffer[idx] > vfi_high1)
            {
                vfi_high1 = VFI_Buffer[idx];
                vfi_high_pos1 = idx;
            }
            if(VFI_Buffer[idx] < vfi_low1)
            {
                vfi_low1 = VFI_Buffer[idx];
                vfi_low_pos1 = idx;
            }
        }
    }
    
    // Находим вторые экстремумы
    double price_high2 = price_high1;
    double price_low2 = price_low1;
    double vfi_high2 = vfi_high1;
    double vfi_low2 = vfi_low1;
    int price_high_pos2 = -1;
    int price_low_pos2 = -1;
    int vfi_high_pos2 = -1;
    int vfi_low_pos2 = -1;
    
    int second_start = MathMax(0, start_pos - range / 2 - 1);
    int second_end = MathMax(0, start_pos - range);
    
    for(int i = second_start; i >= second_end; i--)
    {
        // Максимумы и минимумы цены
        if(i < ArraySize(close))
        {
            if(close[i] > price_high2)
            {
                price_high2 = close[i];
                price_high_pos2 = i;
            }
            if(close[i] < price_low2)
            {
                price_low2 = close[i];
                price_low_pos2 = i;
            }
        }
        
        // Максимумы и минимумы индикатора
        if(i < ArraySize(VFI_Buffer) && VFI_Buffer[i] != EMPTY_VALUE)
        {
            if(VFI_Buffer[i] > vfi_high2)
            {
                vfi_high2 = VFI_Buffer[i];
                vfi_high_pos2 = i;
            }
            if(VFI_Buffer[i] < vfi_low2)
            {
                vfi_low2 = VFI_Buffer[i];
                vfi_low_pos2 = i;
            }
        }
    }
    
    // Проверяем бычью дивергенцию: цены делают более низкие минимумы, индикатор - более высокие
    if(price_low_pos2 >= 0 && vfi_low_pos2 >= 0 &&
       price_low2 < price_low1 && vfi_low2 > vfi_low1)
    {
        return true;
    }
    
    // Проверяем медвежью дивергенцию: цены делают более высокие максимумы, индикатор - более низкие
    if(price_high_pos2 >= 0 && vfi_high_pos2 >= 0 &&
       price_high2 > price_high1 && vfi_high2 < vfi_high1)
    {
        return true;
    }
    
    return false;
}

//+------------------------------------------------------------------+
//| Custom indicator iteration function                              |
//+------------------------------------------------------------------+
int OnCalculate(const int rates_total,
                const int prev_calculated,
                const datetime &time[],
                const double &open[],
                const double &high[],
                const double &low[],
                const double &close[],
                const long &tick_volume[],
                const long &volume[],
                const int &spread[])
{
    // Минимальное количество баров для расчета
    int min_bars = VFI_Length + 50;
    if(rates_total < min_bars)
        return(0);
    
    // ИСПРАВЛЕНИЕ: При изменении настроек пересчитываем все
    bool recalculate_all = false;
    if(prev_calculated == 0 || last_calculated > prev_calculated)
    {
        recalculate_all = true;
        last_calculated = 0;
        
        Print("ℹ️ ", GetLocalizedText("settings_changed"));
        
        // Инициализируем буферы
        ArrayInitialize(VFI_Buffer, EMPTY_VALUE);
        ArrayInitialize(VFI_EMA_Buffer, EMPTY_VALUE);
        ArrayInitialize(Histogram_Buffer, EMPTY_VALUE);
        ArrayInitialize(Buy_Signal_Buffer, EMPTY_VALUE);
        ArrayInitialize(Sell_Signal_Buffer, EMPTY_VALUE);
        ArrayInitialize(DoubleBottom_Buffer, EMPTY_VALUE);
        ArrayInitialize(DoubleTop_Buffer, EMPTY_VALUE);
        ArrayInitialize(Divergence_Buffer, EMPTY_VALUE);
        ArrayInitialize(Risk_Buffer, EMPTY_VALUE);
        ArrayInitialize(Risk_Colors_Buffer, 0);
        ArrayInitialize(VCP_Buffer, 0.0);
        
        // Сбрасываем состояние зон
        dynamic_overbought_level = 0;
        dynamic_oversold_level = 0;
        
        // Удаляем объекты зон
        ObjectDelete(0, overbought_zone_id);
        ObjectDelete(0, oversold_zone_id);
        ObjectDelete(0, overbought_line_id);
        ObjectDelete(0, oversold_line_id);
    }
    
    // Изменяем размер буфера тренда при необходимости
    if(ArraySize(trend_buffer) != rates_total || recalculate_all)
        ArrayResize(trend_buffer, rates_total);
    
    //--- resize calculation arrays
    if(ArraySize(inter_array) != rates_total || recalculate_all)
    {
        ArrayResize(inter_array, rates_total);
        ArrayResize(typical_array, rates_total);
        ArrayResize(volatility_array, rates_total);
        ArrayResize(price_array, rates_total);
        ArrayInitialize(inter_array, 0.0);
        ArrayInitialize(typical_array, 0.0);
        ArrayInitialize(volatility_array, 0.0);
        ArrayInitialize(price_array, 0.0);
    }
    
    // Определяем начальную позицию для расчета
    int start;
    if(recalculate_all)
    {
        start = min_bars;
    }
    else
    {
        start = MathMax(prev_calculated - 1, min_bars);
    }
    
    //--- calculate typical prices and inter values from the beginning
    int calc_start = recalculate_all ? 1 : MathMax(1, start - 100);
    
    for(int i = calc_start; i < rates_total; i++)
    {
        // ИСПРАВЛЕНИЕ: Проверяем валидность цен
        if(high[i] <= 0 || low[i] <= 0 || close[i] <= 0)
        {
            typical_array[i] = i > 0 ? typical_array[i-1] : close[i];
            price_array[i] = close[i];
        }
        else
        {
            typical_array[i] = (high[i] + low[i] + close[i]) / 3.0;
            price_array[i] = close[i];
        }
        
        if(i > 0 && typical_array[i-1] > 0 && typical_array[i] > 0)
        {
            double log_diff = MathLog(typical_array[i]) - MathLog(typical_array[i-1]);
            // ИСПРАВЛЕНИЕ: Ограничиваем экстремальные значения
            if(MathAbs(log_diff) > 1.0) // Ограничение на 100% изменение
                log_diff = log_diff > 0 ? 1.0 : -1.0;
            inter_array[i] = log_diff;
        }
        else
        {
            inter_array[i] = 0.0;
        }
    }
    
    // Основной расчет VFI начинаем только после расчета всех промежуточных значений
    for(int i = start; i < rates_total; i++)
    {
        //--- calculate vinter (standard deviation of inter over 30 periods)
        double vinter = CalculateStdDev(i, MathMin(30, i));
        
        // ИСПРАВЛЕНИЕ: Защита от слишком маленьких значений
        if(vinter < 0.0001)
            vinter = 0.0001;
        
        //--- calculate cutoff
        double cutoff = Coef * vinter * close[i];
        
        //--- calculate volume average over VFI_Length periods
        double vave = 0.0;
        int vol_start = MathMax(0, i - VFI_Length);
        int vol_count = 0;
        
        // Determine which volumes to use
        bool use_real = UseRealVolume && real_volumes_available;
        
        for(int j = vol_start; j < i; j++)
        {
            double vol_value = use_real ? (double)volume[j] : (double)tick_volume[j];
            if(vol_value > 0) // Исключаем нулевые объемы
            {
                vave += vol_value;
                vol_count++;
            }
        }
        
        // ИСПРАВЛЕНИЕ: Защита от деления на ноль
        if(vol_count > 0)
            vave /= (double)vol_count;
        else
            vave = use_real ? (double)volume[i] : (double)tick_volume[i];
            
        if(vave <= 0)
            vave = 1.0; // Минимальное значение
        
        //--- calculate vmax
        double vmax = vave * VCoef;
        
        //--- calculate vc (min of current volume and vmax)
        double vol_current = use_real ? (double)volume[i] : (double)tick_volume[i];
        if(vol_current <= 0)
            vol_current = vave; // Используем среднее значение
            
        double vc = MathMin(vol_current, vmax);
        
        //--- calculate mf (money flow)
        double mf = 0.0;
        if(i > 0)
            mf = typical_array[i] - typical_array[i-1];
        
        //--- calculate vcp
        double vcp = 0.0;
        if(mf > cutoff)
            vcp = vc;
        else if(mf < -cutoff)
            vcp = -vc;
        else
            vcp = 0.0;
        
        VCP_Buffer[i] = vcp;
        
        //--- calculate VFI (sum of vcp over VFI_Length periods divided by vave)
        double vcp_sum = 0.0;
        int vcp_start = MathMax(0, i - VFI_Length + 1);
        for(int j = vcp_start; j <= i; j++)
        {
            vcp_sum += VCP_Buffer[j];
        }
        
        // ИСПРАВЛЕНИЕ: Дополнительная защита от больших значений
        double vfi_raw = vcp_sum / vave;
        if(MathAbs(vfi_raw) > 1000) // Ограничиваем максимальное значение
            vfi_raw = vfi_raw > 0 ? 1000 : -1000;
        
        //--- apply smoothing if needed (SMA with period 3)
        if(SmoothVFI && i >= start + 2)
        {
            double vfi_sum = vfi_raw;
            int count = 1;
            
            for(int j = 1; j <= 2 && (i-j) >= start; j++)
            {
                if(VFI_Buffer[i-j] != EMPTY_VALUE)
                {
                    vfi_sum += VFI_Buffer[i-j];
                    count++;
                }
            }
            
            VFI_Buffer[i] = vfi_sum / count;
        }
        else
        {
            VFI_Buffer[i] = vfi_raw;
        }
        
        //--- calculate VFI EMA
        if(i == start || VFI_EMA_Buffer[i-1] == EMPTY_VALUE)
        {
            VFI_EMA_Buffer[i] = VFI_Buffer[i];
        }
        else
        {
            double alpha = 2.0 / (SignalLength + 1.0);
            VFI_EMA_Buffer[i] = alpha * VFI_Buffer[i] + (1.0 - alpha) * VFI_EMA_Buffer[i-1];
        }
        
        //--- calculate histogram
        if(ShowHisto)
            Histogram_Buffer[i] = VFI_Buffer[i] - VFI_EMA_Buffer[i];
        else
            Histogram_Buffer[i] = EMPTY_VALUE;
            
        //--- Calculate buy and sell signals
        Buy_Signal_Buffer[i] = EMPTY_VALUE;
        Sell_Signal_Buffer[i] = EMPTY_VALUE;
        
        if(i > 0 && VFI_Buffer[i] != EMPTY_VALUE && VFI_Buffer[i-1] != EMPTY_VALUE && 
           VFI_EMA_Buffer[i] != EMPTY_VALUE && VFI_EMA_Buffer[i-1] != EMPTY_VALUE)
        {
            // Buy signal: VFI crosses above EMA
            bool buy_signal = (VFI_Buffer[i-1] < VFI_EMA_Buffer[i-1] && VFI_Buffer[i] > VFI_EMA_Buffer[i]);
            
            if(buy_signal)
            {
                Buy_Signal_Buffer[i] = VFI_Buffer[i] - 0.0005; // Place slightly below the VFI line
                
                // Отправка алерта на сигнал покупки
                if(EnableAlerts || EnableNotifications)
                {
                    string alert_message = Symbol() + ": " + GetLocalizedText("buy_signal_detected") + " @ " +
                                        TimeToString(time[i], TIME_DATE|TIME_MINUTES);
                    SendAlert(alert_message, time[i]);
                }
            }
            
            // Sell signal: VFI crosses below EMA
            bool sell_signal = (VFI_Buffer[i-1] > VFI_EMA_Buffer[i-1] && VFI_Buffer[i] < VFI_EMA_Buffer[i]);
            
            if(sell_signal)
            {
                Sell_Signal_Buffer[i] = VFI_Buffer[i] + 0.0005; // Place slightly above the VFI line
                
                // Отправка алерта на сигнал продажи
                if(EnableAlerts || EnableNotifications)
                {
                    string alert_message = Symbol() + ": " + GetLocalizedText("sell_signal_detected") + " @ " +
                                        TimeToString(time[i], TIME_DATE|TIME_MINUTES);
                    SendAlert(alert_message, time[i]);
                }
            }
        }
        
        //--- Pattern Detection (если включено)
        if(ShowPatterns && i > VFI_Length * 2)
        {
            // Сохраняем информацию о паттернах для информационной панели, но не создаем стрелки на графике
            
            // Определение двойного дна
            if(IsDoubleBottom(i, VFI_Length))
            {
                DoubleBottom_Buffer[i] = VFI_Buffer[i]; // Только для расчетов
                
                // Отправка алерта на паттерн двойного дна
                if(EnableAlerts || EnableNotifications)
                {
                    string alert_message = Symbol() + ": " + GetLocalizedText("double_bottom_detected") + " @ " +
                                        TimeToString(time[i], TIME_DATE|TIME_MINUTES);
                    SendAlert(alert_message, time[i]);
                }
            }
            
            // Определение двойной вершины
            if(IsDoubleTop(i, VFI_Length))
            {
                DoubleTop_Buffer[i] = VFI_Buffer[i]; // Только для расчетов
                
                // Отправка алерта на паттерн двойной вершины
                if(EnableAlerts || EnableNotifications)
                {
                    string alert_message = Symbol() + ": " + GetLocalizedText("double_top_detected") + " @ " +
                                        TimeToString(time[i], TIME_DATE|TIME_MINUTES);
                    SendAlert(alert_message, time[i]);
                }
            }
            
            // Определение дивергенции - используем непосредственно close[], а не ChartClose()
            double close_data[];
            int copied = CopyClose(Symbol(), PERIOD_CURRENT, i - VFI_Length, VFI_Length + 1, close_data);
            
            if(copied > 0)
            {
                if(IsDivergence(i, VFI_Length, close_data))
                {
                    Divergence_Buffer[i] = VFI_Buffer[i]; // Только для расчетов
                    
                    // Отправка алерта на паттерн дивергенции
                    if(EnableAlerts || EnableNotifications)
                    {
                        string alert_message = Symbol() + ": " + GetLocalizedText("divergence_detected") + " @ " +
                                            TimeToString(time[i], TIME_DATE|TIME_MINUTES);
                        SendAlert(alert_message, time[i]);
                    }
                }
            }
        }
        
        //--- Risk Assessment
        double risk_value = 0.0;
        ENUM_RISK_LEVEL risk_level = CalculateRiskLevel(i, RiskAssessmentPeriod, risk_value);
        
        // Устанавливаем значение и цвет риска
        Risk_Buffer[i] = risk_value * 0.5; // Масштабируем для отображения
        Risk_Colors_Buffer[i] = (double)risk_level;
        
        //--- Trend Assessment
        double trend_strength = 0;
        ENUM_TREND_DIRECTION trend_direction = DetermineTrend(i, TrendPeriod, trend_strength);
        trend_buffer[i] = (double)trend_direction * trend_strength; // Записываем в буфер тренда
        
        // Применяем динамическое изменение цветов
        if(EnableDynamicColors)
            UpdateDynamicColors(i);
    }
    
    // Периодически пересчитываем уровни перекупленности/перепроданности
    // На первой итерации или если уровни еще не установлены, обязательно пересчитываем
    if(prev_calculated == 0 || dynamic_overbought_level == 0 || dynamic_oversold_level == 0)
    {
        CalculateOverboughtOversoldLevels(rates_total - 1);
    }
    else if((rates_total - 1) % 100 == 0) // Пересчитываем каждые 100 баров
    {
        CalculateOverboughtOversoldLevels(rates_total - 1);
    }
    
    // После основных расчетов обновляем зоны
    UpdateZoneObjects(rates_total-1);
    
    // После основных расчетов обновляем информационную панель
    if(ShowInfoPanel)
    {
        UpdateInfoPanel(rates_total-1, time);
    }
    
    last_calculated = rates_total;
    return(rates_total);
}

//+------------------------------------------------------------------+
//| Calculate Standard Deviation for inter values - IMPROVED        |
//+------------------------------------------------------------------+
double CalculateStdDev(int pos, int period)
{
    if(pos < 1 || period < 1)
        return(0.0001); // Минимальное значение вместо 0
    
    int actual_period = MathMin(period, pos + 1);
    int start_pos = pos - actual_period + 1;
    
    //--- calculate mean
    double mean = 0.0;
    int valid_count = 0;
    
    for(int i = start_pos; i <= pos; i++)
    {
        if(i >= 0 && i < ArraySize(inter_array))
        {
            mean += inter_array[i];
            valid_count++;
        }
    }
    
    if(valid_count == 0)
        return(0.0001);
        
    mean /= valid_count;
    
    //--- calculate variance
    double variance = 0.0;
    for(int i = start_pos; i <= pos; i++)
    {
        if(i >= 0 && i < ArraySize(inter_array))
        {
            variance += MathPow(inter_array[i] - mean, 2);
        }
    }
    variance /= valid_count;
    
    double std_dev = MathSqrt(variance);
    
    // ИСПРАВЛЕНИЕ: Возвращаем минимальное значение если результат слишком мал
    return(MathMax(std_dev, 0.0001));
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
    // Удаляем информационную панель
    if(ShowInfoPanel)
    {
        DeleteInfoPanel();
    }
    
    // Удаляем объекты зон
    ObjectDelete(0, overbought_zone_id);
    ObjectDelete(0, oversold_zone_id);
    ObjectDelete(0, overbought_line_id);
    ObjectDelete(0, oversold_line_id);
    
    string username = GetComputerUserName();
    string datetime_str = GetCurrentDateTime();
    
    Print(GetLocalizedText("indicator_finished"));
    Print(" ", GetLocalizedText("reason"), ": ", reason);
    Print(" ", GetLocalizedText("time"), ": ", datetime_str, " UTC");
    Print(" ", GetLocalizedText("user"), ": ", username);
}
